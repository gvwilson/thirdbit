---
title: "What Else for Software Carpentry?"
date: 2006-02-21
---
16 lectures are now in place (more or less), which means I have 8 more to do.  The syllabus shows what I've covered already; my current plans include:
<ul>
  <li>unit testing</li>
  <li>XML</li>
  <li>SQL</li>
  <li>more SQL</li>
  <li>small-team development process</li>
</ul>
What do you think the other three should cover (keeping in mind that this is supposed to be a course on basic software engineering, rather than scientific programming)?  Options include:
<ol>
  <li>Basic web programming, with much-revised versions of client, server, and security</li>
  <li>Integration, including:
<ul>
  <li>wrapping C code so that it can be called from Python</li>
  <li>using popen() and its ilk to run external programs</li>
  <li>(probably) something on refactoring to make code more testable (as per Feathers' excellent <em>Working Effectively with Legacy Code</em></li>
</ul>
</li>
  <li>Three lecture-length examples, building very simple versions of core tools that haven't been covered elsewhere:
<ul>
  <li>data lineage</li>
  <li>continuous integration</li>
  <li>data consistency checking</li>
</ul>
</li>
  <li>Give in, and do the scientific programming stuff anyway:
<ul>
  <li>floating-point arithmetic</li>
  <li>Python's Numeric package</li>
  <li>data visualization</li>
</ul>
</li>
  <li>Scrap the single lecture on development process, and put in four full lectures on the subject
<ul>
  <li>XP</li>
  <li>UML-based processes (probably ICONIX)</li>
  <li>something else (not entirely sure what)</li>
</ul>
</li>
  <li>Something else entirelyâ€”suggestions would be very welcome.</li>
</ol>
Please let me know what you think.
