---
title: "Prepping for Next Term"
date: 2007-12-15
---
I'm teaching two courses next term: CSC301 (Intro to Software Engineering) and a combination of CSC490 (undergraduate capstone project) and CSC2125 (graduate "topics in software engineering").  I'm hoping to do a better job with the former than I did this term, so I've started working on lectures. So far, the topics include:
<ul>
  <li>what the data actually says about software engineering (drawn from Glass's <a href="http://www.amazon.com/Facts-Fallacies-Software-Engineering-Development/dp/0321117425"><em>Facts and Fallacies of Software Engineering</em></a> and Endres & Rombach's <a href="http://www.amazon.com/Handbook-Software-Systems-Engineering-Observations/dp/0321154207"><em>Handbook of Software and Systems Engineering</em></a>)</li>
  <li>software process and lifecycles (agile vs. sturdy, with emphasis on the former)</li>
  <li>design patterns: mostly from <a href="http://www.amazon.com/Head-First-Design-Patterns/dp/0596007124"><em>Head First Design Patterns</em></a>—the format is condescending, but the content is excellent</li>
  <li>refactoring: drawn in part from Martin Fowler's <a href="http://www.amazon.com/Refactoring-Improving-Existing-Addison-Wesley-Technology/dp/0201485672"><em>Refactoring</em></a>, but also from Mike Feathers' excellent <a href="http://www.amazon.com/Working-Effectively-Legacy-Robert-Martin/dp/0131177052"><em>Working Effectively With Legacy Code</em></a></li>
  <li>software quality: both heuristics and metrics, with some discussion of empirical studies in software engineering—my main reference is Spinellis' <a href="http://www.amazon.com/Code-Quality-Perspective-Effective-Development/dp/0321166078"><em>Code Quality</em></a></li>
  <li>UML (I'm not a believer, but it <em>is</em> part of the standard curriculum</li>
  <li>testing: I'm assuming students are comfortable with JUnit, so these lectures cover both how to make code testable (Feathers again) and the framework in Meszaros' <a href="http://www.amazon.com/xUnit-Test-Patterns-Refactoring-Addison-Wesley/dp/0131495054"><em>xUnit Test Patterns</em></a>. I will also cover the nine rules from Agans' <a href="http://www.amazon.com/Debugging-Indispensable-Software-Hardware-Problems/dp/0814471684"><em>Debugging</em></a>, and borrow liberally from <a href="http://www.amazon.com/How-Break-Software-Practical-Testing/dp/0201796198">Whittaker's</a> <a href="http://www.amazon.com/How-Break-Web-Software-Applications/dp/0321369440">three</a> <a href="http://www.amazon.com/Break-Software-Security-James-Whittaker/dp/0321194330">books</a>.</li>
  <li>tooling: some intermediate topics in version control (branching and merging), build systems (especially ways of supporting different configurations in a single build file), and ticketing</li>
  <li>the last ten yards (i.e., creating installers, deploying software, and making it work in production environments): my only reference so far is Nygard's <a href="http://www.amazon.com/Release-Production-Ready-Software-Pragmatic-Programmers/dp/0978739213"><em>Release It!</em></a>—lots of other books wave their hands about these issues, or provide tutorials on how to use some vendor or other's installer creator, but I'm looking for something in between)</li>
  <li>security: I think Smith and Marchesini's <a href="http://www.amazon.com/Craft-System-Security-Sean-Smith/dp/0321434838"><em>Craft of System Security</em></a> is at the right level, but I'm going to borrow from many others.</li>
  <li>ethical issues, particularly liability and licensure.</li>
</ul>
It's a lot to cram into 26 lectures, some tutorials (which will probably consist of guest speakers from industry), and four assignments, but with help from Colin and Roy at <a href="http://refreshpartners.com/">Refresh Partners</a> (makers of fine Facebook plugins), I think it'll work.

The combined capstone/graduate course doesn't have a well-defined syllabus yet. Students will work in pairs on real projects with real customers; the current list of proposals includes open source organizations, non-profits, academics from other departments on campus, and a few local companies. After the first class (in which I'll present the projects Ignite-style, and students will decide what to work on), the course will be held upstairs at Molly Bloom's (a local pub).  I figure this will facilitate free and frank discussion ;-)

And of course, my grad students will be starting their thesis work. Samira wants to apply machine learning techniques to requirements management (see for example the work of <a href="http://selab.netlab.uky.edu/homepage/">Jane Huffman Hayes</a>, or Anvik, Hew, and Murphy's "<a href="http://www.cs.ubc.ca/labs/spl/projects/bugTriage/papers/icse2006.pdf">Who Should Fix This Bug?</a>"), and Jeremy is interested in software project visualization (or "dashboards on steroids"), while Carolyn and Jon are still trying to nail down specific topics. It's going to be a lot of work, but I'm looking forward to it.
