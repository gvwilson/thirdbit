---
title: "More Public Embarrassment About Workflows"
date: 2010-01-10
---
Thanks to everyone for the comments on my recent post about web workflows and public embarrassment. I have two of my own to add:
<ol>
  <li>I've looked at tools like <a href="http://seleniumhq.org/">Selenium</a>, but making them do what I want is more effort than it's worth. For example, when a new student joins <a href="http://ucosp.wordpress.com">UCOSP</a>, I have to go to the <a href="http://maps.google.com/maps/ms?ie=UTF8&amp;hl=en&amp;msa=0&amp;msid=100156001803519969567.00047bf69ca81288680da&amp;ll=35.960223,-94.130859&amp;spn=35.566761,74.443359&amp;z=4">Google map</a> that shows where participants are from and add her (or him) to the pointer for her (or his) school. That means parameterization, 'switch' logic, and pattern matching on strings, all of which I'd be happy to do in Python (but only if there was a sandbox in which to test my script, which web applications don't provide).</li>
  <li>I've run into a similar frustration (at least, it feels similar to me) with iTunes. Djole's <em>Indiscretion</em> is one of my favorite albums, but when I import it, iTunes decides that it's actually a mid-80s recording of the Brandenburg Concertos. I presume this is because some identifier in the album data is being mis-matched to a database, but what actually bothers me is how hard it is to override. There doesn't seem to be a way to say "this whole album is actually over <em>there</em>, you silly mis-interpreted assemblage of bytecodes."</li>
</ol>
What ties these two cases together is the notion of computational thinking. Almost by definition, novices (in any domain) don't know enough to have "gut instincts" about how easy things ought to be, or to come up with plausible diagnoses when things go wrong. Someone with a few years of experience, on the other hand, can look at most problems and say, "OK, it <em>should</em> be easy to do," and to have some notion of what the fix could be. I personally believe that the only way to develop those instincts for computational tasks is to actually programâ€”I don't believe that anything worth calling "computational thinking" can be acquired in any other way. (See here and here for earlier discussion of this point.)
