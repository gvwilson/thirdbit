---
layout: page
title: "Not on the Shelves"
subtitle: "Version 5 / 2017"
---

[This discussion of sympathetic magic](../)
explains why I've written reviews of books that don't exist (yet).

## *Sex and Drugs and Guns and Code: What Everyone in Tech Needs to Know About Politics, Economics, and Power*

Inspired by books like
*[Physics for Future Presidents](https://www.amazon.com/Physics-Future-Presidents-Science-Headlines/dp/0393066274/)*
and
*[The Imposter's Handbook](https://bigmachine.io/products/the-imposters-handbook)*,
this book is aimed at people who need to understand the big picture,
but have limited time in which to do it.
Rather than science or programming,
it introduces ideas and methods that are commonplace in the social sciences,
and by doing so illustrates that "the way things are" is neither inevitable nor accidental.
From the reasons racial discrimination persists despite its illogical economic inefficiency
to the ways in which "flat" organizations actually operate,
it gives readers a toolbox for thinking about the society that tech is reshaping for both better and worse.

## *The Undergraduate Operator's Manual*

What effect does pulling an all-nighter have on the quality of your work?
How do people absorb and retain knowledge?
What are some good ways to run a project meeting,
and how can you get people to actually pull their weight?
Every undergraduate has to deal with these issues and a hundred others,
but most of the time,
they are expected to rediscover or reinvent methods themselves.
This textbook for a one-semester course puts solutions in one place,
and by doing so teaches a lot about physiology, psychology, and organizational behavior.

## *Software Tools in JavaScript*

*[Software Tools](http://www.amazon.com/Software-Tools-Brian-W-Kernighan/dp/020103669X/)*
and its sequel *[Software Tools in Pascal](http://www.amazon.com/Software-Tools-Pascal-Brian-Kernighan/dp/0201103427/)*
were two of the most influential books in the history of computing,
as they introduced a whole generation of programmers to the Unix philosophy of tool-based computing.
In retrospect,
one of the reasons that philosophy succeeded was its reliance on a universal data format (strings of ASCII text)
and communication protocol (standard input and standard output).
This book's starting point is the now-commonplace observation that JavaScript, HTTP, and JSON have taken their place,
and shows readers how to build a suite of ever-more-sophisticated tools for assembling web-based applications that use them.
Drawing from sources as diverse as
Jon Udell's "[Seven Ways to Think Like the Web](http://blog.jonudell.net/2011/01/24/seven-ways-to-think-like-the-web/)",
the [Kinetic Rule Language](http://en.wikipedia.org/wiki/Kinetic_Rule_Language),
and the mostly-functional model associated with [Elm](http://elm-lang.org/) and [Redux](https://redux.js.org/),
it presents a "new standard model" based on syndication of distributed streams of events.

## *Research Computing from A to B*

This book is a hands-on introduction to practical computing skills
aimed at graduate students and professionals in research-intensive disciplines.
The core topics–data management, structured programming, task automation, and version control–are introduced
through a series of short tutorials,
then elaborated with further lessons on using the web to share data,
creating reproducible workflows,
cleaning data,
and testing software when the right answer isn't actually known.
While it necessarily glosses over many fine points,
it gives readers a useful toolkit and a sense of where to go next.

## *Managing Research Software Projects*

Your graduate degree is in ecology,
but now you're running a three-person team responsible for building and maintaining a hundred thousand lines of code?
This book is an overview of everything you absolutely, positively need to know
*after* you know how to program:
[marketing](https://www.amazon.com/Marketing-Scientists-Shine-Tough-Times/dp/1597269948/),
[community management](http://producingoss.com),
[leading a lab](https://www.amazon.com/At-Helm-Leading-Laboratory-Second/dp/0879698667/),
and [basic finance](http://ecampus.oregonstate.edu/soc/ecatalog/downloadsyllabus.htm?docid=2641&subject=PSM&cn=565).
We've [made a start](https://swcarpentry.github.io/managing-research-software-projects/),
but there's a lot still to be done.

## *Software Engineering: An Evidence-Based Approach*

Unlike their counterparts in physics, psychology, and engineering,
most students in computer science don't do experiments.
As a result,
they graduate not knowing how to get data,
clean it up,
model it,
and draw conclusions from it.
This innovative textbook corrects that:
it tackles simple real-world problems using basic statistical methods
and data harvested from actual software projects.
Its larger message is that opinions about software should be based on evidence
rather than hearsay and strong opinions.

## *Computing and the Law: A Guide for the Perplexed*

The legal aspects of software have always been complicated;
the web has done nothing to make them simpler.
This book seeks to help programmers understand the rules (or lack thereof)
they have to live with
by tracing the historical development of patents, copyrights, privacy, and professional liability
from the Industrial Revolution to the present day.
Aimed squarely at people with no prior exposure to legal terminology,
it explains concepts clearly and provides examples for each.

## *Software Architecture by Example*

Architects study hundreds of buildings during their training;
writers read hundreds of novels,
and mathematicians study at least that many proofs.
In contrast,
most software engineers only explore a handful of medium-sized programs during their training.
This book corrects that by contrasting alternative implementations of key features of open source applications.
Whether it's the undo/redo stacks of Vim and Emacs,
how Apache and Nginx manage user plugins,
or the way that React and Angular decide what to re-render,
each paired example serves as a springboard for larger discussion of how software is designed
and how tradeoffs are made.

## *Now What? A Practitioner's Guide to Error Handling*

Programs can fail in a hundred different ways,
but most programmers either ignore the possibility of failure
or deal with it by printing a log message.
This book presents examples of what they could do instead,
from data structure repair to automatically restarting servers.
Along the way,
it catalogs the kinds of errors that programmers may encounter
and shows how they can be prevented as well as managed.

## *A Practical Introduction to Debugging*

Most programmers spend a large part of their time debugging,
but most books only show working code,
and never discuss how to prevent, diagnose, and fix errors.
[Most](http://www.amazon.com/Debugging-Indispensable-Software-Hardware-Problems/dp/0814474578/)
[books](http://www.amazon.com/Debugging-Thinking-Multidisciplinary-Approach-Technologies/dp/1555583075/)
[ostensibly](http://www.amazon.com/Debug-It-Prevent-Pragmatic-Programmers/dp/193435628X/)
[about](http://www.amazon.com/The-Developers-Guide-Debugging-Edition/dp/1470185520/)
[debugging](http://www.amazon.com/The-Art-Debugging-GDB-Eclipse/dp/1593271743/)
are either high-level handwaving ("Make sure you're solving the right problem"),
user's guides for particular debugging tools,
or [out of date](http://www.amazon.com/Find-Bug-Book-Incorrect-Programs/dp/0321223918/).
The one notable exception,
Zeller's *[Why Programs Fail](http://www.amazon.com/Why-Programs-Fail-Second-Edition/dp/0123745152/)*,
is an excellent read,
but too advanced for most undergraduates.
This book fills that gap by combining an exploration of how debugging tools actually work
with dozens of case studies showing how to apply them to real-world problems.
And while the author only occasionally makes this explicit,
the book also shows how to write programs that are easier to fix.

## *300 Lines of Science*

Can you write a climate simulator in less than 500 lines of Python?
What about constructing phylogenetic trees in less than 500 lines of R?
This collection would show readers how science is turned into code across a broad range of disciplines.
Each entry is less than 300 lines of code in the style of *[500 Lines or Less](http://aosabook.org/en/index.html#500lines)
supplemented by an equal-sized chunk showing how to test what has been written.

## *Performance Tuning*

In the spirit of Jon Louis Bentley's *[Writing Efficient Programs](https://www.amazon.com/Writing-Efficient-Programs-Prentice-Hall-Software/dp/013970244X/)*,
this textbook shows readers how to model, analyze, and improve the performance of their programs.
Written for undergraduates who already have a basic understanding of computer architecture, compilers, operating systems, and networks,
it can be used in a capstone course that unifies ideas from these subjects.
