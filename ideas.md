---
layout: default
permalink: /ideas/
title: "Ideas"
redirect_from: "/not-on-the-shelves/2017.html"
---

<div class="well" markdown="1">

# Ideas

These ideas are things I might have done if I hadn't done [Software Carpentry](http://software-carpentry.org).
Many are presented as [descriptions of books that don't yet
exist]({{site.github.url}}/not-on-the-shelves/) becauase I still
believe that a good book can change the world.  If you'd like to help
with any of them, or take one on yourself, please let me know.

## Books

_**Sex and Drugs and Guns and Code: What Everyone in Tech Needs to Know About Politics, Economics, and Power**_

Inspired by books like
*[Physics for Future Presidents](https://www.amazon.com/Physics-Future-Presidents-Science-Headlines/dp/0393066274/)*
and
*[The Imposter's Handbook](https://bigmachine.io/products/the-imposters-handbook)*,
this book is aimed at people who need to understand the big picture,
but have limited time in which to do it.
Rather than science or programming,
it introduces ideas and methods that are commonplace in the social sciences,
and illustrates that "the way things are" is neither inevitable nor accidental.
From the reasons racial discrimination persists despite its illogical economic inefficiency
to the ways in which "flat" organizations actually operate
and how [cognitive biases affect us all](http://mentalfloss.com/article/68705/20-cognitive-biases-affect-your-decisions),
it gives readers [a toolbox for thinking about society]({{site.github.url}}/reading/):
the society that tech is reshaping for both better and worse.

_**The Undergraduate Operator's Manual**_

What effect does pulling an all-nighter have on the quality of your work?
How do people absorb and retain knowledge?
What are some good ways to run a project meeting,
and how can you get people to actually pull their weight?
Every undergraduate has to deal with these issues and a hundred others,
but most of the time,
they are expected to rediscover or reinvent methods themselves.
This textbook for a one-semester course puts solutions in one place,
and by doing so teaches a lot about physiology, psychology, and organizational behavior.

_**Software Tools in JavaScript**_

*[Software Tools](http://www.amazon.com/Software-Tools-Brian-W-Kernighan/dp/020103669X/)*
and its sequel *[Software Tools in Pascal](http://www.amazon.com/Software-Tools-Pascal-Brian-Kernighan/dp/0201103427/)*
were introduced a whole generation of programmers to the Unix philosophy of tool-based computing.
This book's starting point is the observation that JavaScript, HTTP, and JSON have taken the place of strings of ASCII and standard I/O.
Drawing from sources as diverse as
Jon Udell's "[Seven Ways to Think Like the Web](http://blog.jonudell.net/2011/01/24/seven-ways-to-think-like-the-web/)",
the [Kinetic Rule Language](http://en.wikipedia.org/wiki/Kinetic_Rule_Language),
and the mostly-functional model associated with [Elm](http://elm-lang.org/) and [Redux](https://redux.js.org/),
it presents a "new standard model" based on syndication of distributed streams of events,
and shows readers how the tools they use are built,
and how to build tools of their own.

_**Research Computing from A to B**_

Based on the workshops run by [Software Carpentry](http://software-carpentry.org) and [Data Carpentry](http://datacarpentry.org),
this book is a hands-on introduction to practical computing skills
aimed at graduate students and professionals in research-intensive disciplines.
The core topics–data management, structured programming, task automation, and version control–are introduced
through a series of short tutorials,
then elaborated with further lessons on using the web to share data,
creating reproducible workflows,
cleaning data,
and testing software when the right answer isn't actually known.
While it necessarily glosses over many fine points,
it gives readers a useful toolkit and a sense of where to go next.

_**Managing Research Software Projects**_

Your graduate degree is in ecology,
but now you're running a three-person team responsible for building and maintaining a hundred thousand lines of code?
This book is an overview of everything you absolutely, positively need to know
*after* you know how to program:
[marketing](https://www.amazon.com/Marketing-Scientists-Shine-Tough-Times/dp/1597269948/),
[community management](http://producingoss.com),
[leading a lab](https://www.amazon.com/At-Helm-Leading-Laboratory-Second/dp/0879698667/),
and [basic finance](http://ecampus.oregonstate.edu/soc/ecatalog/downloadsyllabus.htm?docid=2641&subject=PSM&cn=565).
We've [made a start](https://swcarpentry.github.io/managing-research-software-projects/),
but there's a lot still to be done.

_**Software Engineering: An Evidence-Based Approach**_

Unlike their counterparts in physics, psychology, and engineering,
most students in computer science don't do experiments.
As a result,
they graduate not knowing how to get data,
clean it up,
model it,
and draw conclusions from it.
This innovative textbook corrects that:
it tackles simple real-world problems using basic statistical methods
and data harvested from actual software projects.
Its larger message is that opinions about software should be based on evidence
rather than hearsay and strong opinions.
(Derek Jones' *[Empirical Software Engineering Using R](http://www.knosof.co.uk/ESEUR/)*
is headed in this direction.)

_**Computing and the Law: A Guide for the Perplexed**_

The legal aspects of software have always been complicated;
the web has done nothing to make them simpler.
This book seeks to help programmers understand the rules (or lack thereof)
they have to live with
by tracing the historical development of patents, copyrights, privacy, and professional liability
from the Industrial Revolution to the present day.
Aimed squarely at people with no prior exposure to legal terminology,
it explains concepts clearly and provides examples for each.

_**Software Architecture by Example**_

Architects study hundreds of buildings during their training;
writers read hundreds of novels,
and mathematicians study at least that many proofs.
In contrast,
most software engineers only explore a handful of medium-sized programs during their training.
This book corrects that by contrasting alternative implementations of key features of open source applications.
Whether it's the undo/redo stacks of Vim and Emacs,
how Apache and Nginx manage user plugins,
or the way that React and Angular decide what to re-render,
each paired example serves as a springboard for larger discussion of how software is designed
and how tradeoffs are made.
The book draws material from *[The Architecture of Open Source Applications](http://aosabook.org)*,
but is a tutorial rather than a survey.

_**A Practical Introduction to Debugging**_

Most programmers spend a large part of their time debugging,
but most books only show working code,
and never discuss how to prevent, diagnose, and fix errors.
[Most](http://www.amazon.com/Debugging-Indispensable-Software-Hardware-Problems/dp/0814474578/)
[books](http://www.amazon.com/Debugging-Thinking-Multidisciplinary-Approach-Technologies/dp/1555583075/)</a>
[ostensibly](http://www.amazon.com/Debug-It-Prevent-Pragmatic-Programmers/dp/193435628X/)</a>
[about](http://www.amazon.com/The-Developers-Guide-Debugging-Edition/dp/1470185520/)</a>
[debugging](http://www.amazon.com/The-Art-Debugging-GDB-Eclipse/dp/1593271743/)</a>
are either high-level handwaving ("Make sure you're solving the right problem")
user's guides for particular debugging tools,
or [out of date](http://www.amazon.com/Find-Bug-Book-Incorrect-Programs/dp/0321223918/).
The one notable exception,
Zeller's *[Why Programs Fail](http://www.amazon.com/Why-Programs-Fail-Second-Edition/dp/0123745152/)*,
is an excellent read,
but too advanced for most undergraduates.
This book fills that gap by combining an exploration of how debugging tools actually work
with dozens of case studies showing how to apply them to real-world problems.
And while the author only occasionally makes this explicit,
the book also shows how to write programs that are easier to fix.

_**Now What? A Practitioner's Guide to Error Handling**_

Programs can fail in a hundred different ways,
but most programmers either ignore the possibility of failure
or deal with it by printing a log message.
This companion to *A Practical Introduction to Debugging* presents examples of what they could do instead,
from data structure repair to automatically restarting servers.
Along the way,
it catalogs the kinds of errors that programmers may encounter
and shows how they can be prevented as well as managed.

_**300 Lines of Science**_

Can you write a climate simulator in less than 500 lines of Python?
What about constructing phylogenetic trees in less than 500 lines of R?
This collection would show readers how science is turned into code across a broad range of disciplines.
Each entry is less than 300 lines of code in the style of *[500 Lines or Less](http://aosabook.org/en/index.html#500lines)
supplemented by an equal-sized chunk showing how to test what has been written.

_**Performance Tuning**_

In the spirit of Jon Louis Bentley's *[Writing Efficient Programs](https://www.amazon.com/Writing-Efficient-Programs-Prentice-Hall-Software/dp/013970244X/)*,
this textbook shows readers how to model, analyze, and improve the performance of their programs.
Written for undergraduates who already have a basic understanding of computer architecture, compilers, operating systems, and networks,
it can be used in a capstone course that unifies ideas from these subjects.

## Projects

**Teach programmers how to run grassroots get-into-coding groups**

Programmers create get-into-coding groups so that people won't have to
teach themselves how to write Javascript, then reinvent wheels when it
comes to teaching, running a non-profit, or organizing a community. I
am adding a section to *[How to Teach](/teaching/)* that draws on the
experience of [Software Carpentry](http://software-carpentry.org) and
books like *[Building Powerful Community Organizations](https://www.amazon.com/Building-Powerful-Community-Organizations-Personal/dp/0977151808/)*
to fill that gap.

**Browsercast**

Allow people to create synchronized voiceovers for HTML slideshows.
I've had several summer students take a run at this; the hard part
is the authoring tool to add time marks, but as the demo linked in
the title shows, the idea itself works.

**Diff and merge for common document formats**

Version control is a powerful idea,
but it depends on people being able to work independently,
then see what they've changed and merge those differences.
Unfortunately,
none of today's open source version control systems can handle
the world's most common document formats:
Word, Excel, and PowerPoint.
A tool (or suite of tools) that could do this
would give millions of people an on-ramp instead of a cliff.

**An empirical comparison of the syntax of Python, R, MATLAB, and Julia**

We tried to repeat [Stefik et al's study of programming language
syntax](http://neverworkintheory.org/2014/01/29/stefik-siebert-syntax.html)
for languages commonly used in science, but weren't able to get
enough subjects. I think it's worth trying again, both for its own
sake and to show that this kind of work can and should be done.

**_[The Discussion Book](https://www.amazon.com/Discussion-Book-Great-People-Talking/dp/1119049717/)_ online**

Today's MOOC platforms use the Internet like television. What would
they look like if they directly supported some of the techniques
described in [this useful
book](https://www.amazon.com/Discussion-Book-Great-People-Talking/dp/1119049717/)?
Similarly, Caulfield's notion of [choral
explanations](https://hapgood.us/2016/05/13/choral-explanations/) has
me thinking that I've been mistaken in trying to treat lesson
construction as software development. A "lesson" platform that uses
Stack Overflow as its model rather than GitHub or Wikipedia would be
fascinating to explore, as would [collaborative choral software
exegesis]({{site.github.url}}/09/12/collaborative-choral-software-exegesis.html).

**Using machine learning to find actual design patterns**

I often use Sajaniemi et al's [roles of
variables](http://www.cs.joensuu.fi/~saja/var_roles/stud_vers/stud_Python3_eng.html)
in teaching, but like [the classic design
patterns](https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/),
they were "discovered" by eyeballing novice code. I think that
cluster analysis of patterns of class and variable use would uncover
more patterns, and confirm my suspicion that some of the classics
are really just different names for the same thing. Similarly, I
think that analysis of actual usage patterns could lay the
foundation for [the design of a better version control
system]({{site.github.url}}/2017/09/30/git-graphs-and-engineering.html).

**Numerical JavaScript**

Ten years from now,
I believe that JavaScript (or a derivative like TypeScript)
will have supplanted Python and R
as the language of choice for people doing leading-edge open scientific computing,
because no matter what else programmers use,
they eventually have to learn JavaScript.
More specifically,
I expect that the 5-15% of scientists who are early adopters of new technology
will bypass single-purpose languages like Julia
in favor of the one they already have to master
to create websites and use things like [D3](https://d3js.org/).
And with major players like Microsoft, Google, and Facebook all working hard
to make general-purpose JavaScript faster,
it will be harder and harder for niche players to keep up.

</div>
