<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<link rel="me" href="https://mastodon.social/@gvwilson">
<link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
<link rel="alternate" type="application/atom+xml" title="The Third Bit" href="../atom.xml">
<!-- <script defer data-domain="third-bit.com" src="https://plausible.io/js/plausible.js"></script> -->
    <script src="https://kit.fontawesome.com/4eee35f757.js"></script>
    <link rel="stylesheet" href="../assets/thirdbit.css">
    <link rel="stylesheet" href="../assets/page.css">
    
<title>The Third Bit Blog</title>

    
  </head>
  <body>
    <nav>
  <div class="row underline">
    <div class="col-2 left">
      <a class="navlink" href="../">Home</a>
    </div>
    <div class="col-10 right">
      <a class="navlink" href="../about/">about</a>
      <a class="navlink" href="../blog/">blog</a>
      <a class="navlink" href="../selected/">selected</a>
      <a class="navlink" href="../talks/">talks</a>
      <a class="navlink" href="../bib/">bibliography</a>
      <a class="navlink" href="../fiction/">fiction</a>
    </div>
  </div>
</nav>
    <main>
      
<h1>Blog</h1>


<table class="centered">
  <tbody>
    <tr>
      <td><a href="../archive/2020">2020</a></td>
      <td><a href="../archive/2021">2021</a></td>
      <td><a href="../archive/2022">2022</a></td>
      <td><a href="../archive/2023">2023</a></td>
      <td><a href="../archive/2024">2024</a></td>
      <td><a href="../archive/2025">2025</a></td>
      <td><a href="../archive/2026">2026</a></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td><a href="../archive/2010">2010</a></td>
      <td><a href="../archive/2011">2011</a></td>
      <td><a href="../archive/2012">2012</a></td>
      <td><a href="../archive/2013">2013</a></td>
      <td><a href="../archive/2014">2014</a></td>
      <td><a href="../archive/2015">2015</a></td>
      <td><a href="../archive/2016">2016</a></td>
      <td><a href="../archive/2017">2017</a></td>
      <td><a href="../archive/2018">2018</a></td>
      <td><a href="../archive/2019">2019</a></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td><a href="../archive/2004">2004</a></td>
      <td><a href="../archive/2005">2005</a></td>
      <td><a href="../archive/2006">2006</a></td>
      <td><a href="../archive/2007">2007</a></td>
      <td><a href="../archive/2008">2008</a></td>
      <td><a href="../archive/2009">2009</a></td>
    </tr>
  </tbody>
</table>


<article class="post">
  <h2 class="post-title">
    <a href="../2026/01/10/introducing-asimpy/">
      Introducing asimpy
    </a>
  </h2>
  <p><time datetime="2026-01-10" class="post-date">2026-01-10</time></p>
  <p>I put <a href="https://gvwilson.github.io/sim/">the tutorial on discrete event simulation</a> on hold a couple of days ago
and spent a few hours building
<a href="https://gvwilson.github.io/asimpy/">a small discrete event simulation framework of my own</a>
using <code>async</code>/<code>await</code> instead of <code>yield</code>.
As I hoped,
I learned a few things along the way.</p>
<p>First,
Python&rsquo;s <code>await</code> is just a layer on top of its iterator machinery
(for an admittedly large value of &ldquo;just&rdquo;).
When Python encounters <code>await obj</code> it does something like this:</p>
<div class="highlight"><pre><span></span><code><span class="n">iterator</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="fm">__await__</span><span class="p">()</span>  <span class="c1"># get an iterator</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">value</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span>  <span class="c1"># run to the first yield</span>
<span class="k">except</span> <span class="ne">StopIteration</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">value</span>         <span class="c1"># get the result</span>
</code></pre></div>
<p>Breaking this down:</p>
<ol>
<li>Call the object&rsquo;s <code>__await__()</code> method to get an iterator.</li>
<li>It then advances that iterator to its first <code>yield</code> to get a value.</li>
<li>If the iterator doesn&rsquo;t <code>yield</code>, the result is whatever the iterator returns.
    (That value arrives as the <code>.value</code> field of the <code>StopIteration</code> exception.)</li>
</ol>
<p>We can simulate these steps as follows:</p>
<p><div class="highlight"><pre><span></span><code><span class="c1"># Define a class whose instances can be awaited.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Thing</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__await__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;before yield&quot;</span><span class="p">)</span>
        <span class="k">yield</span> <span class="s2">&quot;pause&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;after yield&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;result&quot;</span>

<span class="c1"># Get the __await__ iterator directly</span>
<span class="n">awaitable</span> <span class="o">=</span> <span class="n">Thing</span><span class="p">()</span>
<span class="nb">iter</span> <span class="o">=</span> <span class="n">awaitable</span><span class="o">.</span><span class="fm">__await__</span><span class="p">()</span>  <span class="c1"># this is an iterator</span>

<span class="c1"># run to first yield</span>
<span class="n">value</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;iterator yielded:&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

<span class="c1"># Step 2: resume until completion</span>
<span class="k">try</span><span class="p">:</span>
    <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">StopIteration</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">value</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;final result:&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code>before yield
iterator yielded: pause
after yield
final result: result
</code></pre></div></p>
<p><code>asimpy</code> builds on this by requiring processes to be derived from a <code>Process</code> class
and to have an <code>async</code> method called <code>run</code>:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Process</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span> <span class="o">=</span> <span class="n">env</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Sleeper</span><span class="p">(</span><span class="n">Process</span><span class="p">):</span>
    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div>
<p>We can then create an instance of <code>Sleeper</code> and pass it to the environment,
which calls its <code>run()</code> method to get a coroutine
and schedules that coroutine for execution:</p>
<div class="highlight"><pre><span></span><code><span class="n">env</span> <span class="o">=</span> <span class="n">Environment</span><span class="p">()</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">Sleeper</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
<span class="n">env</span><span class="o">.</span><span class="n">immediate</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="n">env</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</code></pre></div>
<p><code>Environment.run</code> then pulls processes from its run queue until it hits a time limit
or runs out of things to execute:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Environment</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">until</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_queue</span><span class="p">:</span>
            <span class="n">pending</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_queue</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">until</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">pending</span><span class="o">.</span><span class="n">time</span> <span class="o">&gt;</span> <span class="n">until</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">now</span> <span class="o">=</span> <span class="n">pending</span><span class="o">.</span><span class="n">time</span>
            <span class="n">proc</span> <span class="o">=</span> <span class="n">pending</span><span class="o">.</span><span class="n">proc</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">awaited</span> <span class="o">=</span> <span class="n">proc</span><span class="o">.</span><span class="n">_coro</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">awaited</span><span class="o">.</span><span class="n">act</span><span class="p">(</span><span class="n">proc</span><span class="p">)</span>

            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="k">continue</span>
</code></pre></div>
<p>The two key lines are in the <code>try</code> block:</p>
<ol>
<li>Send <code>None</code> to the process&rsquo;s coroutine to resume its execution.</li>
<li>Get something back the next time it calls <code>await</code>.</li>
<li>Run that something&rsquo;s <code>act()</code> method.</li>
</ol>
<p>For example,
here&rsquo;s how <code>sleep</code> works:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Environment</span><span class="p">:</span>
    <span class="c1"># …as above…</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sleep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delay</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_Sleep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delay</span><span class="p">)</span>

<span class="k">class</span><span class="w"> </span><span class="nc">_Sleep</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">delay</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_env</span> <span class="o">=</span> <span class="n">env</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_delay</span> <span class="o">=</span> <span class="n">delay</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">act</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proc</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">schedule</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">now</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delay</span><span class="p">,</span> <span class="n">proc</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__await__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">yield</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="kc">None</span>
</code></pre></div>
<ol>
<li><code>Environment.sleep()</code> returns an instance of <code>_Sleep</code>,
    so <code>await self.env.sleep(t)</code> inside a process
    gives the environment an object that says, &ldquo;Wait for <em>t</em> ticks.&rdquo;</li>
<li>When the environment calls that object&rsquo;s <code>act()</code> method,
    it reschedules the process that created the <code>_Sleep</code> object
    to run again in <em>t</em> ticks.</li>
</ol>
<p>It is a bit convoluted—the environment asks the process for an object
that in turn manipulates the environment—but so far
it seems to be able to handle shared resources, job queues, and gates.
Interrupts were harder to implement (<a href="../2025/12/08/the-real-hardest-problem/">interrupts are always hard</a>),
but <a href="https://github.com/gvwilson/asimpy/">they are in the code as well</a>.</p>
<p>Was this worth building?
It only has a fraction of <a href="https://simpy.readthedocs.io/">SimPy</a>&rsquo;s features,
and while I haven&rsquo;t benchmarked it yet,
I&rsquo;m certain that <code>asimpy</code> is much slower.
On the other hand,
I learned a few things along the way,
and it gave me an excuse to try out <a href="https://docs.astral.sh/ty/">ty</a> and <a href="https://github.com/taskipy/taskipy">taskipy</a> for the first time.
It was also a chance to practice using an LLM as a coding assistant:
I wouldn&rsquo;t call what I did &ldquo;vibe coding&rdquo;,
but ChatGPT&rsquo;s explanation of how <code>async</code>/<code>await</code> works was helpful,
as was its diagnosis of a couple of bugs.
I&rsquo;ve <a href="https://pypi.org/project/asimpy/">published <code>asimpy</code> on PyPI</a>,
and if a full-time job doesn&rsquo;t materialize some time soon,
I might come back and polish it a bit more.</p>
<blockquote>
<p>What I cannot create, I do not understand.</p>
<p>— Richard Feynman</p>
</blockquote>
</article>

<article class="post">
  <h2 class="post-title">
    <a href="../2026/01/05/next-steps-for-simulation/">
      Next Steps for Simulation
    </a>
  </h2>
  <p><time datetime="2026-01-05" class="post-date">2026-01-05</time></p>
  <p>I&rsquo;ve filed <a href="https://github.com/gvwilson/sim/issues">a few issues</a>
in the <a href="https://github.com/gvwilson/sim">GitHub repository</a>
for my <a href="https://gvwilson.github.io/sim/">discrete event simulation</a> of a small software development team
in order to map out future work.
The goal is to move away from what <a href="https://www.drcathicks.com/">Cat Hicks</a> calls
the &ldquo;brains in jars&rdquo; conception of programmers by including things like this:</p>
<ul>
<li><a href="https://github.com/gvwilson/sim/issues/5">Rushing work</a> should increase the chance that re-work will be needed.</li>
<li>If programmers don&rsquo;t ever get a break, they <a href="https://github.com/gvwilson/sim/issues/6">burn out</a>,
    which increases both their bug rate and the time needed to do the next task.</li>
<li>Too many meetings slows things down,
    but <a href="https://github.com/gvwilson/sim/issues/8">too few meetings</a> increases the chance of re-work being needed
    because of faulty or absent communication.</li>
</ul>
<p>In order to implement these,
though,
I&rsquo;ll need a way to simulate activities that multiple people are working on at the same time.
This would be easy to do if all but the last person to join the activity
sat idle waiting for it to start,
but that&rsquo;s not realistic.
I could instead model it as a multi-person interrupt,
but <a href="https://gvwilson.github.io/sim/interrupts/">interrupts are hard</a>.
If you have enough experience with <a href="https://simpy.readthedocs.io/">SimPy</a> to offer examples,
I&rsquo;d be grateful.
And if you&rsquo;re a professor looking for capstone projects for students,
please give me a shout:
I think that a discrete event simulation framework based on <code>async</code>/<code>await</code> instead of <code>yield</code>
would be just about the right size.</p>
</article>

<article class="post">
  <h2 class="post-title">
    <a href="../2025/12/30/discrete-events/">
      Discrete Events
    </a>
  </h2>
  <p><time datetime="2025-12-30" class="post-date">2025-12-30</time></p>
  <p>My work log tells me I&rsquo;ve spent 54 hours since mid-November
building <a href="https://gvwilson.github.io/sim/">this discrete event simulation</a>,
which works out to a little over an hour a day.
I&rsquo;ve learned a few things about <a href="https://simpy.readthedocs.io/">SimPy</a> and <a href="https://pola.rs/">Polars</a> along the way,
and depending on what happens with my job search,
I may run an online workshop in 2026 to walk people through it.
For now,
though,
I need to put this aside and concentrate on completing a couple of small contracts
and revising some of the fiction <a href="../2025/12/19/the-year-that-was/">I finally &ldquo;finished&rdquo;</a>.</p>
</article>

<article class="post">
  <h2 class="post-title">
    <a href="../2025/12/19/the-year-that-was/">
      The Year That Was
    </a>
  </h2>
  <p><time datetime="2025-12-19" class="post-date">2025-12-19</time></p>
  <p>Another year, another &ldquo;where did the time go?&rdquo; post…</p>
<ul>
<li>
<p>My daughter left home to start university.
    She had a wonderful first semester,
    but <a href="../2025/10/05/loading-the-dishwasher/">I miss her in all sorts of ways</a>.</p>
</li>
<li>
<p>I supervised <a href="../2025/04/09/congratulations-to-this-terms-students/">some student projects</a> at the University of Toronto
    for the first time in fifteen years.
    I really enjoyed working with them,
    and I hope they had fun as well,
    but it brought me face-to-face with how bad the job market is right now
    for newcomers in tech.</p>
</li>
<li>
<p>I was <a href="../2025/11/21/looking-for-work/">laid off</a> for the third time in eight years,
    which has brought me face-to-face with how bad the job market is right now
    for oldcomers in tech.</p>
</li>
<li>
<p>The refugee that my spouse and I helped sponsor through <a href="https://www.rainbowrailroad.org/">Rainbow Railroad</a>
    finally arrived in Canada,
    and has settled in well.</p>
</li>
<li>
<p>I ran <a href="https://gvwilson.github.io/change/">a workshop on organizational change</a> at
    the <a href="https://www.embl.org/">European Molecular Biology Lab</a> in Heidelberg
    and gave a talk on <a href="../talks/sdgc/">cocaine and Conway&rsquo;s Law</a> at
    <a href="https://www.uzh.ch/en.html">the University of Zurich</a>
    (<a href="https://www.youtube.com/watch?v=f86KBeJ7e2M">video here</a>).</p>
</li>
<li>
<p>I contributed to a paper called &ldquo;<a href="https://arxiv.org/abs/2505.06484">10 Quick Tips for Making Your Software Outlive Your Job</a>&rdquo;,
    which was motivated in large part by the Trump administration&rsquo;s hack-and-slash attacks on science.</p>
</li>
<li>
<p>I started building <a href="https://gvwilson.github.io/sim/">a tutorial</a> on how to simulate software development processes.</p>
</li>
<li>
<p>I played jazz in public for the first time in twenty-three years.</p>
</li>
<li>
<p>One wedding, no funerals.</p>
</li>
<li>
<p>I finally finished (first complete drafts of) three pieces of fiction
    that I&rsquo;ve been working on for longer than I want to admit.
    I don&rsquo;t know if there&rsquo;s a market for any of them right now,
    but it felt pretty good to finally write &ldquo;The End&rdquo;.</p>
</li>
</ul>
<p>Time for the day&rsquo;s last cup of tea.
If you came in peace, be welcome.</p>
</article>

<article class="post">
  <h2 class="post-title">
    <a href="../2025/12/08/the-real-hardest-problem/">
      The Real Hardest Problem
    </a>
  </h2>
  <p><time datetime="2025-12-08" class="post-date">2025-12-08</time></p>
  <blockquote>
<p>There are only two hard things in computer science:
cache invalidation and naming things.</p>
<p>— Phil Karlton</p>
</blockquote>
<p>With respect,
I think that handling interrupts is harder than either of these.
<a href="../2025/12/07/handling-interruptions/">Yesterday&rsquo;s post</a> explained how <a href="https://simpy.readthedocs.io/">SimPy</a> does this.
Today,
after several near misses,
we&rsquo;ll look at how to add it to our simulation.</p>
<h2>A Quick Recap</h2>
<p>Our <code>Simulation</code> class now includes a process
that waits a random interval,
chooses a random developer,
and interrupts her by calling <code>.interrupt</code>:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Simulation</span><span class="p">:</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">annoy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t_interrupt_arrival</span><span class="p">())</span>
            <span class="n">dev</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">developers</span><span class="p">)</span>
            <span class="n">dev</span><span class="o">.</span><span class="n">proc</span><span class="o">.</span><span class="n">interrupt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t_interrupt_duration</span><span class="p">())</span>
</code></pre></div>
<p>When <code>.interrupt</code> is called,
SimPy injects a <code>simpy.Interrupt</code> exception into the target process;
the argument to <code>.interrupt</code> is attached to that exception object.
If we&rsquo;re comfortable throwing away the task we&rsquo;re currently working on,
the <code>Developer</code> process can catch the exception like this:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Developer</span><span class="p">(</span><span class="n">Labeled</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">req</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">req</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">dev_queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
                <span class="n">task</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">req</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">dev_required</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">simpy</span><span class="o">.</span><span class="n">Interrupt</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">req</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">req</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
</code></pre></div>
<p>The trickiest part of this is canceling the outstanding request
to get something from the development queue.
As we discovered yesterday,
if we <em>don&rsquo;t</em> do this,
the developer won&rsquo;t ever get anything else from the queue.</p>
<h2>Nearly Right</h2>
<p>What if we <em>don&rsquo;t</em> want to throw away our current task when we&rsquo;re interrupted?
What if instead we want to handle the interruption and then resume that task?
Here&rsquo;s an implementation that&rsquo;s almost right:</p>
<div class="highlight"><pre><span></span><code>    <span class="c1"># This code is wrong.</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">task</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">req</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">task</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">req</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">dev_queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
                    <span class="n">task</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">req</span>
                <span class="n">t_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">now</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">dev_required</span> <span class="o">-</span> <span class="n">task</span><span class="o">.</span><span class="n">dev_done</span><span class="p">)</span>
                <span class="n">task</span><span class="o">.</span><span class="n">dev_done</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">now</span> <span class="o">-</span> <span class="n">t_start</span>
                <span class="k">if</span> <span class="n">task</span><span class="o">.</span><span class="n">is_done</span><span class="p">():</span>
                    <span class="n">task</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">except</span> <span class="n">simpy</span><span class="o">.</span><span class="n">Interrupt</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">req</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">req</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">exc</span><span class="o">.</span><span class="n">cause</span><span class="p">)</span>
</code></pre></div>
<p>Inside the <code>try</code> block we get a task if we don&rsquo;t already have one,
then try to wait for as much time as the task still requires.
When we&rsquo;re done we add some time to the task and check if it&rsquo;s now complete.
If we&rsquo;re interrupted,
we cancel any outstanding request for a new task
and then wait for as long as the interrupt tells us to.</p>
<p>There are (at least) two things wrong with this code.
The first and less important is that when we&rsquo;re interrupted,
we throw away any work we&rsquo;ve done on the task during this iteration of the loop.
That&rsquo;s relatively easy to fix:
we just add some code to the <code>except</code> block to increment the <code>.dev_done</code> time in the task.</p>
<p>The bigger problem,
though,
is that sooner or later this code fails because of an uncaught <code>Interrupt</code> exception.
The problem is that we can be interrupted
<em>inside our interrupt handler</em>.
It isn&rsquo;t likely,
which means it doesn&rsquo;t happen very often,
but if we run the simulation often enough with different random seeds,
it eventually falls over.</p>
<h2>A Corrected Version</h2>
<p>The &ldquo;fix&rdquo; (I&rsquo;ll explain the scare quotes around that word in a moment)
is to move interrupt handling into the <code>try</code> block.
To do that,
we have to add another state variable <code>interrupt_delay</code>
that tells the process if it&rsquo;s currently supposed to be handling an interruption delay:</p>
<div class="highlight"><pre><span></span><code>    <span class="k">def</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">task</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">interrupt_delay</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">req</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">interrupt_delay</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">interrupt_delay</span><span class="p">)</span>
                    <span class="n">interrupt_delay</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">task</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">req</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">dev_queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
                        <span class="n">task</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">req</span>
                    <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">dev_required</span> <span class="o">-</span> <span class="n">task</span><span class="o">.</span><span class="n">dev_done</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">task</span><span class="o">.</span><span class="n">is_done</span><span class="p">():</span>
                        <span class="n">task</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">except</span> <span class="n">simpy</span><span class="o">.</span><span class="n">Interrupt</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">req</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">req</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
                <span class="n">interrupt_delay</span> <span class="o">=</span> <span class="n">exc</span><span class="o">.</span><span class="n">cause</span>
</code></pre></div>
<p>So why did I put scare quotes around the word &ldquo;fix&rdquo;?
Because I&rsquo;m still not 100% sure this works.
It hasn&rsquo;t failed yet,
despite multiple runs with different seeds and parameters,
but this code is now complex enough that I could well believe it contains
a one-in-a-million edge case.
I <em>think</em> the <code>except</code> block is now a critical region,
i.e.,
that no interrupts can occur within it
because none of those three lines hands control back to SimPy,
but I&rsquo;m not completely sure.</p>
<p>And yes,
this code still throws away any work the developer has done on a task
during a particular loop iteration
if an interrupt occurs;
the interrupt handler should increment <code>task.dev_done</code>.
And yes,
it&rsquo;s possible for an interrupt to be interrupted:
a more realistic implementation would stack interrupt delays,
but honestly,
if my boss interrupts me while I&rsquo;m being interrupted,
I don&rsquo;t have any qualms about discarding the first interruption.</p>
<h2>Yaks and More Yaks</h2>
<p>My goal with this series of blog posts was
to simulate the development process of a small software team.
I&rsquo;ve spent most of the last week learning more about <a href="https://simpy.readthedocs.io/">SimPy</a>;
it feels like <a href="https://en.wiktionary.org/wiki/yak_shaving">yak shaving</a>,
but without it,
I don&rsquo;t think I&rsquo;d have confidence in the code shown above
(or be able to review its AI-generated equivalent).</p>
</article>

<article class="post">
  <h2 class="post-title">
    <a href="../2025/12/07/handling-interruptions/">
      Handling Interruptions
    </a>
  </h2>
  <p><time datetime="2025-12-07" class="post-date">2025-12-07</time></p>
  <p>The <a href="../2025/12/04/the-effects-of-rework/">previous post in this series</a> looked at the effects of re-work on throughput.
Its version of the simulation assumed that
a task that needed to be re-done was given back to the developer who had originally worked on it,
and that she would tackle that task once she finished whatever she was doing at the time.
In reality,
though,
developers (and testers) often interrupt what they&rsquo;re doing,
switch to another task,
and then switch back.
This post looks at how to simulate that in <a href="https://simpy.readthedocs.io/">SimPy</a>.</p>
<h2>A Simpler Model</h2>
<p>To start with,
let&rsquo;s go back to a simpler model in which one process adds new tasks to a queue at random intervals,
while developers take tasks,
work on them,
and then mark them as done.
While we&rsquo;re building it,
we&rsquo;ll use these parameters:</p>
<div class="highlight"><pre><span></span><code><span class="n">PARAMS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;n_dev&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>          <span class="c1"># number of developers</span>
    <span class="s2">&quot;rng_seed&quot;</span><span class="p">:</span> <span class="mi">12345</span><span class="p">,</span>   <span class="c1"># random number generation seed</span>
    <span class="s2">&quot;t_arrival&quot;</span><span class="p">:</span> <span class="mf">8.0</span><span class="p">,</span>    <span class="c1"># mean task arrival time</span>
    <span class="s2">&quot;t_dev&quot;</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">,</span>        <span class="c1"># median development time</span>
    <span class="s2">&quot;t_interrupt&quot;</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">,</span>  <span class="c1"># time between interrupts</span>
    <span class="s2">&quot;t_sim&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>         <span class="c1"># length of simulation</span>
<span class="p">}</span>
</code></pre></div>
<p>As before,
we define a <code>Simulation</code> class to hold all our bits and pieces.
Its constructor caches the parameters,
then creates the SimPy <code>Environment</code>,
the development queue,
and the developers.
It also creates a simple list called <code>.log</code> to store log messages:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Simulation</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Overall simulation.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span> <span class="o">=</span> <span class="n">simpy</span><span class="o">.</span><span class="n">Environment</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dev_queue</span> <span class="o">=</span> <span class="n">simpy</span><span class="o">.</span><span class="n">Store</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">developers</span> <span class="o">=</span> <span class="p">[</span><span class="n">Developer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;n_dev&quot;</span><span class="p">])]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="p">[]</span>
</code></pre></div>
<p>For lack of anywhere better to put it,
we define the task generator as a method of <code>Simulation</code>.
The order of statements in the <code>while</code> loop ensures that
the first task is generated at t=0:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Simulation</span><span class="p">:</span>
    <span class="err">…</span><span class="n">previous</span> <span class="n">code</span><span class="err">…</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">generate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate tasks at random intervals starting at t=0.&quot;&quot;&quot;</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">dev_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">Task</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t_arrival</span><span class="p">())</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proc</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Shortcut for running a process.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">proc</span><span class="p">)</span>
</code></pre></div>
<p>As before,
we also give <code>Simulation</code> some convenience methods like <code>.process</code>
so that we can type <code>sim.process(…)</code> rather than <code>sim.env.process(…)</code>.</p>
<h2>Creating Interrupts</h2>
<p>What&rsquo;s new in this simulation is another process
whose only purpose is to interrupt developers.
It does this by choosing a random developer <code>dev</code> every few clock ticks
and then calling <code>dev.proc.interrupt()</code>:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Simulation</span><span class="p">:</span>
    <span class="err">…</span><span class="n">previous</span> <span class="n">code</span><span class="err">…</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">annoy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate annoying interruptions.&quot;&quot;&quot;</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;t_interrupt&quot;</span><span class="p">])</span>
            <span class="n">dev</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">developers</span><span class="p">)</span>
            <span class="n">dev</span><span class="o">.</span><span class="n">proc</span><span class="o">.</span><span class="n">interrupt</span><span class="p">()</span>
</code></pre></div>
<p><code>dev.proc.interrupt()</code> only makes sense once we have looked at
the constructor for the <code>Developer</code> class:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Developer</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A generic worker.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sim</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sim</span> <span class="o">=</span> <span class="n">sim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">work</span><span class="p">())</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="err">…</span><span class="n">the</span> <span class="n">generator</span> <span class="n">simulating</span> <span class="n">a</span> <span class="n">developer</span><span class="s1">&#39;s behavior…</span>
</code></pre></div>
<p>Here&rsquo;s what&rsquo;s going on:</p>
<ol>
<li>
<p><code>Developer.work</code> is (going to be) a generator that simulates
    an individual developer&rsquo;s behavior.</p>
</li>
<li>
<p>Calling it as <code>self.work()</code> in <code>Developer.__init__</code> <em>doesn&rsquo;t</em> start a process.
    Instead, that call creates a generator object.</p>
</li>
<li>
<p>We pass that generator object to <code>self.sim.process()</code>,
    which gives it to the SimPy <code>Environment</code> to run.
    Doing this means that developers start running as soon as they are created.</p>
</li>
<li>
<p>Finally,
    <code>self.sim.process(…)</code> returns the generator object that was passed into it.
    We save this in the <code>Developer</code> object as <code>self.proc</code>
    so that we can access it later.
    (This step was the one that initially confused me.
    <code>Developer</code> isn&rsquo;t a SimPy process:
    the generator object created by calling <code>Developer.work</code> is the process.
    If we want to interrupt the process,
    we need to get at the generator object,
    and the logical place to store a reference to it is
    in the object that defines its behavior.)</p>
</li>
</ol>
<p>So let&rsquo;s jump back to <code>Simulation.annoy</code>. It contains the lines:</p>
<div class="highlight"><pre><span></span><code>    <span class="n">dev</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">developers</span><span class="p">)</span>
    <span class="n">dev</span><span class="o">.</span><span class="n">proc</span><span class="o">.</span><span class="n">interrupt</span><span class="p">()</span>
</code></pre></div>
<p>which mean:</p>
<ol>
<li>
<p>Choose a developer at random.</p>
</li>
<li>
<p>Get a reference to that developer&rsquo;s generator object <code>dev.proc</code>.</p>
</li>
<li>
<p>Call the object&rsquo;s <code>.interrupt</code> method.</p>
</li>
</ol>
<p>The last of those steps injects a <code>simpy.Interrupt</code> exception into the process,
so let&rsquo;s take a look at how we handle that.</p>
<h2>Handling Interrupts</h2>
<p>Here&rsquo;s a simple version of a developer that can handle interrupts:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Developer</span><span class="p">(</span><span class="n">Labeled</span><span class="p">):</span>
    <span class="err">…</span><span class="n">constructor</span><span class="err">…</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">req</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">req</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">dev_queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
                <span class="n">task</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">req</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">dev_required</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">simpy</span><span class="o">.</span><span class="n">Interrupt</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">req</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">req</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
</code></pre></div>
<p>This developer does the following each time it goes around the <code>while</code> loop:</p>
<ol>
<li>
<p>Create a request to get a task from the development queue.</p>
</li>
<li>
<p><code>yield</code> that request,
    which hands the request to the SimPy <code>Environment</code>
    and suspends this process until the request can be satisfied.</p>
</li>
<li>
<p>The result of yielding the request is a task from the development queue,
    so wait a while to simulate working on that task.</p>
</li>
<li>
<p><em>Unless</em> a <code>simpy.Interrupt</code> exception occurs,
    in which case the developer cancels the request for a task
    and goes around the loop again.</p>
</li>
</ol>
<p>We have run into <a href="../2025/12/03/you-have-to-cancel/">the need to cancel</a> before.
In the first version of this code,
I assumed that interrupts would only occur while a developer was working on a task,
so the body of the <code>except</code> block was just <code>pass</code>:</p>
<div class="highlight"><pre><span></span><code>    <span class="c1"># This version is wrong!</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">req</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">req</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">dev_queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
                <span class="n">task</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">req</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">dev_required</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">simpy</span><span class="o">.</span><span class="n">Interrupt</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="k">pass</span>
</code></pre></div>
<p>What I found was that if the interrupt occurred while the developer was waiting on the queue,
and I <em>didn&rsquo;t</em> cancel the request,
subsequent requests were never satisfied.
In other words,
once a developer had been interrupted,
she would never get any more work.</p>
<h2>How It Behaves</h2>
<p>I won&rsquo;t bother to show the code that adds log messages to <code>Simulation.log</code>
or collects the states of all the tasks when the simulation is done,
but here&rsquo;s the JSON output from a typical short run:</p>
<div class="highlight"><pre><span></span><code>{
  &quot;params&quot;: {
    …as shown earlier…
  },
  &quot;messages&quot;: [
    &quot;developer-0 0.00 start task-0&quot;,
    &quot;developer-0 3.00 interrupted in task-0&quot;,
    &quot;developer-0 6.00 interrupted in None&quot;,
    &quot;developer-0 9.00 interrupted in None&quot;,
    &quot;developer-0 12.00 interrupted in None&quot;,
    &quot;developer-0 13.95 start task-1&quot;,
    &quot;developer-0 15.00 interrupted in task-1&quot;,
    &quot;developer-0 15.01 start task-2&quot;,
    &quot;developer-0 16.68 complete task-2&quot;,
    &quot;developer-0 18.00 interrupted in None&quot;
  ],
  &quot;tasks&quot;: [
    {
      &quot;id&quot;: 0,
      &quot;created&quot;: 0,
      &quot;dev_required&quot;: 4.33,
      &quot;state&quot;: [&quot;dev_queue&quot;, &quot;dev&quot;, &quot;interrupted&quot;]
    },
    {
      &quot;id&quot;: 1,
      &quot;created&quot;: 13.95,
      &quot;dev_required&quot;: 5.72,
      &quot;state&quot;: [&quot;dev_queue&quot;, &quot;dev&quot;, &quot;interrupted&quot;]
    },
    {
      &quot;id&quot;: 2,
      &quot;created&quot;: 15.01,
      &quot;dev_required&quot;: 1.67,
      &quot;state&quot;: [&quot;dev_queue&quot;, &quot;dev&quot;, &quot;complete&quot;]
    }
  ]
}
</code></pre></div>
<p>As you can see,
the first two tasks are interrupted and discarded while they&rsquo;re being worked on,
while the developer manages to finish the third task before she&rsquo;s interrupted.
The next step will be to resume tasks rather than just throwing them away.</p>
</article>

<article class="post">
  <h2 class="post-title">
    <a href="../2025/12/06/remembrance/">
      Remembrance
    </a>
  </h2>
  <p><time datetime="2025-12-06" class="post-date">2025-12-06</time></p>
  <p>Jamais plus.</p>
<div class="center">
  <img src="../files/dec-6.png" alt="victims of the Dec 6 massacre" width="90%>
</div>

<div class="center">
  <img src="../files/dec-6-plaque.png" alt="plaque for victims the Dec 6 massacre" width="90%>
</div>
</article>

<article class="post">
  <h2 class="post-title">
    <a href="../2025/12/04/the-effects-of-rework/">
      The Effects of Rework
    </a>
  </h2>
  <p><time datetime="2025-12-04" class="post-date">2025-12-04</time></p>
  <p>Having <a href="../2025/12/03/you-have-to-cancel/">solved yesterday&rsquo;s bug</a>,
we can get back to looking at the effect of re-work on throughput.
As a reminder,
our workflow looks like this:</p>
<div class="highlight"><pre><span></span><code>+----------------+    +-----------+    +------------+    +------------+    +---------+
| task generator | -&gt; | dev queue | -&gt; | developers | -&gt; | test queue | -&gt; | testers |
+----------------+    +-----------+    +------------+    +------------+    +---------+
                            ^                                                   |
                            |                                                   |
                            +---------------------------------------------------+
</code></pre></div>
<p>The two parameters that affect re-work are <code>p_rework_needed</code>,
which is the probability that a tester is going to send a task back for more work,
and <code>p_rework_chosen</code>,
which is the probability that a developer will choose something from her re-work queue
rather than starting fresh work
when both are available.
The extreme cases are:</p>
<ul>
<li><code>p_rework_needed</code> = 0.0, meaning no tasks are ever sent back.</li>
<li><code>p_rework_needed</code> = 1.0, meaning every task is always sent back.
    (Note that this means no task will ever be finished:
    instead,
    tasks will circulate endlesslesly between development and testing,
    and yes,
    sometimes it does feel like that happens in real life.)</li>
<li><code>p_rework_chosen</code> = 0.0, in which case
    developers only re-do tasks when there is no new work queued up.
    (We know from previous simulations that there are almost always
    new tasks waiting to be started.)</li>
<li><code>p_rework_chosen</code> = 1.0, in which case
    developers only start new tasks when nothing needs to be re-done.</li>
</ul>
<p>Finally,
this version of the simulation always sends tasks back to
the developers who originally worked on them
rather than allowing the first available developer
to re-do someone else&rsquo;s work.</p>
<h2>Final States</h2>
<p>The figure below shows the number of tasks in each of the five possible states
at the end of the simulation
as a function of <code>p_rework_needed</code> and <code>p_rework_chosen</code>:</p>
<div class="center">
  <img src="../files/2025/12/04/states.svg" alt="final task states" width="90%">
</div>

<p>As expected,
lots of tasks are in the <code>complete</code> state when there is never any need for re-work,
while none are when re-work is always needed.
This finding may seem obvious,
but this simple check uncovered a couple of bugs in the simulation.</p>
<p>A more interesting finding is that
how developers choose tasks doesn&rsquo;t seem to have much effect
on how many they get done:
while there is some variation,
the bars stay more or less the same height when we look at each row.</p>
<p>We can reach the same conclusion by looking at
the number of times tasks were developed and re-worked.
The sizes of the circles in the plots below reflect these counts:</p>
<div class="row">
  <div class="col-6 center">
    <img src="../files/2025/12/04/n_dev.svg" alt="development count" width="90%">
  </div>
  <div class="col-6 center">
    <img src="../files/2025/12/04/n_rework.svg" alt="re-work count" width="90%">
  </div>
</div>

<p>Again,
the probability of needing re-work has an obvious impact,
while the probability of choosing new work vs. re-work doesn&rsquo;t seem to.</p>
</article>


    </main>
    <footer>
  &copy; 2004-2026 <a href="../about/">Greg Wilson</a>
  <a href="mailto:gvwilson@third-bit.com"><img src="../assets/icons/envelope.svg" alt="email" class="footer-icon"></a>
  <a href="https://www.linkedin.com/in/gvwilson/"><img src="../assets/icons/linkedin.svg" alt="LinkedIn" class="footer-icon"></a>
  <a href="https://mastodon.social/@gvwilson"><img src="../assets/icons/mastodon.svg" alt="Mastodon" class="footer-icon"></a>
  <a href="https://calendly.com/gvwilson/30min"><img src="../assets/icons/calendar.svg" alt="Calendly" class="footer-icon"></a>
  <a href="https://github.com/gvwilson"><img src="../assets/icons/github.svg" alt="GitHub" class="footer-icon"></a>
  <a href="https://www.youtube.com/channel/UCbDQ7FIeYB3FHRADAjUjfrg"><img src="../assets/icons/youtube.svg" alt="YouTube" class="footer-icon"></a>
  <a href="../bib/"><img src="../assets/icons/orcid.svg" alt="ORCID" class="footer-icon"></a>
  <a href="../atom.xml"><img src="../assets/icons/rss.svg" alt="RSS feed" class="footer-icon"></a>
  <a href="../license/"><img src="../assets/icons/cc-by.svg" alt="license" class="footer-icon"></a>
  <a href="../colophon/"><img src="../assets/icons/pencil.svg" alt="colophon" class="footer-icon"></a>
  <a href="../cv/"><img src="../assets/icons/file.svg" alt="CV" class="footer-icon"></a>
  <br>
  The material on this site may not be used to train AI models without the express permission of the author.
</footer>
  </body>
</html>