<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<link rel="me" href="https://mastodon.social/@gvwilson">
<link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
<link rel="alternate" type="application/atom+xml" title="The Third Bit" href="../atom.xml">
<!-- <script defer data-domain="third-bit.com" src="https://plausible.io/js/plausible.js"></script> -->
    <script src="https://kit.fontawesome.com/4eee35f757.js"></script>
    <link rel="stylesheet" href="../assets/thirdbit.css">
    <link rel="stylesheet" href="../assets/page.css">
    
<title>The Third Bit Blog</title>

    
  </head>
  <body>
    <nav>
  <div class="row underline">
    <div class="col-2 left">
      <a class="navlink" href="../">Home</a>
    </div>
    <div class="col-10 right">
      <a class="navlink" href="../about/">about</a>
      <a class="navlink" href="../blog/">blog</a>
      <a class="navlink" href="../selected/">selected</a>
      <a class="navlink" href="../talks/">talks</a>
      <a class="navlink" href="../bib/">bibliography</a>
      <a class="navlink" href="../fiction/">fiction</a>
    </div>
  </div>
</nav>
    <main>
      
<h1>Blog</h1>


<table class="centered">
  <tbody>
    <tr>
      <td><a href="../archive/2020">2020</a></td>
      <td><a href="../archive/2021">2021</a></td>
      <td><a href="../archive/2022">2022</a></td>
      <td><a href="../archive/2023">2023</a></td>
      <td><a href="../archive/2024">2024</a></td>
      <td><a href="../archive/2025">2025</a></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td><a href="../archive/2010">2010</a></td>
      <td><a href="../archive/2011">2011</a></td>
      <td><a href="../archive/2012">2012</a></td>
      <td><a href="../archive/2013">2013</a></td>
      <td><a href="../archive/2014">2014</a></td>
      <td><a href="../archive/2015">2015</a></td>
      <td><a href="../archive/2016">2016</a></td>
      <td><a href="../archive/2017">2017</a></td>
      <td><a href="../archive/2018">2018</a></td>
      <td><a href="../archive/2019">2019</a></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td><a href="../archive/2004">2004</a></td>
      <td><a href="../archive/2005">2005</a></td>
      <td><a href="../archive/2006">2006</a></td>
      <td><a href="../archive/2007">2007</a></td>
      <td><a href="../archive/2008">2008</a></td>
      <td><a href="../archive/2009">2009</a></td>
    </tr>
  </tbody>
</table>


<article class="post">
  <h2 class="post-title">
    <a href="../2025/11/21/simulating-rework/">
      Simulating Rework
    </a>
  </h2>
  <p><time datetime="2025-11-21" class="post-date">2025-11-21</time></p>
  <p>In <a href="../2025/11/20/making-sense-of-simulation/">yesterday&rsquo;s post</a> we started collecting data from our simulation,
and discovered that our metrics will always give us numbers,
but those numbers might be garbage if we&rsquo;re measuring the wrong things or the wrong way.
In this post we&rsquo;ll make the simulation more realistic
by taking into account the fact that most first attempts to fix a bug
either don&rsquo;t fix it or introduce new bugs.</p>
<h2>Rework</h2>
<p>Let&rsquo;s introduce a new parameter to specify
the probability that a task needs to be re-done.
For the moment,
we&rsquo;ll assume this probability doesn&rsquo;t depend on
how many attempts have been made to finish the task so far.
While we&rsquo;re at it,
we&rsquo;ll introduce another parameter to specify
how many times we want to run the simulation:</p>
<div class="highlight"><pre><span></span><code><span class="n">PARAMS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="err">…</span><span class="n">previous</span> <span class="n">parameters</span><span class="err">…</span>
    <span class="s2">&quot;rework_probability&quot;</span><span class="p">:</span> <span class="mf">0.6</span><span class="p">,</span>
    <span class="s2">&quot;num_simulations&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>
<p>Next, we introduce a loop in <code>simulate_task</code>.
Each time around the loop,
we get a developer,
spend some time on the task,
and then check if we&rsquo;re done.
If we are,
we mark the task as completed and break out of the loop;
if not,
we go around the loop again.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">simulate_task</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">developers</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Simulate a task flowing through the system.&quot;&quot;&quot;</span>

    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">developers</span><span class="o">.</span><span class="n">request</span><span class="p">()</span> <span class="k">as</span> <span class="n">req</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">req</span>
            <span class="n">task</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">env</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">_duration</span><span class="p">)</span>
            <span class="n">task</span><span class="o">.</span><span class="n">end</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;rework_probability&quot;</span><span class="p">]:</span>
                <span class="n">task</span><span class="o">.</span><span class="n">completed</span><span class="p">()</span>
                <span class="k">break</span>
</code></pre></div>
<p>If we run our simulation a few times for 100,000 timesteps with two developers,
we complete an average of 14,550 tasks,
which works out to about 13.7 timesteps per task.
That&rsquo;s about 40% of the 36,000 tasks we complete in the same time without rework,
and gives us a baseline against which to compare
a more interesting variation on this model.</p>
<h2>Keeping the Same Developer</h2>
<p>When a task needs to be redone,
the code shown above always grabs the next available developer.
In most development teams,
though,
the same developer would keep working on the task.</p>
<p>We need to make two changes to the simulation to capture this.
First,
we create a <code>FilterStore</code> instead of a <code>Resource</code> to represent
our pool of developers:</p>
<div class="highlight"><pre><span></span><code>    <span class="n">developers</span> <span class="o">=</span> <span class="n">simpy</span><span class="o">.</span><span class="n">FilterStore</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">capacity</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;num_developers&quot;</span><span class="p">])</span>
</code></pre></div>
<p>The difference between the two is that <code>FilterStore</code> allows us to specify
a test or check that a resource has to satisfy when we claim it.
Here&rsquo;s the modified <code>simulate_task</code> that makes use of that:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">simulate_task</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">developers</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Simulate a task being re-worked by the same developer.&quot;&quot;&quot;</span>

    <span class="n">dev</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dev</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dev</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">developers</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dev</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">developers</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="n">item</span><span class="o">.</span><span class="n">_id</span> <span class="o">==</span> <span class="n">dev</span><span class="o">.</span><span class="n">_id</span><span class="p">)</span>
        <span class="n">task</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">env</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">_duration</span><span class="p">)</span>
        <span class="n">developers</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span>
        <span class="n">task</span><span class="o">.</span><span class="n">end</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;rework_probability&quot;</span><span class="p">]:</span>
            <span class="n">task</span><span class="o">.</span><span class="n">completed</span><span class="p">()</span>
            <span class="k">break</span>
</code></pre></div>
<p>Initially,
the task isn&rsquo;t associated with a developer
so <code>dev</code> is set to <code>None</code>.
The first time around the loop,
we use <code>developers.get()</code> without a test to claim a developer.
After that,
we always re-claim the same developer
by passing a function to <code>developers.get()</code> that says,
&ldquo;The only developer we want is the one with the same ID.&rdquo;
We then do some work,
put the developer back in the pool,
and check to see if we&rsquo;re done with this task or not.</p>
<h2>Does It Make a Difference?</h2>
<p>So here&rsquo;s our question:
does this policy change the total number of tasks completed or not?
On the one hand we could argue that it would
because we wouldn&rsquo;t be taking full advantage of idle developers.
On the other hand,
our developers are currently working almost 100% of the time,
so there aren&rsquo;t actually idle cycles going to waste.</p>
<p>The answer is that <em>under the assumptions baked into our simulation</em>
this change in policy doesn&rsquo;t have an impact on the total number of tasks that are completed.
If we increase the number of developers
and lower the rate at which new tasks arrive,
though,
that answer changes:
if developers <em>do</em> have idle cycles,
having developers &ldquo;own&rdquo; tasks is less efficient
than allowing whoever&rsquo;s free to work on whatever needs done.</p>
<p>Of course,
that model doesn&rsquo;t take into account the ramp-up time
that real developers need to familiarize themselves with new problems.
(Putting it another way,
it doesn&rsquo;t account for the time saved by having someone who understands the problem
go back to it.)
We could add another parameter to our model and another few lines of code to capture this,
but before we do that,
we need to put some better analysis machinery in place.</p>
</article>

<article class="post">
  <h2 class="post-title">
    <a href="../2025/11/20/making-sense-of-simulation/">
      Making Sense of Simulation
    </a>
  </h2>
  <p><time datetime="2025-11-20" class="post-date">2025-11-20</time></p>
  <p>I ended <a href="../2025/11/19/simulating-a-developer-pool/">yesterday&rsquo;s post</a> by saying that
we need to collect some data and do a bit of analysis.
<a href="https://simpy.readthedocs.io/">SimPy</a> <a href="https://simpy.readthedocs.io/en/latest/topical_guides/monitoring.html">doesn&rsquo;t do monitoring</a> out of the box,
so we have to roll our own.</p>
<h2>Tracking Time in Tasks</h2>
<p>The first step is to update the class that represents a task
so that it can keep track of how much time it takes.
To do this,
we add two fields called <code>._current</code> (the most recent start-of-work time)
and <code>._elapsed</code> (the total time so far).
We then add three methods:
<code>.start</code> to signal the start of work,
<code>.end</code> to signal the end of work,
and <code>.is_complete</code> so that we can ask if the task has been completed:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TaskRecorder</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Task with uniformly-distributed durations that records activity.&quot;&quot;&quot;</span>

    <span class="n">_id</span> <span class="o">=</span> <span class="n">count</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_id</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">TaskRecorder</span><span class="o">.</span><span class="n">_id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_duration</span> <span class="o">=</span> <span class="n">TaskRecorder</span><span class="o">.</span><span class="n">duration</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elapsed</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">now</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">end</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elapsed</span> <span class="o">+=</span> <span class="n">env</span><span class="o">.</span><span class="n">now</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">is_complete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_current</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_elapsed</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span>
</code></pre></div>
<p>The logic of <code>.is_complete</code> needs a bit of explanation.
When the task is initially created,
its current start time is <code>None</code>.
When it is being executed,
<code>._current</code> records the (simulated) time at which work started,
and when it&rsquo;s done,
we re-set <code>._current</code> to <code>None</code> and record the elapsed time in <code>._elapsed</code>.
The task is therefore complete if <code>._current</code> is <code>None</code>
<em>and</em> some elapsed time has been set.</p>
<p>With this in place,
we can modify the generator that simulates task execution
to signal the start and stop of work:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">simulate_task</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">developers</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Simulate a task flowing through the system.&quot;&quot;&quot;</span>

    <span class="n">task</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">developers</span><span class="o">.</span><span class="n">request</span><span class="p">()</span> <span class="k">as</span> <span class="n">req</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">req</span>
        <span class="k">yield</span> <span class="n">env</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">_duration</span><span class="p">)</span>
        <span class="n">task</span><span class="o">.</span><span class="n">end</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
</code></pre></div>
<p>(We pass the simulation environment <code>env</code> to <code>task.start</code> and <code>task.end</code>
so that the task can check the current simulated time with <code>sim.now</code>.)</p>
<h2>Gathering Statistics</h2>
<p>Now that each task is recording its elapsed time,
we need to gather statistics for all of them.
Let&rsquo;s go back to the <code>TaskRecord</code> class
and have each new task add itself to a list owned by the class:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TaskRecorder</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Task with uniformly-distributed durations that records activity.&quot;&quot;&quot;</span>

    <span class="err">…</span><span class="n">previous</span> <span class="n">code</span><span class="err">…</span>
    <span class="n">_all</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="err">…</span><span class="n">previous</span> <span class="n">code</span><span class="err">…</span>
        <span class="n">TaskRecorder</span><span class="o">.</span><span class="n">_all</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</code></pre></div>
<p>When the simulation is finished,
we can walk through this list to find out
how much time was spent on each task
and whether that task was completed or not:</p>
<div class="highlight"><pre><span></span><code><span class="n">PRECISION</span> <span class="o">=</span> <span class="mi">2</span>


<span class="k">def</span><span class="w"> </span><span class="nf">write_log</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">stream</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create and write entire log.&quot;&quot;&quot;</span>

    <span class="n">log</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;kind&quot;</span><span class="p">,</span> <span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;elapsed&quot;</span><span class="p">,</span> <span class="s2">&quot;completed&quot;</span><span class="p">)]</span>
    <span class="n">log</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span>
        <span class="p">(</span><span class="s2">&quot;task&quot;</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">_elapsed</span><span class="p">,</span> <span class="n">PRECISION</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">is_complete</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">TaskRecorder</span><span class="o">.</span><span class="n">_all</span>
    <span class="p">])</span>
    <span class="n">total</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">_elapsed</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">TaskRecorder</span><span class="o">.</span><span class="n">_all</span><span class="p">)</span>
    <span class="n">log</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;total&quot;</span><span class="p">,</span> <span class="s2">&quot;task&quot;</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">total</span><span class="p">,</span> <span class="n">PRECISION</span><span class="p">),</span> <span class="kc">None</span><span class="p">))</span>
    <span class="n">csv</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">lineterminator</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">writerows</span><span class="p">(</span><span class="n">log</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
    <span class="err">…</span><span class="n">previous</span> <span class="n">code</span><span class="err">…</span>
    <span class="n">write_log</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">)</span>
</code></pre></div>
<p>Let&rsquo;s run it for 100 simulated timesteps
with two developers:</p>
<div class="highlight"><pre><span></span><code>kind,id,elapsed,completed
task,0,1.09,True
task,1,3.69,True
task,2,2.74,True
…,…,…,…
task,39,0.0,False
task,40,0.0,False
task,41,0.0,False
total,task,378.68,
</code></pre></div>
<p>Cool!
Our simulation is working—except it isn&rsquo;t.</p>
<h2>Don&rsquo;t Trust, Just Verify</h2>
<p>Take a look at the last line of the output shown above.
It&rsquo;s telling us that our workers did a total of 378.68 timesteps of work during this simulation,
but that&rsquo;s impossible:
we have two developers and the simulation ran for 100 timesteps,
so even if both developers were busy 100% of the time,
they couldn&rsquo;t have done more than 200 timesteps of work.
What&rsquo;s gone wrong?</p>
<p>The answer lies in <code>simulate_task</code>,
which we reproduce here from above:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">simulate_task</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">developers</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
    <span class="n">task</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">developers</span><span class="o">.</span><span class="n">request</span><span class="p">()</span> <span class="k">as</span> <span class="n">req</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">req</span>
        <span class="k">yield</span> <span class="n">env</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">_duration</span><span class="p">)</span>
        <span class="n">task</span><span class="o">.</span><span class="n">end</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
</code></pre></div>
<p>The problem is that we&rsquo;re including the time the task spends waiting for a developer
in our measure of how long the task was worked on.
The fix is to move <code>task.start</code> <em>after</em> <code>yield req</code>,
so that we start the task&rsquo;s clock when we start work on it:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">simulate_task</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">developers</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">developers</span><span class="o">.</span><span class="n">request</span><span class="p">()</span> <span class="k">as</span> <span class="n">req</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">req</span>
        <span class="n">task</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">env</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">_duration</span><span class="p">)</span>
        <span class="n">task</span><span class="o">.</span><span class="n">end</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
</code></pre></div>
<p>When we re-run the simulation with the same parameters,
we get:</p>
<div class="highlight"><pre><span></span><code>kind,id,elapsed,completed
task,0,1.09,True
task,1,3.69,True
task,2,2.74,True
…,…,…,…
task,39,0.0,False
task,40,0.0,False
task,41,0.0,False
total,task,149.41,
</code></pre></div>
<p>This result is physically plausible but still puzzling:
why are the developers only busy 75% of the time?
Let&rsquo;s try running the simulation for 100,000 timesteps instead:</p>
<div class="highlight"><pre><span></span><code>…,…,…,…
total,task,199961.93,
</code></pre></div>
<p>That works out to 99.98% utilization,
so the earlier figure of 75% seems to be due to warmup effects.</p>
<h2>What We&rsquo;ve Learned</h2>
<p>What I learned from this bug is that
badly-designed measurements can produce numbers that are wrong
without being obviously wrong.
I didn&rsquo;t immediately notice that worker utilization in the buggy simulation was impossible;
I don&rsquo;t believe I would have noticed at all if the measure or the simulation
were more complicated.
As I build more realistic simulations,
I&rsquo;m going to add checks on the results
based on the properties of the model
(e.g., &ldquo;we can&rsquo;t have done more work than is physically possible&rdquo;).
Similarly,
when we start to monitor real developers,
I&rsquo;m going to think very carefully about whether
what I&rsquo;m measuring is measuring what I want to.</p>
<blockquote>
<p>I also have to go back and figure out exactly what &ldquo;warmup effects&rdquo; means:
right now,
I&rsquo;m just waving my hands and hoping you won&rsquo;t notice that I glossed over that.</p>
</blockquote>
</article>

<article class="post">
  <h2 class="post-title">
    <a href="../2025/11/19/simulating-a-developer-pool/">
      Simulating a Developer Pool
    </a>
  </h2>
  <p><time datetime="2025-11-19" class="post-date">2025-11-19</time></p>
  <p>Following <a href="../2025/11/18/starting-to-simulate/">yesterday&rsquo;s post</a>
about using <a href="https://simpy.readthedocs.io/">SimPy</a> for discrete event simulation,
let&rsquo;s have a look at a slightly more interesting scenario:
a pool of developers,
all of whom work at the same speed,
handling tasks of varying duration that arrive at random intervals.</p>
<h2>Overall Structure</h2>
<p>The main function of the simulation takes a dictionary of parameter values,
creates a SimPy environment,
does a little bit of magic,
and then simulates the system for a specified length of time:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Run simulation.&quot;&quot;&quot;</span>

    <span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;random_seed&quot;</span><span class="p">])</span>
    <span class="n">env</span> <span class="o">=</span> <span class="n">simpy</span><span class="o">.</span><span class="n">Environment</span><span class="p">()</span>
    <span class="n">developers</span> <span class="o">=</span> <span class="n">simpy</span><span class="o">.</span><span class="n">Resource</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">capacity</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;num_developers&quot;</span><span class="p">])</span>
    <span class="n">env</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">generate_tasks</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">developers</span><span class="p">))</span>
    <span class="n">env</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">until</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;simulation_duration&quot;</span><span class="p">])</span>
</code></pre></div>
<p>The &ldquo;magic&rdquo; referred to earlier has two parts:</p>
<ol>
<li>Since the developers are all the same (for now),
    we can model them using a SimPy <code>Resource</code> with a fixed capacity.
    This basically acts as a pile of things:
    our processes can take a thing if one is available,
    but will be suspended if one is not.</li>
<li>We then call <code>generate_tasks</code> to create the generator that adds new tasks to the system
    and give that generator to <code>env.process</code> to run.</li>
</ol>
<h2>Generating Tasks</h2>
<p>OK, what does <code>generate_tasks</code> do?</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">generate_tasks</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">developers</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generates tasks at random intervals.&quot;&quot;&quot;</span>

    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">env</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">expovariate</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;task_arrival_rate&quot;</span><span class="p">]))</span>
    <span class="n">task</span> <span class="o">=</span> <span class="n">TaskUniform</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="n">env</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">simulate_task</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">developers</span><span class="p">,</span> <span class="n">task</span><span class="p">))</span>
</code></pre></div>
<p>Each time around the loop,
it calls <code>env.timeout</code> to create an object representing a delay
and uses <code>yield</code> to hand that to SimPy,
which suspends the process until that much simulated time has passed.
When it resumes,
the generator creates a new <code>TaskUniform</code> object (we&rsquo;ll look at that in a moment)
and then calls <code>simulate_task</code> to create a new process (i.e., a new generator)
to simulate the execution of that task.
(The <code>while True</code> in this function is a bit misleading:
this generator hands control back to SimPy each time it encounters the <code>yield</code> statement,
and only resumes if SimPy reschedules it,
so it only runs as long as SimPy wants it to.)</p>
<blockquote>
<p>When I first started working with SimPy,
I found it a bit counter-intuitive to represent tasks as processes
rather than using processes for the workers.
It&rsquo;s possible to do the latter,
but the code turns out to be simpler if we treat developers as a passive resource.
Read into that what you will…</p>
</blockquote>
<h2>What Kind of Randomness?</h2>
<p>At this point we need to talk about math,
because <code>random.expovariate</code> is anything but intuitive.
Suppose that the probability of a task arriving at any moment is fixed
and completely independent of when the previous task arrived.
This is called a <em>memoryless</em> system,
and it turns out that the time between arrivals in such a system has an exponential distribution:
if the average arrival rate is λ events per unit time,
then the time between arrivals is an exponential random variable with mean 1/λ.
Real-world arrival rates are rarely this tidy,
but it&rsquo;s a good starting point.</p>
<h2>Representing Tasks</h2>
<p>We now have two bits of code to explore:
the <code>TaskUniform</code> class that represents a task
and the <code>simulate_task</code> function that models its behavior.
The former just stores a unique ID and a duration,
and knows how to represent itself as a string for printing:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TaskUniform</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Task with uniformly-distributed durations.&quot;&quot;&quot;</span>

    <span class="n">_id</span> <span class="o">=</span> <span class="n">count</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_id</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">TaskUniform</span><span class="o">.</span><span class="n">_id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_duration</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;max_task_duration&quot;</span><span class="p">])</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;task-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_duration</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span>
</code></pre></div>
<p>Note that we&rsquo;ve decided to model task durations as uniformly distributed
between 1.0 and some maximum value.
This might win a prize for &ldquo;least realistic assumption&rdquo;,
but we&rsquo;ll come back and adjust it later.</p>
<h2>Simulating a Task</h2>
<p>Finally,
we get to actually simulating a task.
As before,
the fact that this function uses <code>yield</code> means that it creates a generator;
I think that would have been clearer if a keyword like <code>gen</code> had been introduced in place of <code>def</code>,
but it is what it is:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">simulate_task</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">developers</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Simulate a task flowing through the system.&quot;&quot;&quot;</span>

    <span class="n">available</span> <span class="o">=</span> <span class="n">developers</span><span class="o">.</span><span class="n">capacity</span> <span class="o">-</span> <span class="n">developers</span><span class="o">.</span><span class="n">count</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">env</span><span class="o">.</span><span class="n">now</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">task</span><span class="si">}</span><span class="s2"> arrives, </span><span class="si">{</span><span class="n">available</span><span class="si">}</span><span class="s2"> available&quot;</span><span class="p">)</span>
    <span class="n">request_start</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">now</span>
    <span class="k">with</span> <span class="n">developers</span><span class="o">.</span><span class="n">request</span><span class="p">()</span> <span class="k">as</span> <span class="n">req</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">req</span>
        <span class="n">delay</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">now</span> <span class="o">-</span> <span class="n">request_start</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">env</span><span class="o">.</span><span class="n">now</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">task</span><span class="si">}</span><span class="s2"> starts after delay </span><span class="si">{</span><span class="n">delay</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">env</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">_duration</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">env</span><span class="o">.</span><span class="n">now</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">task</span><span class="si">}</span><span class="s2"> finishes&quot;</span><span class="p">)</span>
</code></pre></div>
<p>Going through this phrase by phrase:</p>
<ol>
<li>The task starts by reporting how many developers are available.
    (Remember, <code>developers</code> is a <code>Resource</code> with a fixed capacity;
    its <code>.count</code> tells us how much of that resource is currently being used.)</li>
<li>The task then records the time at which it starts running.
    We don&rsquo;t have to do this right at the start of the function
    (before checking the number of available developers)
    because we&rsquo;re not checking the computer&rsquo;s actual clock:
    <code>env.now</code> gives us the current simulated time in the SimPy environment,
    and that time only advances when processes tell the framework
    that they want it to.</li>
<li>We then ask for a developer using <code>developer.request()</code>.
    This method gives us an object that we store in <code>req</code>,
    which we immediately <code>yield</code> to tell SimPy what we want.
    If the request can be satisfied right away,
    SimPy immediately reschedules this process;
    if the resource is already at capacity,
    SimPy suspends this process until a developer is available.</li>
<li>…which means that as soon as execution passes the <code>yield req</code> line,
    we know that a resource is available.
    We print a message to report how long the task had to wait for a developer…</li>
<li>…and then <code>yield</code> the object created by calling <code>env.timeout</code> with the task&rsquo;s duration
    to tell SimPy that the task needs that much time to complete.</li>
<li>Finally,
    we print another message to report when the task finished…</li>
<li>…and give the developer back to the developer pool.
    <em>This isn&rsquo;t visible in the code</em>:
    it&rsquo;s done automatically when we reach the end of the <code>with</code> block,
    in the same way that a file opened in a <code>with</code> is automatically closed at the block&rsquo;s end.</li>
</ol>
<h2>A Sample Run</h2>
<p>Let&rsquo;s run the simulation with the following parameters:</p>
<div class="highlight"><pre><span></span><code><span class="n">PARAMS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;max_task_duration&quot;</span><span class="p">:</span> <span class="mf">10.0</span><span class="p">,</span>
    <span class="s2">&quot;task_arrival_rate&quot;</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span>
    <span class="s2">&quot;num_developers&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
    <span class="s2">&quot;simulation_duration&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
    <span class="s2">&quot;random_seed&quot;</span><span class="p">:</span> <span class="mi">12345</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>
<p>The output is:</p>
<div class="highlight"><pre><span></span><code>1.08: task-0/1.09 arrives, 2 developers available
1.08: task-0/1.09 starts after delay 0.00
2.17: task-0/1.09 finishes
4.57: task-1/3.69 arrives, 2 developers available
4.57: task-1/3.69 starts after delay 0.00
5.49: task-2/2.74 arrives, 1 developers available
5.49: task-2/2.74 starts after delay 0.00
7.15: task-3/2.46 arrives, 0 developers available
7.42: task-4/4.90 arrives, 0 developers available
8.23: task-2/2.74 finishes
8.23: task-3/2.46 starts after delay 1.07
8.25: task-1/3.69 finishes
8.25: task-4/4.90 starts after delay 0.83
9.07: task-5/2.57 arrives, 0 developers available
10.68: task-6/4.19 arrives, 0 developers available
10.68: task-3/2.46 finishes
10.68: task-5/2.57 starts after delay 1.61
13.15: task-4/4.90 finishes
13.15: task-6/4.19 starts after delay 2.47
13.25: task-5/2.57 finishes
17.03: task-7/1.82 arrives, 1 developers available
17.03: task-7/1.82 starts after delay 0.00
17.34: task-6/4.19 finishes
18.85: task-7/1.82 finishes
</code></pre></div>
<p>Things are certainly happening:
tasks are arriving and either starting immediately
or waiting until a developer is available.
But is our code correct?
And what does it tell us about how long tasks take to complete
and how busy developers are?
To answer those questions,
we need to collect some data and do a bit of analysis.
Stay tuned…</p>
</article>

<article class="post">
  <h2 class="post-title">
    <a href="../2025/11/18/starting-to-simulate/">
      Starting to Simulate
    </a>
  </h2>
  <p><time datetime="2025-11-18" class="post-date">2025-11-18</time></p>
  <p>Inspired in part by <a href="https://sim.curiousduck.io/">the software development simulator</a>
that Elisabeth Hendrickson and friends built,
I&rsquo;ve been toying with the idea of using <a href="https://simpy.readthedocs.io/">SimPy</a> to create something
that could be used in a half-day workshop to
(a) show people how powerful discrete event simulation can be, and
(b) demonstrate why simple measurements of developers&rsquo; work are almost always misleading.
It&rsquo;s been thirty-five years since I did this kind of simulation,
SimPy uses some features of Python that I haven&rsquo;t kept up with,
and I&rsquo;ve never taught this topic before,
so I&rsquo;m planning to do a few blog posts about how it works and what I&rsquo;m learning.</p>
<h2>Generators</h2>
<p>A <em>generator</em> is a Python function that creates an object
which uses its stack to maintain persistent state.
That probably doesn&rsquo;t make any sense unless you already understand it,
so here&rsquo;s an example:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">gen_char_from_string</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">text</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></div>
<p>The magic is the keyword <code>yield</code>,
which tells Python that this function creates a generator.
(I think the code would be easier to understand
if a keyword like <code>gen</code> had to be used instead of <code>def</code>,
but that ship sailed a long time ago.)
We can use our generator like this:</p>
<div class="highlight"><pre><span></span><code><span class="n">gen</span> <span class="o">=</span> <span class="n">gen_char_from_string</span><span class="p">(</span><span class="s2">&quot;one&quot;</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">ch</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">ch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ended by exception&quot;</span><span class="p">)</span>
</code></pre></div>
<p>As this code shows,
calling <code>gen_char_from_string</code> creates an object rather than immediately returning a value.
Each time we call <code>next</code> on that object,
it advances to the next <code>yield</code>.
The generator object preserves its stack,
so the local variables <code>text</code> and <code>i</code> persist from one invocation to the next.
When execution reaches the end of the generator,
Python thows a <code>StopIteration</code> exception to tell us it&rsquo;s done.</p>
<p>Why go to all this trouble?
First,
<code>for</code> loops understand how to interact with generators,
so we can rewrite the snippets above as:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">gen_char_from_string</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">text</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">ch</span>

<span class="n">characters</span> <span class="o">=</span> <span class="p">[</span><span class="n">ch</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">gen_char_from_string</span><span class="p">(</span><span class="s2">&quot;two&quot;</span><span class="p">)]</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;result as list: </span><span class="si">{</span><span class="n">characters</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>
<p>Second,
we can do things like create &ldquo;infinite&rdquo; generators:</p>
<p><div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">gen_infinite</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">text</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>


<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ch</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gen_infinite</span><span class="p">(</span><span class="s2">&quot;three&quot;</span><span class="p">)):</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">9</span><span class="p">:</span>
        <span class="k">break</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ch</span><span class="p">)</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code>0 t
1 h
2 r
3 e
4 e
5 t
6 h
7 r
8 e
9 e
</code></pre></div></p>
<p>or generate the cross-product of two arbitrary collections:</p>
<p><div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">gen_combinations</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">left_item</span> <span class="ow">in</span> <span class="n">left</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">right_item</span> <span class="ow">in</span> <span class="n">right</span><span class="p">:</span>
            <span class="k">yield</span> <span class="p">(</span><span class="n">left_item</span><span class="p">,</span> <span class="n">right_item</span><span class="p">)</span>


<span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">gen_combinations</span><span class="p">(</span><span class="s2">&quot;abc&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code>(&#39;a&#39;, 1)
(&#39;a&#39;, 2)
(&#39;a&#39;, 3)
(&#39;b&#39;, 1)
(&#39;b&#39;, 2)
(&#39;b&#39;, 3)
(&#39;c&#39;, 1)
(&#39;c&#39;, 2)
(&#39;c&#39;, 3)
</code></pre></div></p>
<p>We can even store our generators in a list (after all, they&rsquo;re just objects)
and then use them however we want:</p>
<p><div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">alternate</span><span class="p">(</span><span class="n">processes</span><span class="p">):</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">proc</span> <span class="ow">in</span> <span class="n">processes</span><span class="p">:</span>
                <span class="k">yield</span> <span class="nb">next</span><span class="p">(</span><span class="n">proc</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">break</span>

<span class="k">def</span><span class="w"> </span><span class="nf">seq</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">v</span>

<span class="n">sequences</span> <span class="o">=</span> <span class="p">[</span><span class="n">seq</span><span class="p">(</span><span class="s2">&quot;ab&quot;</span><span class="p">),</span> <span class="n">seq</span><span class="p">(</span><span class="s2">&quot;123&quot;</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">thing</span> <span class="ow">in</span> <span class="n">alternate</span><span class="p">(</span><span class="n">sequences</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">thing</span><span class="p">)</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code>a
1
b
2
</code></pre></div></p>
<h2>Discrete Event Simulation</h2>
<p><em>Discrete event simulation</em> models a system as a series of events,
each of which occurs at a particular instant in time.
We can simulate such a system by advancing the clock one tick at a time,
but it&rsquo;s more efficient to have each <em>process</em> tell us when it&rsquo;s next going to do something
and then jump ahead to the least of those times.</p>
<blockquote>
<p>Note: we&rsquo;re using the word &ldquo;process&rdquo; to mean &ldquo;something active&rdquo;
rather than &ldquo;an operating system process&rdquo;.
I prefer the word &ldquo;actor&rdquo;,
but &ldquo;process&rdquo; is pretty deeply embedded in discrete event simulation terminology.</p>
</blockquote>
<p>SimPy handles all these details for us.
All we have to do is:</p>
<ol>
<li>Create an <em>environment</em> that stores all the SimPy-ish stuff
    like the list of running processes.</li>
<li>Give it some processes to run.</li>
<li>Tell it to run the simulation until all the processes are done.</li>
</ol>
<div class="highlight"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">simpy</span>

<span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">():</span>
    <span class="n">env</span> <span class="o">=</span> <span class="n">simpy</span><span class="o">.</span><span class="n">Environment</span><span class="p">()</span>
    <span class="n">env</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">worker</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">worker_id</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_jobs</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">job_time</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">env</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">worker</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">worker_id</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">num_jobs</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">job_time</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">env</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Simulation completed at T=</span><span class="si">{</span><span class="n">env</span><span class="o">.</span><span class="n">now</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>
<p>The key thing here is that <code>worker</code> <em>isn&rsquo;t</em> a normal function call.
Instead of handing a value to <code>env.process</code>,
it creates a generator for the environment to run.
That generator yields <code>env.timeout(delay)</code> to tell SimPy
that it wants to wait for a certain length of time,
e.g.,
to simulate being busy.
(Processes can yield other things as well—we&rsquo;ll see some in future posts.)</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">worker</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">worker_id</span><span class="p">,</span> <span class="n">num_jobs</span><span class="p">,</span> <span class="n">job_time</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Actor with fixed-time jobs.&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;T=</span><span class="si">{</span><span class="n">env</span><span class="o">.</span><span class="n">now</span><span class="si">}</span><span class="s2"> worker </span><span class="si">{</span><span class="n">worker_id</span><span class="si">}</span><span class="s2"> starts&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">job_num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_jobs</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;T=</span><span class="si">{</span><span class="n">env</span><span class="o">.</span><span class="n">now</span><span class="si">}</span><span class="s2"> worker </span><span class="si">{</span><span class="n">worker_id</span><span class="si">}</span><span class="s2"> starts job </span><span class="si">{</span><span class="n">job_num</span><span class="si">}</span><span class="s2"> duration </span><span class="si">{</span><span class="n">job_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">env</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">job_time</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;T=</span><span class="si">{</span><span class="n">env</span><span class="o">.</span><span class="n">now</span><span class="si">}</span><span class="s2"> worker </span><span class="si">{</span><span class="n">worker_id</span><span class="si">}</span><span class="s2"> finishes job </span><span class="si">{</span><span class="n">job_num</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;T=</span><span class="si">{</span><span class="n">env</span><span class="o">.</span><span class="n">now</span><span class="si">}</span><span class="s2"> worker </span><span class="si">{</span><span class="n">worker_id</span><span class="si">}</span><span class="s2"> finishes&quot;</span><span class="p">)</span>
</code></pre></div>
<p>Here&rsquo;s the output:</p>
<div class="highlight"><pre><span></span><code>T=0 worker 1 starts
T=0 worker 1 starts job 0 duration 2
T=0 worker 2 starts
T=0 worker 2 starts job 0 duration 3
T=2 worker 1 finishes job 0
T=2 worker 1 starts job 1 duration 2
T=3 worker 2 finishes job 0
T=3 worker 2 starts job 1 duration 3
T=4 worker 1 finishes job 1
T=4 worker 1 starts job 2 duration 2
T=6 worker 2 finishes job 1
T=6 worker 2 starts job 2 duration 3
T=6 worker 1 finishes job 2
T=6 worker 1 finishes
T=9 worker 2 finishes job 2
T=9 worker 2 finishes
Simulation completed at T=9
</code></pre></div>
<h2>Next Steps</h2>
<p>A couple of workers doing fixed-size jobs, completely independently,
isn&rsquo;t a particularly interesting scenario.
The next post in this series will look at two things:</p>
<ol>
<li>How do we make a more realistic simulation?</li>
<li>How do we create more comprehensible output?</li>
</ol>
<p>These questions are equally important because
there&rsquo;s no point building something whose results we can&rsquo;t understand (and check).
Stay tuned…</p>
</article>

<article class="post">
  <h2 class="post-title">
    <a href="../2025/11/11/end-of-life-ideas/">
      End of Life Ideas
    </a>
  </h2>
  <p><time datetime="2025-11-11" class="post-date">2025-11-11</time></p>
  <p>Years ago, <a href="https://exple.tive.org/blarg/2025/11/11/historical-reasons-2/">Mike Hoye suggested</a> that we should retire Unix usernames
in the way that sports teams retire jersey numbers,
and for the same reasons.
I was reminded of this while doing interviews with people about how projects end;
a couple of other ideas that have come up are adding a <code>-eol</code> (end-of-life) modified to semantic versioning
similar to the <code>-beta</code> modifier,
so that <code>1.2.3-eol</code> would mean &ldquo;this is the last release this project is going to do&rdquo;,
and holding wakes for projects so that people can celebrate the contributions they <em>did</em> make
and the impact they <em>did</em> have.
If you have other suggestions or rituals,
please <a href="mailto:gvwilson@third-bit.com">get in touch</a>.</p>
</article>

<article class="post">
  <h2 class="post-title">
    <a href="../2025/10/25/cognitive-pollution/">
      Cognitive Pollution
    </a>
  </h2>
  <p><time datetime="2025-10-25" class="post-date">2025-10-25</time></p>
  <blockquote>
<p><em>Update: I have posted <a href="https://youtu.be/f86KBeJ7e2M">a recording of the talk</a>.</em></p>
</blockquote>
<p>I am grateful to <a href="https://sback.it/">Prof. Alberto Bacchelli</a>
for inviting me to give a colloquium at the <a href="https://www.ifi.uzh.ch/en.html">University of Zurich</a>
a couple of days ago.
My talk was titled <a href="../talks/sdgc/">Cocaine and Conway&rsquo;s Law</a>,
but what it was really about was how to teach young software developers about <em>cognitive pollution</em>.</p>
<p>When most existing software engineering courses talk about risk,
they talk about single-point incidents like the <a href="https://en.wikipedia.org/wiki/Therac-25">Therac-25</a>
or <a href="https://en.wikipedia.org/wiki/Ariane_flight_V88">Ariane 5 flight V88</a>
where there is a direct cause-and-effect relationship between a mistake in software and something bad happening.
I think we should instead talk about things like
<a href="https://en.wikipedia.org/wiki/Tetraethyllead">tetraethyl lead</a>
and <a href="https://en.wikipedia.org/wiki/Asbestos">asbestos</a>,
or about <a href="https://en.wikipedia.org/wiki/Purdue_Pharma">Purdue Pharma</a>&rsquo;s role in the opioid epidemic
and the <a href="https://en.wikipedia.org/wiki/Fossil_fuels_lobby">fossil fuels lobby</a>&rsquo;s campaign
to promote <a href="https://en.wikipedia.org/wiki/Climate_change_denial">climate change denial</a>.</p>
<p>In each of these cases,
deliberate choices increased the general level of risk to hundreds of millions of people,
but the statistical nature of that risk
allowed those responsible to avoid personal accountability.
I think that case studies like these will help learners understand things like
the role that Meta&rsquo;s algorithms played in the <a href="https://en.wikipedia.org/wiki/Rohingya_genocide">Rohingya genocide</a>
and think more clearly about scenarios like the one below:</p>
<blockquote>
<p>It is 2035.
Most men under 20 have learned what they &ldquo;know&rdquo; about what women like
from AI chatbots trained on porn and tuned to maximize engagement.
As a result,
many of them believe that a frightened &ldquo;no&rdquo; actually means &ldquo;yes please&rdquo;.
The people who have earned billions from these systems
cannot legally be held accountable for their users&rsquo; actions.</p>
<p>How does that make you feel?</p>
</blockquote>
<p>If you are currently teaching an undergraduate course that covers cases like these,
please <a href="mailto:gvwilson@third-bit.com">get in touch</a>:
I&rsquo;d be grateful for a chance to learn from you.</p>
</article>

<article class="post">
  <h2 class="post-title">
    <a href="../2025/10/18/one-small-command/">
      One Small Command
    </a>
  </h2>
  <p><time datetime="2025-10-18" class="post-date">2025-10-18</time></p>
  <blockquote>
<p>Please note that I am suffering from jet lag and recovering from a bad cold while writing this,
which means my proposal may well be garbage.</p>
</blockquote>
<p>I&rsquo;ve had a lot of conversations over the years about
the differences in how software engineers and data scientists work.
One example is how they manage software:</p>
<ul>
<li>
<p>Software engineers regard duplicated code as sinful and refactor to avoid it.</p>
</li>
<li>
<p>Data scientists routinely copy a notebook or a script and make small changes to do a new data analysis.
    After many years,
    I have accepted that they are right to do so:
    their analyses are often exploratory one-offs,
    so copy-and-modify is more efficient than generalize-and-parameterize.</p>
</li>
</ul>
<p>The problem is that software engineers build tools for software engineers,
which means they don&rsquo;t automatically support data scientists&rsquo; workflows.
Continuing the refactor-versus-copy example,
Git doesn&rsquo;t have a way to explicitly say &ldquo;this file started as a copy of that one&rdquo;.
Git has a way to say &ldquo;this file was moved or renamed&rdquo; (<code>git mv</code>),
but there isn&rsquo;t a corresponding <code>git cp</code> command
because software engineers believe that you shouldn&rsquo;t be doing that.
You can ask Git to guess which files were copied in each commit:</p>
<div class="highlight"><pre><span></span><code>git log --find-copies --diff-filter=C --stat
</code></pre></div>
<p>but (a) you probably didn&rsquo;t know this existed,
(b) you&rsquo;re not going to remember it,
and (c) Git&rsquo;s heuristics often produce incorrect answers.</p>
<p>So let&rsquo;s add <code>git cp</code> so that the log records copying events explicitly.
That will allow us to trace the lineage of copied-and-modified notebooks and scripts
(and the copied-and-modified configuration files that software engineers create
because they don&rsquo;t think of YAML and TOML as code).
Doing this won&rsquo;t solve all our traceability problems,
but I think it will solve some of them,
and we&rsquo;ll learn something useful from its failure if it doesn&rsquo;t.</p>
</article>

<article class="post">
  <h2 class="post-title">
    <a href="../2025/10/08/labwork-to-leadership/">
      Labwork to Leadership
    </a>
  </h2>
  <p><time datetime="2025-10-08" class="post-date">2025-10-08</time></p>
  <p>Jen Heemstra&rsquo;s
<a href="https://isbnsearch.org/isbn/9780674258631"><em>Labwork to Leadership: A Concise Guide to Thriving in the Science Job You Weren’t Trained For</em></a>
is the book I&rsquo;ve been hoping to find for years.
It includes sections on managing yourself, managing others, and coaching future leaders,
all grounded in first-hand experience and empirical research.
I wish it included more on <a href="https://gvwilson.github.io/change/">organizational change</a>
and <a href="../2025/09/12/searching-for-closure/">winding projects down</a>,
but those are <em>my</em> preoccupations:
as is,
it would be a great foundation for a Carpentries-style workshop,
and I hope someone creates that.</p>
<div class="center">
  <img src="../files/books/heemstra-leadership.jpg" alt="cover of Heemstra's 'Labwork to Leadership'">
</div>
</article>


    </main>
    <footer>
  &copy; 2004-2025 <a href="../about/">Greg Wilson</a>
  <a href="mailto:gvwilson@third-bit.com"><img src="../assets/icons/envelope.svg" alt="email" class="footer-icon"></a>
  <a href="https://www.linkedin.com/in/gvwilson/"><img src="../assets/icons/linkedin.svg" alt="LinkedIn" class="footer-icon"></a>
  <a href="https://mastodon.social/@gvwilson"><img src="../assets/icons/mastodon.svg" alt="Mastodon" class="footer-icon"></a>
  <a href="https://calendly.com/gvwilson/30min"><img src="../assets/icons/calendar.svg" alt="Calendly" class="footer-icon"></a>
  <a href="https://github.com/gvwilson"><img src="../assets/icons/github.svg" alt="GitHub" class="footer-icon"></a>
  <a href="https://www.youtube.com/channel/UCbDQ7FIeYB3FHRADAjUjfrg"><img src="../assets/icons/youtube.svg" alt="YouTube" class="footer-icon"></a>
  <a href="../bib/"><img src="../assets/icons/orcid.svg" alt="ORCID" class="footer-icon"></a>
  <a href="../atom.xml"><img src="../assets/icons/rss.svg" alt="RSS feed" class="footer-icon"></a>
  <a href="../license/"><img src="../assets/icons/cc-by.svg" alt="license" class="footer-icon"></a>
  <a href="../colophon/"><img src="../assets/icons/pencil.svg" alt="colophon" class="footer-icon"></a>
  <a href="../cv/"><img src="../assets/icons/file.svg" alt="CV" class="footer-icon"></a>
  <br>
  None of the material on this site may be used to train AI models without the express prior permission of the author.
</footer>
  </body>
</html>