<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<link rel="me" href="https://mastodon.social/@gvwilson">
<link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
<link rel="alternate" type="application/atom+xml" title="The Third Bit" href="../atom.xml">
<!-- <script defer data-domain="third-bit.com" src="https://plausible.io/js/plausible.js"></script> -->
    <script src="https://kit.fontawesome.com/4eee35f757.js"></script>
    <link rel="stylesheet" href="../assets/thirdbit.css">
    <link rel="stylesheet" href="../assets/page.css">
    
<title>The Third Bit Blog</title>

    
  </head>
  <body>
    <nav>
  <div class="row underline">
    <div class="col-2 left">
      <a class="navlink" href="../">Home</a>
    </div>
    <div class="col-10 right">
      <a class="navlink" href="../about/">about</a>
      <a class="navlink" href="../blog/">blog</a>
      <a class="navlink" href="../selected/">selected</a>
      <a class="navlink" href="../talks/">talks</a>
      <a class="navlink" href="../bib/">bibliography</a>
      <a class="navlink" href="../fiction/">fiction</a>
    </div>
  </div>
</nav>
    <main>
      
<h1>Blog</h1>


<table class="centered">
  <tbody>
    <tr>
      <td><a href="../archive/2020">2020</a></td>
      <td><a href="../archive/2021">2021</a></td>
      <td><a href="../archive/2022">2022</a></td>
      <td><a href="../archive/2023">2023</a></td>
      <td><a href="../archive/2024">2024</a></td>
      <td><a href="../archive/2025">2025</a></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td><a href="../archive/2010">2010</a></td>
      <td><a href="../archive/2011">2011</a></td>
      <td><a href="../archive/2012">2012</a></td>
      <td><a href="../archive/2013">2013</a></td>
      <td><a href="../archive/2014">2014</a></td>
      <td><a href="../archive/2015">2015</a></td>
      <td><a href="../archive/2016">2016</a></td>
      <td><a href="../archive/2017">2017</a></td>
      <td><a href="../archive/2018">2018</a></td>
      <td><a href="../archive/2019">2019</a></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td><a href="../archive/2004">2004</a></td>
      <td><a href="../archive/2005">2005</a></td>
      <td><a href="../archive/2006">2006</a></td>
      <td><a href="../archive/2007">2007</a></td>
      <td><a href="../archive/2008">2008</a></td>
      <td><a href="../archive/2009">2009</a></td>
    </tr>
  </tbody>
</table>


<article class="post">
  <h2 class="post-title">
    <a href="../2025/12/08/the-real-hardest-problem/">
      The Real Hardest Problem
    </a>
  </h2>
  <p><time datetime="2025-12-08" class="post-date">2025-12-08</time></p>
  <blockquote>
<p>There are only two hard things in computer science:
cache invalidation and naming things.</p>
<p>— Phil Karlton</p>
</blockquote>
<p>With respect,
I think that handling interrupts is harder than either of these.
<a href="../2025/12/07/handling-interruptions/">Yesterday&rsquo;s post</a> explained how <a href="https://simpy.readthedocs.io/">SimPy</a> does this.
Today,
after several near misses,
we&rsquo;ll look at how to add it to our simulation.</p>
<h2>A Quick Recap</h2>
<p>Our <code>Simulation</code> class now includes a process
that waits a random interval,
chooses a random developer,
and interrupts her by calling <code>.interrupt</code>:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Simulation</span><span class="p">:</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">annoy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t_interrupt_arrival</span><span class="p">())</span>
            <span class="n">dev</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">developers</span><span class="p">)</span>
            <span class="n">dev</span><span class="o">.</span><span class="n">proc</span><span class="o">.</span><span class="n">interrupt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t_interrupt_duration</span><span class="p">())</span>
</code></pre></div>
<p>When <code>.interrupt</code> is called,
SimPy injects a <code>simpy.Interrupt</code> exception into the target process;
the argument to <code>.interrupt</code> is attached to that exception object.
If we&rsquo;re comfortable throwing away the task we&rsquo;re currently working on,
the <code>Developer</code> process can catch the exception like this:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Developer</span><span class="p">(</span><span class="n">Labeled</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">req</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">req</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">dev_queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
                <span class="n">task</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">req</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">dev_required</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">simpy</span><span class="o">.</span><span class="n">Interrupt</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">req</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">req</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
</code></pre></div>
<p>The trickiest part of this is canceling the outstanding request
to get something from the development queue.
As we discovered yesterday,
if we <em>don&rsquo;t</em> do this,
the developer won&rsquo;t ever get anything else from the queue.</p>
<h2>Nearly Right</h2>
<p>What if we <em>don&rsquo;t</em> want to throw away our current task when we&rsquo;re interrupted?
What if instead we want to handle the interruption and then resume that task?
Here&rsquo;s an implementation that&rsquo;s almost right:</p>
<div class="highlight"><pre><span></span><code>    <span class="c1"># This code is wrong.</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">task</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">req</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">task</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">req</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">dev_queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
                    <span class="n">task</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">req</span>
                <span class="n">t_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">now</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">dev_required</span> <span class="o">-</span> <span class="n">task</span><span class="o">.</span><span class="n">dev_done</span><span class="p">)</span>
                <span class="n">task</span><span class="o">.</span><span class="n">dev_done</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">now</span> <span class="o">-</span> <span class="n">t_start</span>
                <span class="k">if</span> <span class="n">task</span><span class="o">.</span><span class="n">is_done</span><span class="p">():</span>
                    <span class="n">task</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">except</span> <span class="n">simpy</span><span class="o">.</span><span class="n">Interrupt</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">req</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">req</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">exc</span><span class="o">.</span><span class="n">cause</span><span class="p">)</span>
</code></pre></div>
<p>Inside the <code>try</code> block we get a task if we don&rsquo;t already have one,
then try to wait for as much time as the task still requires.
When we&rsquo;re done we add some time to the task and check if it&rsquo;s now complete.
If we&rsquo;re interrupted,
we cancel any outstanding request for a new task
and then wait for as long as the interrupt tells us to.</p>
<p>There are (at least) two things wrong with this code.
The first and less important is that when we&rsquo;re interrupted,
we throw away any work we&rsquo;ve done on the task during this iteration of the loop.
That&rsquo;s relatively easy to fix:
we just add some code to the <code>except</code> block to increment the <code>.dev_done</code> time in the task.</p>
<p>The bigger problem,
though,
is that sooner or later this code fails because of an uncaught <code>Interrupt</code> exception.
The problem is that we can be interrupted
<em>inside our interrupt handler</em>.
It isn&rsquo;t likely,
which means it doesn&rsquo;t happen very often,
but if we run the simulation often enough with different random seeds,
it eventually falls over.</p>
<h2>A Corrected Version</h2>
<p>The &ldquo;fix&rdquo; (I&rsquo;ll explain the scare quotes around that word in a moment)
is to move interrupt handling into the <code>try</code> block.
To do that,
we have to add another state variable <code>interrupt_delay</code>
that tells the process if it&rsquo;s currently supposed to be handling an interruption delay:</p>
<div class="highlight"><pre><span></span><code>    <span class="k">def</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">task</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">interrupt_delay</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">req</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">interrupt_delay</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">interrupt_delay</span><span class="p">)</span>
                    <span class="n">interrupt_delay</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">task</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">req</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">dev_queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
                        <span class="n">task</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">req</span>
                    <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">dev_required</span> <span class="o">-</span> <span class="n">task</span><span class="o">.</span><span class="n">dev_done</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">task</span><span class="o">.</span><span class="n">is_done</span><span class="p">():</span>
                        <span class="n">task</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">except</span> <span class="n">simpy</span><span class="o">.</span><span class="n">Interrupt</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">req</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">req</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
                <span class="n">interrupt_delay</span> <span class="o">=</span> <span class="n">exc</span><span class="o">.</span><span class="n">cause</span>
</code></pre></div>
<p>So why did I put scare quotes around the word &ldquo;fix&rdquo;?
Because I&rsquo;m still not 100% sure this works.
It hasn&rsquo;t failed yet,
despite multiple runs with different seeds and parameters,
but this code is now complex enough that I could well believe it contains
a one-in-a-million edge case.
I <em>think</em> the <code>except</code> block is now a critical region,
i.e.,
that no interrupts can occur within it
because none of those three lines hands control back to SimPy,
but I&rsquo;m not completely sure.</p>
<p>And yes,
this code still throws away any work the developer has done on a task
during a particular loop iteration
if an interrupt occurs;
the interrupt handler should increment <code>task.dev_done</code>.
And yes,
it&rsquo;s possible for an interrupt to be interrupted:
a more realistic implementation would stack interrupt delays,
but honestly,
if my boss interrupts me while I&rsquo;m being interrupted,
I don&rsquo;t have any qualms about discarding the first interruption.</p>
<h2>Yaks and More Yaks</h2>
<p>My goal with this series of blog posts was
to simulate the development process of a small software team.
I&rsquo;ve spent most of the last week learning more about <a href="https://simpy.readthedocs.io/">SimPy</a>;
it feels like <a href="https://en.wiktionary.org/wiki/yak_shaving">yak shaving</a>,
but without it,
I don&rsquo;t think I&rsquo;d have confidence in the code shown above
(or be able to review its AI-generated equivalent).</p>
</article>

<article class="post">
  <h2 class="post-title">
    <a href="../2025/12/07/handling-interruptions/">
      Handling Interruptions
    </a>
  </h2>
  <p><time datetime="2025-12-07" class="post-date">2025-12-07</time></p>
  <p>The <a href="../2025/12/04/the-effects-of-rework/">previous post in this series</a> looked at the effects of re-work on throughput.
Its version of the simulation assumed that
a task that needed to be re-done was given back to the developer who had originally worked on it,
and that she would tackle that task once she finished whatever she was doing at the time.
In reality,
though,
developers (and testers) often interrupt what they&rsquo;re doing,
switch to another task,
and then switch back.
This post looks at how to simulate that in <a href="https://simpy.readthedocs.io/">SimPy</a>.</p>
<h2>A Simpler Model</h2>
<p>To start with,
let&rsquo;s go back to a simpler model in which one process adds new tasks to a queue at random intervals,
while developers take tasks,
work on them,
and then mark them as done.
While we&rsquo;re building it,
we&rsquo;ll use these parameters:</p>
<div class="highlight"><pre><span></span><code><span class="n">PARAMS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;n_dev&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>          <span class="c1"># number of developers</span>
    <span class="s2">&quot;rng_seed&quot;</span><span class="p">:</span> <span class="mi">12345</span><span class="p">,</span>   <span class="c1"># random number generation seed</span>
    <span class="s2">&quot;t_arrival&quot;</span><span class="p">:</span> <span class="mf">8.0</span><span class="p">,</span>    <span class="c1"># mean task arrival time</span>
    <span class="s2">&quot;t_dev&quot;</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">,</span>        <span class="c1"># median development time</span>
    <span class="s2">&quot;t_interrupt&quot;</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">,</span>  <span class="c1"># time between interrupts</span>
    <span class="s2">&quot;t_sim&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>         <span class="c1"># length of simulation</span>
<span class="p">}</span>
</code></pre></div>
<p>As before,
we define a <code>Simulation</code> class to hold all our bits and pieces.
Its constructor caches the parameters,
then creates the SimPy <code>Environment</code>,
the development queue,
and the developers.
It also creates a simple list called <code>.log</code> to store log messages:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Simulation</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Overall simulation.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span> <span class="o">=</span> <span class="n">simpy</span><span class="o">.</span><span class="n">Environment</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dev_queue</span> <span class="o">=</span> <span class="n">simpy</span><span class="o">.</span><span class="n">Store</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">developers</span> <span class="o">=</span> <span class="p">[</span><span class="n">Developer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;n_dev&quot;</span><span class="p">])]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="p">[]</span>
</code></pre></div>
<p>For lack of anywhere better to put it,
we define the task generator as a method of <code>Simulation</code>.
The order of statements in the <code>while</code> loop ensures that
the first task is generated at t=0:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Simulation</span><span class="p">:</span>
    <span class="err">…</span><span class="n">previous</span> <span class="n">code</span><span class="err">…</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">generate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate tasks at random intervals starting at t=0.&quot;&quot;&quot;</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">dev_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">Task</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t_arrival</span><span class="p">())</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proc</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Shortcut for running a process.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">proc</span><span class="p">)</span>
</code></pre></div>
<p>As before,
we also give <code>Simulation</code> some convenience methods like <code>.process</code>
so that we can type <code>sim.process(…)</code> rather than <code>sim.env.process(…)</code>.</p>
<h2>Creating Interrupts</h2>
<p>What&rsquo;s new in this simulation is another process
whose only purpose is to interrupt developers.
It does this by choosing a random developer <code>dev</code> every few clock ticks
and then calling <code>dev.proc.interrupt()</code>:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Simulation</span><span class="p">:</span>
    <span class="err">…</span><span class="n">previous</span> <span class="n">code</span><span class="err">…</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">annoy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate annoying interruptions.&quot;&quot;&quot;</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;t_interrupt&quot;</span><span class="p">])</span>
            <span class="n">dev</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">developers</span><span class="p">)</span>
            <span class="n">dev</span><span class="o">.</span><span class="n">proc</span><span class="o">.</span><span class="n">interrupt</span><span class="p">()</span>
</code></pre></div>
<p><code>dev.proc.interrupt()</code> only makes sense once we have looked at
the constructor for the <code>Developer</code> class:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Developer</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A generic worker.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sim</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sim</span> <span class="o">=</span> <span class="n">sim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">work</span><span class="p">())</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="err">…</span><span class="n">the</span> <span class="n">generator</span> <span class="n">simulating</span> <span class="n">a</span> <span class="n">developer</span><span class="s1">&#39;s behavior…</span>
</code></pre></div>
<p>Here&rsquo;s what&rsquo;s going on:</p>
<ol>
<li>
<p><code>Developer.work</code> is (going to be) a generator that simulates
    an individual developer&rsquo;s behavior.</p>
</li>
<li>
<p>Calling it as <code>self.work()</code> in <code>Developer.__init__</code> <em>doesn&rsquo;t</em> start a process.
    Instead, that call creates a generator object.</p>
</li>
<li>
<p>We pass that generator object to <code>self.sim.process()</code>,
    which gives it to the SimPy <code>Environment</code> to run.
    Doing this means that developers start running as soon as they are created.</p>
</li>
<li>
<p>Finally,
    <code>self.sim.process(…)</code> returns the generator object that was passed into it.
    We save this in the <code>Developer</code> object as <code>self.proc</code>
    so that we can access it later.
    (This step was the one that initially confused me.
    <code>Developer</code> isn&rsquo;t a SimPy process:
    the generator object created by calling <code>Developer.work</code> is the process.
    If we want to interrupt the process,
    we need to get at the generator object,
    and the logical place to store a reference to it is
    in the object that defines its behavior.)</p>
</li>
</ol>
<p>So let&rsquo;s jump back to <code>Simulation.annoy</code>. It contains the lines:</p>
<div class="highlight"><pre><span></span><code>    <span class="n">dev</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">developers</span><span class="p">)</span>
    <span class="n">dev</span><span class="o">.</span><span class="n">proc</span><span class="o">.</span><span class="n">interrupt</span><span class="p">()</span>
</code></pre></div>
<p>which mean:</p>
<ol>
<li>
<p>Choose a developer at random.</p>
</li>
<li>
<p>Get a reference to that developer&rsquo;s generator object <code>dev.proc</code>.</p>
</li>
<li>
<p>Call the object&rsquo;s <code>.interrupt</code> method.</p>
</li>
</ol>
<p>The last of those steps injects a <code>simpy.Interrupt</code> exception into the process,
so let&rsquo;s take a look at how we handle that.</p>
<h2>Handling Interrupts</h2>
<p>Here&rsquo;s a simple version of a developer that can handle interrupts:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Developer</span><span class="p">(</span><span class="n">Labeled</span><span class="p">):</span>
    <span class="err">…</span><span class="n">constructor</span><span class="err">…</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">req</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">req</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">dev_queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
                <span class="n">task</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">req</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">dev_required</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">simpy</span><span class="o">.</span><span class="n">Interrupt</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">req</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">req</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
</code></pre></div>
<p>This developer does the following each time it goes around the <code>while</code> loop:</p>
<ol>
<li>
<p>Create a request to get a task from the development queue.</p>
</li>
<li>
<p><code>yield</code> that request,
    which hands the request to the SimPy <code>Environment</code>
    and suspends this process until the request can be satisfied.</p>
</li>
<li>
<p>The result of yielding the request is a task from the development queue,
    so wait a while to simulate working on that task.</p>
</li>
<li>
<p><em>Unless</em> a <code>simpy.Interrupt</code> exception occurs,
    in which case the developer cancels the request for a task
    and goes around the loop again.</p>
</li>
</ol>
<p>We have run into <a href="../2025/12/03/you-have-to-cancel/">the need to cancel</a> before.
In the first version of this code,
I assumed that interrupts would only occur while a developer was working on a task,
so the body of the <code>except</code> block was just <code>pass</code>:</p>
<div class="highlight"><pre><span></span><code>    <span class="c1"># This version is wrong!</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">req</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">req</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">dev_queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
                <span class="n">task</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">req</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">dev_required</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">simpy</span><span class="o">.</span><span class="n">Interrupt</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="k">pass</span>
</code></pre></div>
<p>What I found was that if the interrupt occurred while the developer was waiting on the queue,
and I <em>didn&rsquo;t</em> cancel the request,
subsequent requests were never satisfied.
In other words,
once a developer had been interrupted,
she would never get any more work.</p>
<h2>How It Behaves</h2>
<p>I won&rsquo;t bother to show the code that adds log messages to <code>Simulation.log</code>
or collects the states of all the tasks when the simulation is done,
but here&rsquo;s the JSON output from a typical short run:</p>
<div class="highlight"><pre><span></span><code>{
  &quot;params&quot;: {
    …as shown earlier…
  },
  &quot;messages&quot;: [
    &quot;developer-0 0.00 start task-0&quot;,
    &quot;developer-0 3.00 interrupted in task-0&quot;,
    &quot;developer-0 6.00 interrupted in None&quot;,
    &quot;developer-0 9.00 interrupted in None&quot;,
    &quot;developer-0 12.00 interrupted in None&quot;,
    &quot;developer-0 13.95 start task-1&quot;,
    &quot;developer-0 15.00 interrupted in task-1&quot;,
    &quot;developer-0 15.01 start task-2&quot;,
    &quot;developer-0 16.68 complete task-2&quot;,
    &quot;developer-0 18.00 interrupted in None&quot;
  ],
  &quot;tasks&quot;: [
    {
      &quot;id&quot;: 0,
      &quot;created&quot;: 0,
      &quot;dev_required&quot;: 4.33,
      &quot;state&quot;: [&quot;dev_queue&quot;, &quot;dev&quot;, &quot;interrupted&quot;]
    },
    {
      &quot;id&quot;: 1,
      &quot;created&quot;: 13.95,
      &quot;dev_required&quot;: 5.72,
      &quot;state&quot;: [&quot;dev_queue&quot;, &quot;dev&quot;, &quot;interrupted&quot;]
    },
    {
      &quot;id&quot;: 2,
      &quot;created&quot;: 15.01,
      &quot;dev_required&quot;: 1.67,
      &quot;state&quot;: [&quot;dev_queue&quot;, &quot;dev&quot;, &quot;complete&quot;]
    }
  ]
}
</code></pre></div>
<p>As you can see,
the first two tasks are interrupted and discarded while they&rsquo;re being worked on,
while the developer manages to finish the third task before she&rsquo;s interrupted.
The next step will be to resume tasks rather than just throwing them away.</p>
</article>

<article class="post">
  <h2 class="post-title">
    <a href="../2025/12/06/remembrance/">
      Remembrance
    </a>
  </h2>
  <p><time datetime="2025-12-06" class="post-date">2025-12-06</time></p>
  <p>Jamais plus.</p>
<div class="center">
  <img src="../files/dec-6.png" alt="victims of the Dec 6 massacre" width="90%>
</div>

<div class="center">
  <img src="../files/dec-6-plaque.png" alt="plaque for victims the Dec 6 massacre" width="90%>
</div>
</article>

<article class="post">
  <h2 class="post-title">
    <a href="../2025/12/04/the-effects-of-rework/">
      The Effects of Rework
    </a>
  </h2>
  <p><time datetime="2025-12-04" class="post-date">2025-12-04</time></p>
  <p>Having <a href="../2025/12/03/you-have-to-cancel/">solved yesterday&rsquo;s bug</a>,
we can get back to looking at the effect of re-work on throughput.
As a reminder,
our workflow looks like this:</p>
<div class="highlight"><pre><span></span><code>+----------------+    +-----------+    +------------+    +------------+    +---------+
| task generator | -&gt; | dev queue | -&gt; | developers | -&gt; | test queue | -&gt; | testers |
+----------------+    +-----------+    +------------+    +------------+    +---------+
                            ^                                                   |
                            |                                                   |
                            +---------------------------------------------------+
</code></pre></div>
<p>The two parameters that affect re-work are <code>p_rework_needed</code>,
which is the probability that a tester is going to send a task back for more work,
and <code>p_rework_chosen</code>,
which is the probability that a developer will choose something from her re-work queue
rather than starting fresh work
when both are available.
The extreme cases are:</p>
<ul>
<li><code>p_rework_needed</code> = 0.0, meaning no tasks are ever sent back.</li>
<li><code>p_rework_needed</code> = 1.0, meaning every task is always sent back.
    (Note that this means no task will ever be finished:
    instead,
    tasks will circulate endlesslesly between development and testing,
    and yes,
    sometimes it does feel like that happens in real life.)</li>
<li><code>p_rework_chosen</code> = 0.0, in which case
    developers only re-do tasks when there is no new work queued up.
    (We know from previous simulations that there are almost always
    new tasks waiting to be started.)</li>
<li><code>p_rework_chosen</code> = 1.0, in which case
    developers only start new tasks when nothing needs to be re-done.</li>
</ul>
<p>Finally,
this version of the simulation always sends tasks back to
the developers who originally worked on them
rather than allowing the first available developer
to re-do someone else&rsquo;s work.</p>
<h2>Final States</h2>
<p>The figure below shows the number of tasks in each of the five possible states
at the end of the simulation
as a function of <code>p_rework_needed</code> and <code>p_rework_chosen</code>:</p>
<div class="center">
  <img src="../files/2025/12/04/states.svg" alt="final task states" width="90%">
</div>

<p>As expected,
lots of tasks are in the <code>complete</code> state when there is never any need for re-work,
while none are when re-work is always needed.
This finding may seem obvious,
but this simple check uncovered a couple of bugs in the simulation.</p>
<p>A more interesting finding is that
how developers choose tasks doesn&rsquo;t seem to have much effect
on how many they get done:
while there is some variation,
the bars stay more or less the same height when we look at each row.</p>
<p>We can reach the same conclusion by looking at
the number of times tasks were developed and re-worked.
The sizes of the circles in the plots below reflect these counts:</p>
<div class="row">
  <div class="col-6 center">
    <img src="../files/2025/12/04/n_dev.svg" alt="development count" width="90%">
  </div>
  <div class="col-6 center">
    <img src="../files/2025/12/04/n_rework.svg" alt="re-work count" width="90%">
  </div>
</div>

<p>Again,
the probability of needing re-work has an obvious impact,
while the probability of choosing new work vs. re-work doesn&rsquo;t seem to.</p>
</article>

<article class="post">
  <h2 class="post-title">
    <a href="../2025/12/03/you-have-to-cancel/">
      You Have to Cancel
    </a>
  </h2>
  <p><time datetime="2025-12-03" class="post-date">2025-12-03</time></p>
  <p>It has taken me almost three hours to answer <a href="../2025/12/03/in-search-of-sturdiness/">my earlier question</a> about <a href="https://simpy.readthedocs.io/">SimPy</a>,
and once I recover,
I&rsquo;m going to submit a couple of PRs for their documentation.
To recap,
the most recent version of the simulation
all testers to bounce work back to the development queue if they find bugs:</p>
<div class="highlight"><pre><span></span><code>+----------------+    +-----------+    +------------+    +------------+    +---------+
| task generator | -&gt; | dev queue | -&gt; | developers | -&gt; | test queue | -&gt; | testers |
+----------------+    +-----------+    +------------+    +------------+    +---------+
                            ^                                                   |
                            |                                                   |
                            +---------------------------------------------------+
</code></pre></div>
<p>I&rsquo;m going to walk through the code I wrote,
the problem I had,
and the solution I (think I&rsquo;ve) found step by step.
If there&rsquo;s a simpler way,
or if this <em>is</em> documentation clearly somewhere,
please <a href="mailto:gvwilson@third-bit.com">let me know</a>.</p>
<h2>Tasks</h2>
<p>A <code>Task</code> has a unique ID and keeps track of how many times it has been worked on:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Task</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ident</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ident</span> <span class="o">=</span> <span class="n">ident</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;task-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ident</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="si">}</span><span class="s2">&quot;</span>
</code></pre></div>
<h2>The Overall Simulation</h2>
<p>Since I don&rsquo;t want to have to pass a whole bunch of parameters around,
<code>Simulation</code> stores the SimPy <code>Environment</code>,
our single developer,
our single tester,
and the three queues:
one for new tasks,
one for tasks that need to be reworked,
and one for tasks that are ready for testing:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Simulation</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Environment.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span> <span class="o">=</span> <span class="n">simpy</span><span class="o">.</span><span class="n">Environment</span><span class="p">()</span>

        <span class="c1"># One developer and one tester.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">developer</span> <span class="o">=</span> <span class="n">Developer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tester</span> <span class="o">=</span> <span class="n">Tester</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Queues for new development work, rework, and testing.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_dev</span> <span class="o">=</span> <span class="n">simpy</span><span class="o">.</span><span class="n">Store</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_rework</span> <span class="o">=</span> <span class="n">simpy</span><span class="o">.</span><span class="n">Store</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_test</span> <span class="o">=</span> <span class="n">simpy</span><span class="o">.</span><span class="n">Store</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">)</span>
</code></pre></div>
<p><code>Simulation</code> also defines the generator that creates new tasks
and puts them in the ready-to-develop queue:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Simulation</span><span class="p">:</span>
    <span class="err">…</span><span class="n">previous</span> <span class="n">code</span><span class="err">…</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">generate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">task</span> <span class="o">=</span> <span class="n">Task</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">now</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> create </span><span class="si">{</span><span class="n">task</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_dev</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">T_GEN</span><span class="p">)</span>
</code></pre></div>
<p>Finally,
<code>Simulation</code> defines a convenience method that runs everything:</p>
<div class="highlight"><pre><span></span><code>    <span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">generate</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">developer</span><span class="o">.</span><span class="n">work</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tester</span><span class="o">.</span><span class="n">work</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">until</span><span class="o">=</span><span class="n">T_SIM</span><span class="p">)</span>
</code></pre></div>
<p>For testing,
the parameters are:</p>
<div class="highlight"><pre><span></span><code><span class="n">N_TASK</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># number of tasks to create</span>
<span class="n">T_GEN</span> <span class="o">=</span> <span class="mi">1</span>   <span class="c1"># time between tasks</span>
<span class="n">T_DEV</span> <span class="o">=</span> <span class="mi">1</span>   <span class="c1"># time to do development</span>
<span class="n">T_TEST</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># time to do testing</span>
<span class="n">T_SIM</span> <span class="o">=</span> <span class="mi">4</span>   <span class="c1"># how long to run the whole simulation</span>
</code></pre></div>
<h2>Workers</h2>
<p>A generic <code>Worker</code> (either a developer or a tester)
caches the object that holds the overall simulation
and provides a couple of convenience methods for getting the current time
and for printing itself:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Worker</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sim</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sim</span> <span class="o">=</span> <span class="n">sim</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">now</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">now</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">now</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span>
</code></pre></div>
<h2>Testers</h2>
<p>The tester gets a task from the testing queue,
waits a tick to simulate work,
increments the task&rsquo;s internal count of how many times it has gone around the loop,
and then puts it in the rework queue:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Tester</span><span class="p">(</span><span class="n">Worker</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># Get a task from the testing queue.</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">: wait for task(s)&quot;</span><span class="p">)</span>
            <span class="n">task</span> <span class="o">=</span> <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">q_test</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">: got </span><span class="si">{</span><span class="n">task</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Do testing.</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">T_TEST</span><span class="p">)</span>
            <span class="n">task</span><span class="o">.</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># Always put the task in the rework queue.</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">q_rework</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">: put </span><span class="si">{</span><span class="n">task</span><span class="si">}</span><span class="s2"> in rework queue&quot;</span><span class="p">)</span>
</code></pre></div>
<h2>Developers (the wrong version)</h2>
<p><strong>This code is wrong, but will be fixed below.</strong></p>
<p>My original <code>Developer</code> waited until a task was available in <em>either</em>
the development queue or the rework queue,
then selected one of those tasks (giving priority to rework),
waited a tick to simulate work,
and put the task in the testing queue:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">DeveloperWrong</span><span class="p">(</span><span class="n">Worker</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># Get either a task for development or a task for rework.</span>
            <span class="n">req_dev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">q_dev</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="n">req_rework</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">q_rework</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">: wait for task(s)&quot;</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">simpy</span><span class="o">.</span><span class="n">AnyOf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">env</span><span class="p">,</span> <span class="p">[</span><span class="n">req_dev</span><span class="p">,</span> <span class="n">req_rework</span><span class="p">])</span>

            <span class="c1"># Give priority to rework.</span>
            <span class="k">if</span> <span class="n">req_rework</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
                <span class="n">task</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">req_rework</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> got </span><span class="si">{</span><span class="n">task</span><span class="si">}</span><span class="s2"> from rework with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">events</span><span class="p">)</span><span class="si">}</span><span class="s2"> events&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">req_dev</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
                <span class="n">task</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">req_dev</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> got </span><span class="si">{</span><span class="n">task</span><span class="si">}</span><span class="s2"> from dev with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">events</span><span class="p">)</span><span class="si">}</span><span class="s2"> events&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;how did we get here?&quot;</span>

            <span class="c1"># Do development.</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">T_DEV</span><span class="p">)</span>

            <span class="c1"># Put the task in the testing queue.</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">q_test</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">: put </span><span class="si">{</span><span class="n">task</span><span class="si">}</span><span class="s2"> in testing queue&quot;</span><span class="p">)</span>
</code></pre></div>
<p>According to the documentation,
<code>simpy.AnyOf</code> creates an object that means &ldquo;give me any of the following&rdquo;.
Its result is a dictionary-like object
whose keys are the requests
and whose values are items from one or more of the queues being waited on:
&ldquo;or more&rdquo; because it&rsquo;s possible for items to be available in multiple queues simultaneously.</p>
<h2>Output from the Buggy Version</h2>
<p>Here&rsquo;s the output using the <code>DeveloperWrong</code> class shown above:</p>
<div class="highlight"><pre><span></span><code>0.00 create task-0/0
DeveloperWrong/0.00: wait for task(s)
Tester/0.00: wait for task(s)
DeveloperWrong/0.00 got task-0/0 from dev with 1 events
1.00 create task-1/0
DeveloperWrong/1.00: put task-0/0 in testing queue
DeveloperWrong/1.00: wait for task(s)
Tester/1.00: got task-0/0
DeveloperWrong/1.00 got task-1/0 from dev with 1 events
2.00 create task-2/0
Tester/2.00: put task-0/1 in rework queue
Tester/2.00: wait for task(s)
DeveloperWrong/2.00: put task-1/0 in testing queue
DeveloperWrong/2.00: wait for task(s)
Tester/2.00: got task-1/0
DeveloperWrong/2.00 got task-2/0 from dev with 1 events
3.00 create task-3/0
Tester/3.00: put task-1/1 in rework queue
Tester/3.00: wait for task(s)
DeveloperWrong/3.00: put task-2/0 in testing queue
DeveloperWrong/3.00: wait for task(s)
Tester/3.00: got task-2/0
DeveloperWrong/3.00 got task-3/0 from dev with 1 events
</code></pre></div>
<p>A lot is going on in those 23 lines,
so let&rsquo;s look at what the developer got from where:</p>
<div class="highlight"><pre><span></span><code>DeveloperWrong/0.00 got task-0/0 from dev with 1 events
DeveloperWrong/1.00 got task-1/0 from dev with 1 events
DeveloperWrong/2.00 got task-2/0 from dev with 1 events
DeveloperWrong/3.00 got task-3/0 from dev with 1 events
</code></pre></div>
<p>Hm:
the developer is never taking tasks from the rework queue.
Is the tester putting them in?</p>
<div class="highlight"><pre><span></span><code>Tester/0.00: wait for task(s)
Tester/1.00: got task-0/0
Tester/2.00: put task-0/1 in rework queue
Tester/2.00: wait for task(s)
Tester/2.00: got task-1/0
Tester/3.00: put task-1/1 in rework queue
Tester/3.00: wait for task(s)
Tester/3.00: got task-2/0
</code></pre></div>
<p>So what&rsquo;s going on?</p>
<h2>A Corrected Developer</h2>
<p>Here&rsquo;s the skeleton of the corrected developer&rsquo;s <code>work</code> method:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">DeveloperRight</span><span class="p">(</span><span class="n">Worker</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">which</span> <span class="o">=</span> <span class="s2">&quot;dev&quot;</span>
        <span class="n">take</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># Get either a task for development or a task for rework.</span>
            <span class="n">req_dev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">q_dev</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="n">req_rework</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">q_rework</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">: wait for task(s)&quot;</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">simpy</span><span class="o">.</span><span class="n">AnyOf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">env</span><span class="p">,</span> <span class="p">[</span><span class="n">req_dev</span><span class="p">,</span> <span class="n">req_rework</span><span class="p">])</span>

            <span class="err">…</span><span class="n">magic</span> <span class="n">happens</span> <span class="n">here</span><span class="err">…</span>

            <span class="c1"># Do development.</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">T_DEV</span><span class="p">)</span>

            <span class="c1"># Put the task in the testing queue.</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">q_test</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">: put </span><span class="si">{</span><span class="n">task</span><span class="si">}</span><span class="s2"> in testing queue&quot;</span><span class="p">)</span>
</code></pre></div>
<p>The bit of magic in the middle is that as far as I can tell,
all of the requests that <em>weren&rsquo;t</em> selected have to be canceled,
even if there wasn&rsquo;t something in the queue at the time for the developer to take.
For example,
the first time the developer gets a task from the development queue,
the rework queue is guaranteed to be empty,
but we still have to cancel the request for something from it.</p>
<p>In order to demonstrate this,
I&rsquo;ve filled in the magic portion of <code>work</code> with code that alternates between
taking work from the development queue (if available)
and taking work from the rework queue (ditto).
Of course,
if there is only one event in the result from <code>AnyOf</code>,
the code uses that,
but <em>still cancels the other request</em>:</p>
<div class="highlight"><pre><span></span><code>    <span class="k">def</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">which</span> <span class="o">=</span> <span class="s2">&quot;dev&quot;</span>
        <span class="n">take</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="err">…</span><span class="n">get</span> <span class="n">either</span> <span class="n">a</span> <span class="n">task</span> <span class="k">for</span> <span class="n">development</span> <span class="ow">or</span> <span class="n">a</span> <span class="n">task</span> <span class="k">for</span> <span class="n">rework</span><span class="err">…</span>

            <span class="c1"># Pick one.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">events</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">: ...got two events&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">which</span> <span class="o">==</span> <span class="s2">&quot;dev&quot;</span><span class="p">:</span>
                    <span class="n">take</span> <span class="o">=</span> <span class="s2">&quot;dev&quot;</span>
                    <span class="n">which</span> <span class="o">=</span> <span class="s2">&quot;rework&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">take</span> <span class="o">=</span> <span class="s2">&quot;rework&quot;</span>
                    <span class="n">which</span> <span class="o">=</span> <span class="s2">&quot;dev&quot;</span>
            <span class="k">elif</span> <span class="n">req_dev</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">events</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">: ...got dev&quot;</span><span class="p">)</span>
                <span class="n">take</span> <span class="o">=</span> <span class="s2">&quot;dev&quot;</span>
            <span class="k">elif</span> <span class="n">req_rework</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">events</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">: ...got rework&quot;</span><span class="p">)</span>
                <span class="n">take</span> <span class="o">=</span> <span class="s2">&quot;rework&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;how did we get here?&quot;</span>

            <span class="c1"># Now take it.</span>
            <span class="k">if</span> <span class="n">take</span> <span class="o">==</span> <span class="s2">&quot;dev&quot;</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">: ...taking dev&quot;</span><span class="p">)</span>
                <span class="n">task</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">req_dev</span><span class="p">]</span>
                <span class="n">req_rework</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">take</span> <span class="o">==</span> <span class="s2">&quot;rework&quot;</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">: ...taking rework&quot;</span><span class="p">)</span>
                <span class="n">task</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">req_rework</span><span class="p">]</span>
                <span class="n">req_dev</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;how did we get here?&quot;</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> got </span><span class="si">{</span><span class="n">task</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="err">…</span><span class="n">do</span> <span class="n">development</span> <span class="ow">and</span> <span class="n">put</span> <span class="n">the</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">testing</span> <span class="n">queue</span><span class="err">…</span>
</code></pre></div>
<p>Here are the relevant bits of output when the simulation is run for 10 ticks instead of just 4:</p>
<div class="highlight"><pre><span></span><code>DeveloperRight/0.00: ...taking dev
DeveloperRight/1.00: ...taking dev
DeveloperRight/2.00: ...taking dev
DeveloperRight/3.00: ...taking rework
DeveloperRight/4.00: ...taking dev
DeveloperRight/5.00: ...taking rework
DeveloperRight/6.00: ...taking dev
DeveloperRight/7.00: ...taking rework
DeveloperRight/8.00: ...taking dev
DeveloperRight/9.00: ...taking rework
</code></pre></div>
<p>As I said at the outset,
I&rsquo;m going to submit some PRs for SimPy&rsquo;s documentation
to shout loudly and clearly that outstanding requests need to be canceled
(or possibly recycled: I haven&rsquo;t tried that yet).
Meanwhile,
I can now get back to playing with the impact of rework fractions on throughput.</p>
</article>

<article class="post">
  <h2 class="post-title">
    <a href="../2025/12/03/in-search-of-sturdiness/">
      In Search of Sturdiness
    </a>
  </h2>
  <p><time datetime="2025-12-03" class="post-date">2025-12-03</time></p>
  <p>I took a break from this series of posts for a couple of days
to focus on <a href="../2025/11/21/looking-for-work/">looking for a new role</a>
and because I&rsquo;ve hit a bit of a roadblock.
In the most recent version of the simulation,
testers can bounce work back to the development queue if they find bugs:</p>
<div class="highlight"><pre><span></span><code>+----------------+    +-----------+    +------------+    +------------+    +---------+
| task generator | -&gt; | dev queue | -&gt; | developers | -&gt; | test queue | -&gt; | testers |
+----------------+    +-----------+    +------------+    +------------+    +---------+
                            ^                                                   |
                            |                                                   |
                            +---------------------------------------------------+
</code></pre></div>
<p>Tasks that have been sent back for more work always have higher priority than new tasks,
but that&rsquo;s not realistic.
What I&rsquo;d like to model is a system in which re-work is done by
the same developer who did the initial work.
I can do this by creating a re-work queue for each developer,
and use <a href="https://simpy.readthedocs.io/">SimPy</a>&rsquo;s <code>AnyOf</code> operator to select from either queue:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Developer</span><span class="p">(</span><span class="n">Worker</span><span class="p">):</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">rework_get</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rework_queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="n">new_get</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">dev_queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="n">result</span> <span class="o">=</span> <span class="k">yield</span><span class="p">(</span><span class="n">simpy</span><span class="o">.</span><span class="n">AnyOf</span><span class="p">(</span><span class="n">rework_get</span><span class="p">,</span> <span class="n">new_get</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">rework_get</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">events</span><span class="p">:</span>
                <span class="n">task</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">rework_get</span><span class="p">]</span>
                <span class="n">new_get</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">task</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">new_get</span><span class="p">]</span>
</code></pre></div>
<p>Notice that the &ldquo;get&rdquo; request for the new-work queue is canceled
when there&rsquo;s re-work to be done.
Doing this takes care of the case in which items were available in <em>both</em> queues
(which turns out to be very common);
I found by trial and error that canceling a &ldquo;get&rdquo; request has no effect
if the request is still pending,
which simplifies the logic a little bit.</p>
<p>So here&rsquo;s my problem:
when there is re-work to be done <em>and</em> the developer is working on a new task,
I&rsquo;d like to interrupt the developer and have them do re-work,
then resume their previous task;
in other words,
I&rsquo;d like re-work to take <em>immediate</em> precedence over new work.
However,
if the developer is already doing re-work,
I don&rsquo;t want to interrupt them.</p>
<p>SimPy supports interrupts:
if you have a process <code>p</code>, you can call <code>p.interrupt()</code> to throw an exception into it.
The process can catch this and do whatever it wants:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">p</span><span class="p">():</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="err">…</span><span class="n">normal</span> <span class="n">operation</span><span class="err">…</span>
        <span class="k">except</span> <span class="n">simpy</span><span class="o">.</span><span class="n">Interrupt</span><span class="p">:</span>
            <span class="err">…</span><span class="n">interrupt</span> <span class="n">handler</span><span class="err">…</span>
</code></pre></div>
<p>So now what?
As near as I can figure,
when a developer is interrupted,
it checks to see whether it&rsquo;s already doing re-work or not.
If it is,
it puts the task associated with the re-work interrupt in its re-work queue.
If not,
it puts the (new) task it&rsquo;s working on in the re-work queue
and switches tasks.
Hm,
that means the developer&rsquo;s queue has to be a priority queue
so that re-work takes precedence over new work.
And we need to keep track of time spent so far on each task.
And there&rsquo;s probably at least one corner case I haven&rsquo;t thought of yet,
because this is a concurrent system with interrupts
and there are <em>always</em> corner cases.</p>
<p>A few final thoughts:</p>
<ol>
<li>
<p>The title of this post is &ldquo;In Search of Sturdiness&rdquo;
    because I think that word best sums up what I&rsquo;m looking for.
    I don&rsquo;t care all that much if a solution is elegant or graceful or clever;
    I want something sturdy because I want to make more changes to the simulation
    and I don&rsquo;t want to have to come back and re-design this part.</p>
</li>
<li>
<p>AI tools aren&rsquo;t much help here,
    at least not the ones I&rsquo;ve tried.
    They&rsquo;re good at generating plausible answers,
    but this situation needs one that&rsquo;s right as well.</p>
</li>
<li>
<p>This is where I&rsquo;d like to make use of a tool like <a href="https://alloytools.org/">Alloy</a> or <a href="https://en.wikipedia.org/wiki/TLA%2B">TLA+</a>,
    but they aren&rsquo;t already part of my repertoire,
    and I don&rsquo;t have time for a three-month side quest to master one of them.</p>
</li>
<li>
<p>I&rsquo;ve tried to find an experienced SimPy user, without luck.
    If you are one,
    and are willing to offer some design advice,
    I&rsquo;d be very grateful if you would <a href="mailto:gvwilson@third-bit.com">reach out</a>.</p>
</li>
</ol>
</article>

<article class="post">
  <h2 class="post-title">
    <a href="../2025/11/30/observability/">
      Observability
    </a>
  </h2>
  <p><time datetime="2025-11-30" class="post-date">2025-11-30</time></p>
  <p>So far we&rsquo;ve been collecting whatever data we want
whenever something significant happens in the simulation,
but we can&rsquo;t do that in the real world.
Since we need to tidy up the simulation a bit,
let&rsquo;s  data collection a little more realistic as well.</p>
<h2>The Overall Simulation</h2>
<p>As before,
we&rsquo;re going to store the major pieces of the simulation in a <code>Simulation</code> object
so that we don&rsquo;t have to pass lots of bits and pieces to every function and method.
This class holds:</p>
<ul>
<li>the simulation parameters;</li>
<li>the <a href="https://simpy.readthedocs.io/">SimPy</a> <code>Environment</code>;</li>
<li>the developers (represented as <code>Developer</code> objects);</li>
<li>the queue of tasks waiting for a developer;</li>
<li>the testers (represeented as <code>Tester</code> objects) and the queue of tasks waiting for them;
    and</li>
<li>an instance of a new <code>Log</code> class that will collect data about the state of the simulation.</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Simulation</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Overall simulation.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span> <span class="o">=</span> <span class="n">simpy</span><span class="o">.</span><span class="n">Environment</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">developers</span> <span class="o">=</span> <span class="p">[</span><span class="n">Developer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;num_dev&quot;</span><span class="p">])]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dev_queue</span> <span class="o">=</span> <span class="n">simpy</span><span class="o">.</span><span class="n">PriorityStore</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">testers</span> <span class="o">=</span> <span class="p">[</span><span class="n">Tester</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;num_tester&quot;</span><span class="p">])]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">test_queue</span> <span class="o">=</span> <span class="n">simpy</span><span class="o">.</span><span class="n">PriorityStore</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">Log</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</code></pre></div>
<p>As before,
we provide some convenience methods to get at useful properties
of the underlying <code>Environment</code>:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Simulation</span><span class="p">:</span>
    <span class="err">…</span><span class="n">previous</span> <span class="n">code</span><span class="err">…</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">now</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Shortcut for current time.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">now</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proc</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Shortcut for running a process.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">proc</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">timeout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Shortcut for delaying a fixed time.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
</code></pre></div>
<p>and put all the randomization here as well:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Simulation</span><span class="p">:</span>
    <span class="err">…</span><span class="n">previous</span> <span class="n">code</span><span class="err">…</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">rand_task_arrival</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Task arrival time.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">random</span><span class="o">.</span><span class="n">expovariate</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;task_arrival&quot;</span><span class="p">])</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">rand_test_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Testing time.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">random</span><span class="o">.</span><span class="n">lognormvariate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;median_test_time&quot;</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">rand_rework</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Does this task need to be reworked?&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;prob_rework&quot;</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">rand_dev_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Development time.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">random</span><span class="o">.</span><span class="n">lognormvariate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;median_dev_time&quot;</span><span class="p">]</span>
</code></pre></div>
<p>Finally,
we provide one method to generate new tasks
and one to launch all the active processes in the simulation:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Simulation</span><span class="p">:</span>
    <span class="err">…</span><span class="n">previous</span> <span class="n">code</span><span class="err">…</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">generate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate tasks at random intervals starting at t=0.&quot;&quot;&quot;</span>

        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">dev_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">Task</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rand_task_arrival</span><span class="p">())</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">dev_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">Task</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Run the whole simulation.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">generate</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">work</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">workers</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">developers</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">testers</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">workers</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">work</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">until</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;sim_time&quot;</span><span class="p">])</span>
</code></pre></div>
<p>Two things to note in the code above:</p>
<ol>
<li>
<p>We always generate the first task at time 0.
    We don&rsquo;t have to do this,
    but it always felt weird looking at the statistics
    to have a small delay at the start before anything happened.</p>
</li>
<li>
<p>The logger is an active process,
    just like the developers, testers, and task generator.
    We&rsquo;ll look at it in more detail in a bit.</p>
</li>
</ol>
<h2>Developers</h2>
<p>Earlier posts in this series showed
how we give each developer (and tester) a unique ID
and how we automatically create lists of them.
We won&rsquo;t repeat that code here,
since the most interesting thing about a developer is the work she does:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Developer</span><span class="p">(</span><span class="n">Worker</span><span class="p">):</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">task</span> <span class="o">=</span> <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">dev_queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>

            <span class="k">with</span> <span class="n">WorkLog</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="p">(</span><span class="n">Worker</span><span class="o">.</span><span class="n">State</span><span class="o">.</span><span class="n">BUSY</span><span class="p">,</span> <span class="n">Worker</span><span class="o">.</span><span class="n">State</span><span class="o">.</span><span class="n">IDLE</span><span class="p">),</span>
                <span class="n">task</span><span class="p">,</span>
                <span class="p">(</span><span class="n">Task</span><span class="o">.</span><span class="n">State</span><span class="o">.</span><span class="n">DEV</span><span class="p">,</span> <span class="n">Task</span><span class="o">.</span><span class="n">State</span><span class="o">.</span><span class="n">WAIT_TEST</span><span class="p">),</span>
                <span class="s2">&quot;n_dev&quot;</span><span class="p">,</span>
                <span class="s2">&quot;t_dev&quot;</span><span class="p">,</span>
            <span class="p">):</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">required_dev</span><span class="p">)</span>

            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">test_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
</code></pre></div>
<p>If we ignore <code>WorkLog</code> for a moment,
we can see that <code>Developer.work</code> is:</p>
<div class="highlight"><pre><span></span><code>    <span class="k">def</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">task</span> <span class="o">=</span> <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">dev_queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">required_dev</span><span class="p">)</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">test_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
</code></pre></div>
<p>i.e.,
wait to a get a take from the development queue,
pause for a while to do the work,
and then put the task in the testing queue.</p>
<h2>Recording Work</h2>
<p>So what is <code>WorkLog</code>?
It&rsquo;s a <em>context manager</em>,
i.e.,
a class that does something at the start of a block
and then automatically does some cleanup at the end of the block.
In our case,
what it does at the start is record the start time of the work
and change the state flags of the worker and task:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">WorkLog</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Context manager to keep track of elapsed time.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">worker</span><span class="p">,</span> <span class="n">worker_states</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">task_states</span><span class="p">,</span> <span class="n">key_num</span><span class="p">,</span> <span class="n">key_time</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">worker</span> <span class="o">=</span> <span class="n">worker</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">worker_states</span> <span class="o">=</span> <span class="n">worker_states</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">task</span> <span class="o">=</span> <span class="n">task</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">task_states</span> <span class="o">=</span> <span class="n">task_states</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">key_num</span> <span class="o">=</span> <span class="n">key_num</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">key_time</span> <span class="o">=</span> <span class="n">key_time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Start the clock.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">worker</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">now</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">worker</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">worker_states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">task</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">task_states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div>
<p>At the end of the block—i.e.,
after the simulated work is done—the context manager
records how long the worker spent and how many tasks it has processed,
then changes the states of the task and worker again:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">WorkLog</span><span class="p">:</span>
    <span class="err">…</span><span class="n">previous</span> <span class="n">code</span><span class="err">…</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Stop the clock.&quot;&quot;&quot;</span>

        <span class="n">elapsed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">worker</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">now</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">worker</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">worker_states</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">worker</span><span class="p">[</span><span class="s2">&quot;busy&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">elapsed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">worker</span><span class="p">[</span><span class="s2">&quot;n_task&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">task_states</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">task</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">task_states</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">task</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">key_num</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">task</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">key_time</span><span class="p">]</span> <span class="o">+=</span> <span class="n">elapsed</span>

        <span class="k">return</span> <span class="kc">False</span>
</code></pre></div>
<p>Using <code>WorkLog</code> adds eight lines to what was a three-line simulation loop,
but we&rsquo;ve learned the hard way as this code evolves
that keeping the record keeping for developers and testers in sync is error-prone.
Putting that code in a class,
and ensuring that the end-of-work record keeping is always done,
speeds up development.</p>
<h2>Testers</h2>
<p>The <code>Tester</code> class is similar to the <code>Developer</code> class:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Tester</span><span class="p">(</span><span class="n">Worker</span><span class="p">):</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">task</span> <span class="o">=</span> <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">test_queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>

            <span class="k">with</span> <span class="n">WorkLog</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="p">(</span><span class="n">Worker</span><span class="o">.</span><span class="n">State</span><span class="o">.</span><span class="n">BUSY</span><span class="p">,</span> <span class="n">Worker</span><span class="o">.</span><span class="n">State</span><span class="o">.</span><span class="n">IDLE</span><span class="p">),</span>
                <span class="n">task</span><span class="p">,</span>
                <span class="p">(</span><span class="n">Task</span><span class="o">.</span><span class="n">State</span><span class="o">.</span><span class="n">TEST</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="s2">&quot;n_test&quot;</span><span class="p">,</span>
                <span class="s2">&quot;t_test&quot;</span><span class="p">,</span>
            <span class="p">):</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">required_test</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">rand_rework</span><span class="p">():</span>
                <span class="n">task</span><span class="o">.</span><span class="n">priority</span> <span class="o">=</span> <span class="n">Task</span><span class="o">.</span><span class="n">PRI_HIGH</span>
                <span class="n">task</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">Task</span><span class="o">.</span><span class="n">State</span><span class="o">.</span><span class="n">WAIT_DEV</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">dev_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">task</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">Task</span><span class="o">.</span><span class="n">State</span><span class="o">.</span><span class="n">COMPLETE</span>
</code></pre></div>
<p>This class gets work from the ready-to-test queue,
and then decides once the work is done
whether the task needs to be re-developed or not.
If it does,
it goes back into the ready-to-develop queue with high priority
to ensure that tasks needing rework are done before tasks that haven&rsquo;t been touched yet.
Without this rule,
far fewer tasks are completed,
and far more tasks are half-done at the simulation&rsquo;s end.</p>
<h2>Logging</h2>
<p>It&rsquo;s finally time to look at the <code>Log</code> class that records data.
Its constructor makes space to record snapshots of
the states of all the tasks in the system,
the lengths of all the queues,
and what the developers and testers are doing:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Log</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Keep a log of interesting things.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sim</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sim</span> <span class="o">=</span> <span class="n">sim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snapshot</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;tasks&quot;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="s2">&quot;queues&quot;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="s2">&quot;workers&quot;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="p">}</span>
</code></pre></div>
<p>The generator that does the active work is simplicity itself:
record the state of the simulation,
then wait a fixed interval
(which we will initially set to one clock tick):</p>
<div class="highlight"><pre><span></span><code>    <span class="k">def</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_record</span><span class="p">()</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;log_interval&quot;</span><span class="p">])</span>
</code></pre></div>
<p>The code to record the simulation state is a bit messy,
because it depends on the implementations of various classes,
but in brief it creates records for:</p>
<ol>
<li>
<p>the state of every task in the system;</p>
</li>
<li>
<p>the lengths of the two queues; and</p>
</li>
<li>
<p>the state of each developer and tester.</p>
</li>
</ol>
<div class="highlight"><pre><span></span><code>    <span class="k">def</span><span class="w"> </span><span class="nf">_record</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Record a log entry at a particular moment.&quot;&quot;&quot;</span>

        <span class="n">now</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">now</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">Labeled</span><span class="o">.</span><span class="n">_all</span><span class="p">[</span><span class="n">Task</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">snapshot</span><span class="p">[</span><span class="s2">&quot;tasks&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">{</span><span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">now</span><span class="p">,</span> <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="s2">&quot;state&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">state</span><span class="p">)}</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">queue</span> <span class="ow">in</span> <span class="p">((</span><span class="s2">&quot;dev&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">dev_queue</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;test&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">test_queue</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">snapshot</span><span class="p">[</span><span class="s2">&quot;queues&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">{</span><span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">now</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span> <span class="s2">&quot;length&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="o">.</span><span class="n">items</span><span class="p">)}</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">kind</span><span class="p">,</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="p">((</span><span class="s2">&quot;dev&quot;</span><span class="p">,</span> <span class="n">Developer</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;test&quot;</span><span class="p">,</span> <span class="n">Tester</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">Labeled</span><span class="o">.</span><span class="n">_all</span><span class="p">[</span><span class="bp">cls</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">snapshot</span><span class="p">[</span><span class="s2">&quot;workers&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">{</span><span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">now</span><span class="p">,</span> <span class="s2">&quot;kind&quot;</span><span class="p">:</span> <span class="n">kind</span><span class="p">,</span> <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">w</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="s2">&quot;state&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">state</span><span class="p">)}</span>
                <span class="p">)</span>
</code></pre></div>
<h2>What Have We Learned?</h2>
<p>The first thing we learned from this refactoring is that
roughly half the code is devoted to collecting data.
This won&rsquo;t come as a surprise to anyone who has ever built a monitoring tool:
figuring out what&rsquo;s going on is often as hard as making things happen,
and sometimes harder.</p>
<p>The second thing we&rsquo;ve learned is that our simulation can still surprise us.
The graph on the left shows the lengths of the develpment and testing queues over time,
while the one on the right shows how many tasks are in each of the possible states:</p>
<div class="row">
  <div class="col-6 center">
    <img src="../files/2025/11/30/sample_queues.svg" alt="queue lengths" width="90%">
    <br>
    Queue Lengths
  </div>
  <div class="col-6 center">
    <img src="../files/2025/11/30/sample_tasks.svg" alt="task states" width="90%">
    <br>
    Task States
  </div>
</div>

<p>The steady growth in the number of tasks waiting for a developer makes sense:
we&rsquo;re generating new ones faster than they can be completed.
But why does the length of the testing queue rise and then fall?
Is it just random variation?
Or is it revealing some unexpected property of our development process?
That question will have to wait for tomorrow.</p>
</article>

<article class="post">
  <h2 class="post-title">
    <a href="../2025/11/29/what-changed-revisited/">
      What Changed Revisited
    </a>
  </h2>
  <p><time datetime="2025-11-29" class="post-date">2025-11-29</time></p>
  <p>Let&rsquo;s take another look at the log-scaled version of [yesterday&rsquo;s chart][what-changed]:</p>
<div class="center">
  <img src="../files/2025/11/28/times-log.svg" alt="log-scale time plot" width="90%">
</div>

<p>There hasn&rsquo;t been any turnover in the team or a major rewrite of the product,
so why has the number of bugs that take more than 100 hours to close
been creeping up slowly but steadily?
Luckily,
we have access to the source code of the simulation,
so we can get a definitive answer.
(Yes, this is cheating…)</p>
<p>The first difference is that
the development and testing queues are priority queues:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Simulation</span><span class="p">:</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span> <span class="o">=</span> <span class="n">simpy</span><span class="o">.</span><span class="n">Environment</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dev_queue</span> <span class="o">=</span> <span class="n">simpy</span><span class="o">.</span><span class="n">PriorityStore</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">test_queue</span> <span class="o">=</span> <span class="n">simpy</span><span class="o">.</span><span class="n">PriorityStore</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">)</span>
</code></pre></div>
<p>We have also added constants to define two priority levels—remember,
a lower number is a higher priority:</p>
<div class="highlight"><pre><span></span><code><span class="n">PRI_REWORK</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">PRI_NEW</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div>
<p>We have also made a small but crucial change to
the class that simulates a tester:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Tester</span><span class="p">(</span><span class="n">Labeled</span><span class="p">):</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">item</span> <span class="o">=</span> <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">test_queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="n">priority</span><span class="p">,</span> <span class="n">task</span> <span class="o">=</span> <span class="n">item</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">task</span><span class="p">[</span><span class="s2">&quot;test_time&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">task_rework</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">dev_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">simpy</span><span class="o">.</span><span class="n">PriorityItem</span><span class="p">(</span><span class="n">PRI_REWORK</span><span class="p">,</span> <span class="n">task</span><span class="p">))</span>
</code></pre></div>
<p>The last two lines of <code>work</code> say,
&ldquo;If testing reveals that this task needs to be re-done,
put it back in the development queue with high priority.&rdquo;
If you&rsquo;ll excuse a bit more ASCII art,
this change means that our simulation is now:</p>
<div class="highlight"><pre><span></span><code>+----------------+    +-----------+    +------------+    +------------+    +---------+
| task generator | -&gt; | dev queue | -&gt; | developers | -&gt; | test queue | -&gt; | testers |
+----------------+    +-----------+    +------------+    +------------+    +---------+
                            ^                                                   |
                            |                                                   |
                            +---------------------------------------------------+
</code></pre></div>
<p>From quarter to quarter,
the probability of QA revealing that a task needs to be re-done
has gone from 0% to 50%.
As noted yesterday,
we see a corresponding decrease in the total number of tasks completed each quarter:</p>
<table>
<thead>
<tr>
<th style="text-align: right;">quarter</th>
<th style="text-align: right;">number</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: right;">1</td>
<td style="text-align: right;">2222</td>
</tr>
<tr>
<td style="text-align: right;">2</td>
<td style="text-align: right;">1912</td>
</tr>
<tr>
<td style="text-align: right;">3</td>
<td style="text-align: right;">1525</td>
</tr>
<tr>
<td style="text-align: right;">4</td>
<td style="text-align: right;">993</td>
</tr>
</tbody>
</table>
<p>What these numbers don&rsquo;t tell us is <em>why</em>.
Are our testers getting better at finding bugs?
Are our developers making more mistakes because they&rsquo;re burning out?
Or has there been some sort of change in how work is being tracked?
(0% rework in the first quarter seems suspicious…)
Once again,
data can draw our attention to things that need to be explained,
but we still have to find the explanation.</p>
</article>


    </main>
    <footer>
  &copy; 2004-2025 <a href="../about/">Greg Wilson</a>
  <a href="mailto:gvwilson@third-bit.com"><img src="../assets/icons/envelope.svg" alt="email" class="footer-icon"></a>
  <a href="https://www.linkedin.com/in/gvwilson/"><img src="../assets/icons/linkedin.svg" alt="LinkedIn" class="footer-icon"></a>
  <a href="https://mastodon.social/@gvwilson"><img src="../assets/icons/mastodon.svg" alt="Mastodon" class="footer-icon"></a>
  <a href="https://calendly.com/gvwilson/30min"><img src="../assets/icons/calendar.svg" alt="Calendly" class="footer-icon"></a>
  <a href="https://github.com/gvwilson"><img src="../assets/icons/github.svg" alt="GitHub" class="footer-icon"></a>
  <a href="https://www.youtube.com/channel/UCbDQ7FIeYB3FHRADAjUjfrg"><img src="../assets/icons/youtube.svg" alt="YouTube" class="footer-icon"></a>
  <a href="../bib/"><img src="../assets/icons/orcid.svg" alt="ORCID" class="footer-icon"></a>
  <a href="../atom.xml"><img src="../assets/icons/rss.svg" alt="RSS feed" class="footer-icon"></a>
  <a href="../license/"><img src="../assets/icons/cc-by.svg" alt="license" class="footer-icon"></a>
  <a href="../colophon/"><img src="../assets/icons/pencil.svg" alt="colophon" class="footer-icon"></a>
  <a href="../cv/"><img src="../assets/icons/file.svg" alt="CV" class="footer-icon"></a>
  <br>
  None of the material on this site may be used to train AI models without the express prior permission of the author.
</footer>
  </body>
</html>