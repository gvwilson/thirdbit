<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<link rel="me" href="https://mastodon.social/@gvwilson">
<link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
<link rel="alternate" type="application/atom+xml" title="The Third Bit" href="../atom.xml">
<!-- <script defer data-domain="third-bit.com" src="https://plausible.io/js/plausible.js"></script> -->
    <script src="https://kit.fontawesome.com/4eee35f757.js"></script>
    <link rel="stylesheet" href="../assets/thirdbit.css">
    <link rel="stylesheet" href="../assets/page.css">
    
<title>The Third Bit Blog</title>

    
  </head>
  <body>
    <nav>
  <div class="row underline">
    <div class="col-2 left">
      <a class="navlink" href="../">Home</a>
    </div>
    <div class="col-10 right">
      <a class="navlink" href="../about/">about</a>
      <a class="navlink" href="../blog/">blog</a>
      <a class="navlink" href="../selected/">selected</a>
      <a class="navlink" href="../talks/">talks</a>
      <a class="navlink" href="../bib/">bibliography</a>
      <a class="navlink" href="../fiction/">fiction</a>
    </div>
  </div>
</nav>
    <main>
      
<h1>Blog</h1>


<table class="centered">
  <tbody>
    <tr>
      <td><a href="../archive/2020">2020</a></td>
      <td><a href="../archive/2021">2021</a></td>
      <td><a href="../archive/2022">2022</a></td>
      <td><a href="../archive/2023">2023</a></td>
      <td><a href="../archive/2024">2024</a></td>
      <td><a href="../archive/2025">2025</a></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td><a href="../archive/2010">2010</a></td>
      <td><a href="../archive/2011">2011</a></td>
      <td><a href="../archive/2012">2012</a></td>
      <td><a href="../archive/2013">2013</a></td>
      <td><a href="../archive/2014">2014</a></td>
      <td><a href="../archive/2015">2015</a></td>
      <td><a href="../archive/2016">2016</a></td>
      <td><a href="../archive/2017">2017</a></td>
      <td><a href="../archive/2018">2018</a></td>
      <td><a href="../archive/2019">2019</a></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td><a href="../archive/2004">2004</a></td>
      <td><a href="../archive/2005">2005</a></td>
      <td><a href="../archive/2006">2006</a></td>
      <td><a href="../archive/2007">2007</a></td>
      <td><a href="../archive/2008">2008</a></td>
      <td><a href="../archive/2009">2009</a></td>
    </tr>
  </tbody>
</table>


<article class="post">
  <h2 class="post-title">
    <a href="../2025/12/06/remembrance/">
      Remembrance
    </a>
  </h2>
  <p><time datetime="2025-12-06" class="post-date">2025-12-06</time></p>
  <p>Jamais plus.</p>
<div class="center">
  <img src="../files/dec-6.png" alt="victims of the Dec 6 massacre" width="90%>
</div>

<div class="center">
  <img src="../files/dec-6-plaque.png" alt="plaque for victims the Dec 6 massacre" width="90%>
</div>
</article>

<article class="post">
  <h2 class="post-title">
    <a href="../2025/12/04/the-effects-of-rework/">
      The Effects of Rework
    </a>
  </h2>
  <p><time datetime="2025-12-04" class="post-date">2025-12-04</time></p>
  <p>Having <a href="../2025/12/03/you-have-to-cancel/">solved yesterday&rsquo;s bug</a>,
we can get back to looking at the effect of re-work on throughput.
As a reminder,
our workflow looks like this:</p>
<div class="highlight"><pre><span></span><code>+----------------+    +-----------+    +------------+    +------------+    +---------+
| task generator | -&gt; | dev queue | -&gt; | developers | -&gt; | test queue | -&gt; | testers |
+----------------+    +-----------+    +------------+    +------------+    +---------+
                            ^                                                   |
                            |                                                   |
                            +---------------------------------------------------+
</code></pre></div>
<p>The two parameters that affect re-work are <code>p_rework_needed</code>,
which is the probability that a tester is going to send a task back for more work,
and <code>p_rework_chosen</code>,
which is the probability that a developer will choose something from her re-work queue
rather than starting fresh work
when both are available.
The extreme cases are:</p>
<ul>
<li><code>p_rework_needed</code> = 0.0, meaning no tasks are ever sent back.</li>
<li><code>p_rework_needed</code> = 1.0, meaning every task is always sent back.
    (Note that this means no task will ever be finished:
    instead,
    tasks will circulate endlesslesly between development and testing,
    and yes,
    sometimes it does feel like that happens in real life.)</li>
<li><code>p_rework_chosen</code> = 0.0, in which case
    developers only re-do tasks when there is no new work queued up.
    (We know from previous simulations that there are almost always
    new tasks waiting to be started.)</li>
<li><code>p_rework_chosen</code> = 1.0, in which case
    developers only start new tasks when nothing needs to be re-done.</li>
</ul>
<p>Finally,
this version of the simulation always sends tasks back to
the developers who originally worked on them
rather than allowing the first available developer
to re-do someone else&rsquo;s work.</p>
<h2>Final States</h2>
<p>The figure below shows the number of tasks in each of the five possible states
at the end of the simulation
as a function of <code>p_rework_needed</code> and <code>p_rework_chosen</code>:</p>
<div class="center">
  <img src="../files/2025/12/04/states.svg" alt="final task states" width="90%">
</div>

<p>As expected,
lots of tasks are in the <code>complete</code> state when there is never any need for re-work,
while none are when re-work is always needed.
This finding may seem obvious,
but this simple check uncovered a couple of bugs in the simulation.</p>
<p>A more interesting finding is that
how developers choose tasks doesn&rsquo;t seem to have much effect
on how many they get done:
while there is some variation,
the bars stay more or less the same height when we look at each row.</p>
<p>We can reach the same conclusion by looking at
the number of times tasks were developed and re-worked.
The sizes of the circles in the plots below reflect these counts:</p>
<div class="row">
  <div class="col-6 center">
    <img src="../files/2025/12/04/n_dev.svg" alt="development count" width="90%">
  </div>
  <div class="col-6 center">
    <img src="../files/2025/12/04/n_rework.svg" alt="re-work count" width="90%">
  </div>
</div>

<p>Again,
the probability of needing re-work has an obvious impact,
while the probability of choosing new work vs. re-work doesn&rsquo;t seem to.</p>
</article>

<article class="post">
  <h2 class="post-title">
    <a href="../2025/12/03/you-have-to-cancel/">
      You Have to Cancel
    </a>
  </h2>
  <p><time datetime="2025-12-03" class="post-date">2025-12-03</time></p>
  <p>It has taken me almost three hours to answer <a href="../2025/12/03/in-search-of-sturdiness/">my earlier question</a> about <a href="https://simpy.readthedocs.io/">SimPy</a>,
and once I recover,
I&rsquo;m going to submit a couple of PRs for their documentation.
To recap,
the most recent version of the simulation
all testers to bounce work back to the development queue if they find bugs:</p>
<div class="highlight"><pre><span></span><code>+----------------+    +-----------+    +------------+    +------------+    +---------+
| task generator | -&gt; | dev queue | -&gt; | developers | -&gt; | test queue | -&gt; | testers |
+----------------+    +-----------+    +------------+    +------------+    +---------+
                            ^                                                   |
                            |                                                   |
                            +---------------------------------------------------+
</code></pre></div>
<p>I&rsquo;m going to walk through the code I wrote,
the problem I had,
and the solution I (think I&rsquo;ve) found step by step.
If there&rsquo;s a simpler way,
or if this <em>is</em> documentation clearly somewhere,
please <a href="mailto:gvwilson@third-bit.com">let me know</a>.</p>
<h2>Tasks</h2>
<p>A <code>Task</code> has a unique ID and keeps track of how many times it has been worked on:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Task</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ident</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ident</span> <span class="o">=</span> <span class="n">ident</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;task-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ident</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="si">}</span><span class="s2">&quot;</span>
</code></pre></div>
<h2>The Overall Simulation</h2>
<p>Since I don&rsquo;t want to have to pass a whole bunch of parameters around,
<code>Simulation</code> stores the SimPy <code>Environment</code>,
our single developer,
our single tester,
and the three queues:
one for new tasks,
one for tasks that need to be reworked,
and one for tasks that are ready for testing:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Simulation</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Environment.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span> <span class="o">=</span> <span class="n">simpy</span><span class="o">.</span><span class="n">Environment</span><span class="p">()</span>

        <span class="c1"># One developer and one tester.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">developer</span> <span class="o">=</span> <span class="n">Developer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tester</span> <span class="o">=</span> <span class="n">Tester</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Queues for new development work, rework, and testing.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_dev</span> <span class="o">=</span> <span class="n">simpy</span><span class="o">.</span><span class="n">Store</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_rework</span> <span class="o">=</span> <span class="n">simpy</span><span class="o">.</span><span class="n">Store</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_test</span> <span class="o">=</span> <span class="n">simpy</span><span class="o">.</span><span class="n">Store</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">)</span>
</code></pre></div>
<p><code>Simulation</code> also defines the generator that creates new tasks
and puts them in the ready-to-develop queue:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Simulation</span><span class="p">:</span>
    <span class="err">…</span><span class="n">previous</span> <span class="n">code</span><span class="err">…</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">generate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">task</span> <span class="o">=</span> <span class="n">Task</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">now</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> create </span><span class="si">{</span><span class="n">task</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_dev</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">T_GEN</span><span class="p">)</span>
</code></pre></div>
<p>Finally,
<code>Simulation</code> defines a convenience method that runs everything:</p>
<div class="highlight"><pre><span></span><code>    <span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">generate</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">developer</span><span class="o">.</span><span class="n">work</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tester</span><span class="o">.</span><span class="n">work</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">until</span><span class="o">=</span><span class="n">T_SIM</span><span class="p">)</span>
</code></pre></div>
<p>For testing,
the parameters are:</p>
<div class="highlight"><pre><span></span><code><span class="n">N_TASK</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># number of tasks to create</span>
<span class="n">T_GEN</span> <span class="o">=</span> <span class="mi">1</span>   <span class="c1"># time between tasks</span>
<span class="n">T_DEV</span> <span class="o">=</span> <span class="mi">1</span>   <span class="c1"># time to do development</span>
<span class="n">T_TEST</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># time to do testing</span>
<span class="n">T_SIM</span> <span class="o">=</span> <span class="mi">4</span>   <span class="c1"># how long to run the whole simulation</span>
</code></pre></div>
<h2>Workers</h2>
<p>A generic <code>Worker</code> (either a developer or a tester)
caches the object that holds the overall simulation
and provides a couple of convenience methods for getting the current time
and for printing itself:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Worker</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sim</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sim</span> <span class="o">=</span> <span class="n">sim</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">now</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">now</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">now</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span>
</code></pre></div>
<h2>Testers</h2>
<p>The tester gets a task from the testing queue,
waits a tick to simulate work,
increments the task&rsquo;s internal count of how many times it has gone around the loop,
and then puts it in the rework queue:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Tester</span><span class="p">(</span><span class="n">Worker</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># Get a task from the testing queue.</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">: wait for task(s)&quot;</span><span class="p">)</span>
            <span class="n">task</span> <span class="o">=</span> <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">q_test</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">: got </span><span class="si">{</span><span class="n">task</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Do testing.</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">T_TEST</span><span class="p">)</span>
            <span class="n">task</span><span class="o">.</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># Always put the task in the rework queue.</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">q_rework</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">: put </span><span class="si">{</span><span class="n">task</span><span class="si">}</span><span class="s2"> in rework queue&quot;</span><span class="p">)</span>
</code></pre></div>
<h2>Developers (the wrong version)</h2>
<p><strong>This code is wrong, but will be fixed below.</strong></p>
<p>My original <code>Developer</code> waited until a task was available in <em>either</em>
the development queue or the rework queue,
then selected one of those tasks (giving priority to rework),
waited a tick to simulate work,
and put the task in the testing queue:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">DeveloperWrong</span><span class="p">(</span><span class="n">Worker</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># Get either a task for development or a task for rework.</span>
            <span class="n">req_dev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">q_dev</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="n">req_rework</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">q_rework</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">: wait for task(s)&quot;</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">simpy</span><span class="o">.</span><span class="n">AnyOf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">env</span><span class="p">,</span> <span class="p">[</span><span class="n">req_dev</span><span class="p">,</span> <span class="n">req_rework</span><span class="p">])</span>

            <span class="c1"># Give priority to rework.</span>
            <span class="k">if</span> <span class="n">req_rework</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
                <span class="n">task</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">req_rework</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> got </span><span class="si">{</span><span class="n">task</span><span class="si">}</span><span class="s2"> from rework with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">events</span><span class="p">)</span><span class="si">}</span><span class="s2"> events&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">req_dev</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
                <span class="n">task</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">req_dev</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> got </span><span class="si">{</span><span class="n">task</span><span class="si">}</span><span class="s2"> from dev with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">events</span><span class="p">)</span><span class="si">}</span><span class="s2"> events&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;how did we get here?&quot;</span>

            <span class="c1"># Do development.</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">T_DEV</span><span class="p">)</span>

            <span class="c1"># Put the task in the testing queue.</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">q_test</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">: put </span><span class="si">{</span><span class="n">task</span><span class="si">}</span><span class="s2"> in testing queue&quot;</span><span class="p">)</span>
</code></pre></div>
<p>According to the documentation,
<code>simpy.AnyOf</code> creates an object that means &ldquo;give me any of the following&rdquo;.
Its result is a dictionary-like object
whose keys are the requests
and whose values are items from one or more of the queues being waited on:
&ldquo;or more&rdquo; because it&rsquo;s possible for items to be available in multiple queues simultaneously.</p>
<h2>Output from the Buggy Version</h2>
<p>Here&rsquo;s the output using the <code>DeveloperWrong</code> class shown above:</p>
<div class="highlight"><pre><span></span><code>0.00 create task-0/0
DeveloperWrong/0.00: wait for task(s)
Tester/0.00: wait for task(s)
DeveloperWrong/0.00 got task-0/0 from dev with 1 events
1.00 create task-1/0
DeveloperWrong/1.00: put task-0/0 in testing queue
DeveloperWrong/1.00: wait for task(s)
Tester/1.00: got task-0/0
DeveloperWrong/1.00 got task-1/0 from dev with 1 events
2.00 create task-2/0
Tester/2.00: put task-0/1 in rework queue
Tester/2.00: wait for task(s)
DeveloperWrong/2.00: put task-1/0 in testing queue
DeveloperWrong/2.00: wait for task(s)
Tester/2.00: got task-1/0
DeveloperWrong/2.00 got task-2/0 from dev with 1 events
3.00 create task-3/0
Tester/3.00: put task-1/1 in rework queue
Tester/3.00: wait for task(s)
DeveloperWrong/3.00: put task-2/0 in testing queue
DeveloperWrong/3.00: wait for task(s)
Tester/3.00: got task-2/0
DeveloperWrong/3.00 got task-3/0 from dev with 1 events
</code></pre></div>
<p>A lot is going on in those 23 lines,
so let&rsquo;s look at what the developer got from where:</p>
<div class="highlight"><pre><span></span><code>DeveloperWrong/0.00 got task-0/0 from dev with 1 events
DeveloperWrong/1.00 got task-1/0 from dev with 1 events
DeveloperWrong/2.00 got task-2/0 from dev with 1 events
DeveloperWrong/3.00 got task-3/0 from dev with 1 events
</code></pre></div>
<p>Hm:
the developer is never taking tasks from the rework queue.
Is the tester putting them in?</p>
<div class="highlight"><pre><span></span><code>Tester/0.00: wait for task(s)
Tester/1.00: got task-0/0
Tester/2.00: put task-0/1 in rework queue
Tester/2.00: wait for task(s)
Tester/2.00: got task-1/0
Tester/3.00: put task-1/1 in rework queue
Tester/3.00: wait for task(s)
Tester/3.00: got task-2/0
</code></pre></div>
<p>So what&rsquo;s going on?</p>
<h2>A Corrected Developer</h2>
<p>Here&rsquo;s the skeleton of the corrected developer&rsquo;s <code>work</code> method:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">DeveloperRight</span><span class="p">(</span><span class="n">Worker</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">which</span> <span class="o">=</span> <span class="s2">&quot;dev&quot;</span>
        <span class="n">take</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># Get either a task for development or a task for rework.</span>
            <span class="n">req_dev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">q_dev</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="n">req_rework</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">q_rework</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">: wait for task(s)&quot;</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">simpy</span><span class="o">.</span><span class="n">AnyOf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">env</span><span class="p">,</span> <span class="p">[</span><span class="n">req_dev</span><span class="p">,</span> <span class="n">req_rework</span><span class="p">])</span>

            <span class="err">…</span><span class="n">magic</span> <span class="n">happens</span> <span class="n">here</span><span class="err">…</span>

            <span class="c1"># Do development.</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">T_DEV</span><span class="p">)</span>

            <span class="c1"># Put the task in the testing queue.</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">q_test</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">: put </span><span class="si">{</span><span class="n">task</span><span class="si">}</span><span class="s2"> in testing queue&quot;</span><span class="p">)</span>
</code></pre></div>
<p>The bit of magic in the middle is that as far as I can tell,
all of the requests that <em>weren&rsquo;t</em> selected have to be canceled,
even if there wasn&rsquo;t something in the queue at the time for the developer to take.
For example,
the first time the developer gets a task from the development queue,
the rework queue is guaranteed to be empty,
but we still have to cancel the request for something from it.</p>
<p>In order to demonstrate this,
I&rsquo;ve filled in the magic portion of <code>work</code> with code that alternates between
taking work from the development queue (if available)
and taking work from the rework queue (ditto).
Of course,
if there is only one event in the result from <code>AnyOf</code>,
the code uses that,
but <em>still cancels the other request</em>:</p>
<div class="highlight"><pre><span></span><code>    <span class="k">def</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">which</span> <span class="o">=</span> <span class="s2">&quot;dev&quot;</span>
        <span class="n">take</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="err">…</span><span class="n">get</span> <span class="n">either</span> <span class="n">a</span> <span class="n">task</span> <span class="k">for</span> <span class="n">development</span> <span class="ow">or</span> <span class="n">a</span> <span class="n">task</span> <span class="k">for</span> <span class="n">rework</span><span class="err">…</span>

            <span class="c1"># Pick one.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">events</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">: ...got two events&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">which</span> <span class="o">==</span> <span class="s2">&quot;dev&quot;</span><span class="p">:</span>
                    <span class="n">take</span> <span class="o">=</span> <span class="s2">&quot;dev&quot;</span>
                    <span class="n">which</span> <span class="o">=</span> <span class="s2">&quot;rework&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">take</span> <span class="o">=</span> <span class="s2">&quot;rework&quot;</span>
                    <span class="n">which</span> <span class="o">=</span> <span class="s2">&quot;dev&quot;</span>
            <span class="k">elif</span> <span class="n">req_dev</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">events</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">: ...got dev&quot;</span><span class="p">)</span>
                <span class="n">take</span> <span class="o">=</span> <span class="s2">&quot;dev&quot;</span>
            <span class="k">elif</span> <span class="n">req_rework</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">events</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">: ...got rework&quot;</span><span class="p">)</span>
                <span class="n">take</span> <span class="o">=</span> <span class="s2">&quot;rework&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;how did we get here?&quot;</span>

            <span class="c1"># Now take it.</span>
            <span class="k">if</span> <span class="n">take</span> <span class="o">==</span> <span class="s2">&quot;dev&quot;</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">: ...taking dev&quot;</span><span class="p">)</span>
                <span class="n">task</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">req_dev</span><span class="p">]</span>
                <span class="n">req_rework</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">take</span> <span class="o">==</span> <span class="s2">&quot;rework&quot;</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">: ...taking rework&quot;</span><span class="p">)</span>
                <span class="n">task</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">req_rework</span><span class="p">]</span>
                <span class="n">req_dev</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;how did we get here?&quot;</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> got </span><span class="si">{</span><span class="n">task</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="err">…</span><span class="n">do</span> <span class="n">development</span> <span class="ow">and</span> <span class="n">put</span> <span class="n">the</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">testing</span> <span class="n">queue</span><span class="err">…</span>
</code></pre></div>
<p>Here are the relevant bits of output when the simulation is run for 10 ticks instead of just 4:</p>
<div class="highlight"><pre><span></span><code>DeveloperRight/0.00: ...taking dev
DeveloperRight/1.00: ...taking dev
DeveloperRight/2.00: ...taking dev
DeveloperRight/3.00: ...taking rework
DeveloperRight/4.00: ...taking dev
DeveloperRight/5.00: ...taking rework
DeveloperRight/6.00: ...taking dev
DeveloperRight/7.00: ...taking rework
DeveloperRight/8.00: ...taking dev
DeveloperRight/9.00: ...taking rework
</code></pre></div>
<p>As I said at the outset,
I&rsquo;m going to submit some PRs for SimPy&rsquo;s documentation
to shout loudly and clearly that outstanding requests need to be canceled
(or possibly recycled: I haven&rsquo;t tried that yet).
Meanwhile,
I can now get back to playing with the impact of rework fractions on throughput.</p>
</article>

<article class="post">
  <h2 class="post-title">
    <a href="../2025/12/03/in-search-of-sturdiness/">
      In Search of Sturdiness
    </a>
  </h2>
  <p><time datetime="2025-12-03" class="post-date">2025-12-03</time></p>
  <p>I took a break from this series of posts for a couple of days
to focus on <a href="../2025/11/21/looking-for-work/">looking for a new role</a>
and because I&rsquo;ve hit a bit of a roadblock.
In the most recent version of the simulation,
testers can bounce work back to the development queue if they find bugs:</p>
<div class="highlight"><pre><span></span><code>+----------------+    +-----------+    +------------+    +------------+    +---------+
| task generator | -&gt; | dev queue | -&gt; | developers | -&gt; | test queue | -&gt; | testers |
+----------------+    +-----------+    +------------+    +------------+    +---------+
                            ^                                                   |
                            |                                                   |
                            +---------------------------------------------------+
</code></pre></div>
<p>Tasks that have been sent back for more work always have higher priority than new tasks,
but that&rsquo;s not realistic.
What I&rsquo;d like to model is a system in which re-work is done by
the same developer who did the initial work.
I can do this by creating a re-work queue for each developer,
and use <a href="https://simpy.readthedocs.io/">SimPy</a>&rsquo;s <code>AnyOf</code> operator to select from either queue:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Developer</span><span class="p">(</span><span class="n">Worker</span><span class="p">):</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">rework_get</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rework_queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="n">new_get</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">dev_queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="n">result</span> <span class="o">=</span> <span class="k">yield</span><span class="p">(</span><span class="n">simpy</span><span class="o">.</span><span class="n">AnyOf</span><span class="p">(</span><span class="n">rework_get</span><span class="p">,</span> <span class="n">new_get</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">rework_get</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">events</span><span class="p">:</span>
                <span class="n">task</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">rework_get</span><span class="p">]</span>
                <span class="n">new_get</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">task</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">new_get</span><span class="p">]</span>
</code></pre></div>
<p>Notice that the &ldquo;get&rdquo; request for the new-work queue is canceled
when there&rsquo;s re-work to be done.
Doing this takes care of the case in which items were available in <em>both</em> queues
(which turns out to be very common);
I found by trial and error that canceling a &ldquo;get&rdquo; request has no effect
if the request is still pending,
which simplifies the logic a little bit.</p>
<p>So here&rsquo;s my problem:
when there is re-work to be done <em>and</em> the developer is working on a new task,
I&rsquo;d like to interrupt the developer and have them do re-work,
then resume their previous task;
in other words,
I&rsquo;d like re-work to take <em>immediate</em> precedence over new work.
However,
if the developer is already doing re-work,
I don&rsquo;t want to interrupt them.</p>
<p>SimPy supports interrupts:
if you have a process <code>p</code>, you can call <code>p.interrupt()</code> to throw an exception into it.
The process can catch this and do whatever it wants:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">p</span><span class="p">():</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="err">…</span><span class="n">normal</span> <span class="n">operation</span><span class="err">…</span>
        <span class="k">except</span> <span class="n">simpy</span><span class="o">.</span><span class="n">Interrupt</span><span class="p">:</span>
            <span class="err">…</span><span class="n">interrupt</span> <span class="n">handler</span><span class="err">…</span>
</code></pre></div>
<p>So now what?
As near as I can figure,
when a developer is interrupted,
it checks to see whether it&rsquo;s already doing re-work or not.
If it is,
it puts the task associated with the re-work interrupt in its re-work queue.
If not,
it puts the (new) task it&rsquo;s working on in the re-work queue
and switches tasks.
Hm,
that means the developer&rsquo;s queue has to be a priority queue
so that re-work takes precedence over new work.
And we need to keep track of time spent so far on each task.
And there&rsquo;s probably at least one corner case I haven&rsquo;t thought of yet,
because this is a concurrent system with interrupts
and there are <em>always</em> corner cases.</p>
<p>A few final thoughts:</p>
<ol>
<li>
<p>The title of this post is &ldquo;In Search of Sturdiness&rdquo;
    because I think that word best sums up what I&rsquo;m looking for.
    I don&rsquo;t care all that much if a solution is elegant or graceful or clever;
    I want something sturdy because I want to make more changes to the simulation
    and I don&rsquo;t want to have to come back and re-design this part.</p>
</li>
<li>
<p>AI tools aren&rsquo;t much help here,
    at least not the ones I&rsquo;ve tried.
    They&rsquo;re good at generating plausible answers,
    but this situation needs one that&rsquo;s right as well.</p>
</li>
<li>
<p>This is where I&rsquo;d like to make use of a tool like <a href="https://alloytools.org/">Alloy</a> or <a href="https://en.wikipedia.org/wiki/TLA%2B">TLA+</a>,
    but they aren&rsquo;t already part of my repertoire,
    and I don&rsquo;t have time for a three-month side quest to master one of them.</p>
</li>
<li>
<p>I&rsquo;ve tried to find an experienced SimPy user, without luck.
    If you are one,
    and are willing to offer some design advice,
    I&rsquo;d be very grateful if you would <a href="mailto:gvwilson@third-bit.com">reach out</a>.</p>
</li>
</ol>
</article>

<article class="post">
  <h2 class="post-title">
    <a href="../2025/11/30/observability/">
      Observability
    </a>
  </h2>
  <p><time datetime="2025-11-30" class="post-date">2025-11-30</time></p>
  <p>So far we&rsquo;ve been collecting whatever data we want
whenever something significant happens in the simulation,
but we can&rsquo;t do that in the real world.
Since we need to tidy up the simulation a bit,
let&rsquo;s  data collection a little more realistic as well.</p>
<h2>The Overall Simulation</h2>
<p>As before,
we&rsquo;re going to store the major pieces of the simulation in a <code>Simulation</code> object
so that we don&rsquo;t have to pass lots of bits and pieces to every function and method.
This class holds:</p>
<ul>
<li>the simulation parameters;</li>
<li>the <a href="https://simpy.readthedocs.io/">SimPy</a> <code>Environment</code>;</li>
<li>the developers (represented as <code>Developer</code> objects);</li>
<li>the queue of tasks waiting for a developer;</li>
<li>the testers (represeented as <code>Tester</code> objects) and the queue of tasks waiting for them;
    and</li>
<li>an instance of a new <code>Log</code> class that will collect data about the state of the simulation.</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Simulation</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Overall simulation.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span> <span class="o">=</span> <span class="n">simpy</span><span class="o">.</span><span class="n">Environment</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">developers</span> <span class="o">=</span> <span class="p">[</span><span class="n">Developer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;num_dev&quot;</span><span class="p">])]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dev_queue</span> <span class="o">=</span> <span class="n">simpy</span><span class="o">.</span><span class="n">PriorityStore</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">testers</span> <span class="o">=</span> <span class="p">[</span><span class="n">Tester</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;num_tester&quot;</span><span class="p">])]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">test_queue</span> <span class="o">=</span> <span class="n">simpy</span><span class="o">.</span><span class="n">PriorityStore</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">Log</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</code></pre></div>
<p>As before,
we provide some convenience methods to get at useful properties
of the underlying <code>Environment</code>:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Simulation</span><span class="p">:</span>
    <span class="err">…</span><span class="n">previous</span> <span class="n">code</span><span class="err">…</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">now</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Shortcut for current time.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">now</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proc</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Shortcut for running a process.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">proc</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">timeout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Shortcut for delaying a fixed time.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
</code></pre></div>
<p>and put all the randomization here as well:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Simulation</span><span class="p">:</span>
    <span class="err">…</span><span class="n">previous</span> <span class="n">code</span><span class="err">…</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">rand_task_arrival</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Task arrival time.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">random</span><span class="o">.</span><span class="n">expovariate</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;task_arrival&quot;</span><span class="p">])</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">rand_test_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Testing time.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">random</span><span class="o">.</span><span class="n">lognormvariate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;median_test_time&quot;</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">rand_rework</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Does this task need to be reworked?&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;prob_rework&quot;</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">rand_dev_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Development time.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">random</span><span class="o">.</span><span class="n">lognormvariate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;median_dev_time&quot;</span><span class="p">]</span>
</code></pre></div>
<p>Finally,
we provide one method to generate new tasks
and one to launch all the active processes in the simulation:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Simulation</span><span class="p">:</span>
    <span class="err">…</span><span class="n">previous</span> <span class="n">code</span><span class="err">…</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">generate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate tasks at random intervals starting at t=0.&quot;&quot;&quot;</span>

        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">dev_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">Task</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rand_task_arrival</span><span class="p">())</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">dev_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">Task</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Run the whole simulation.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">generate</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">work</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">workers</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">developers</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">testers</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">workers</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">work</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">until</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;sim_time&quot;</span><span class="p">])</span>
</code></pre></div>
<p>Two things to note in the code above:</p>
<ol>
<li>
<p>We always generate the first task at time 0.
    We don&rsquo;t have to do this,
    but it always felt weird looking at the statistics
    to have a small delay at the start before anything happened.</p>
</li>
<li>
<p>The logger is an active process,
    just like the developers, testers, and task generator.
    We&rsquo;ll look at it in more detail in a bit.</p>
</li>
</ol>
<h2>Developers</h2>
<p>Earlier posts in this series showed
how we give each developer (and tester) a unique ID
and how we automatically create lists of them.
We won&rsquo;t repeat that code here,
since the most interesting thing about a developer is the work she does:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Developer</span><span class="p">(</span><span class="n">Worker</span><span class="p">):</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">task</span> <span class="o">=</span> <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">dev_queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>

            <span class="k">with</span> <span class="n">WorkLog</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="p">(</span><span class="n">Worker</span><span class="o">.</span><span class="n">State</span><span class="o">.</span><span class="n">BUSY</span><span class="p">,</span> <span class="n">Worker</span><span class="o">.</span><span class="n">State</span><span class="o">.</span><span class="n">IDLE</span><span class="p">),</span>
                <span class="n">task</span><span class="p">,</span>
                <span class="p">(</span><span class="n">Task</span><span class="o">.</span><span class="n">State</span><span class="o">.</span><span class="n">DEV</span><span class="p">,</span> <span class="n">Task</span><span class="o">.</span><span class="n">State</span><span class="o">.</span><span class="n">WAIT_TEST</span><span class="p">),</span>
                <span class="s2">&quot;n_dev&quot;</span><span class="p">,</span>
                <span class="s2">&quot;t_dev&quot;</span><span class="p">,</span>
            <span class="p">):</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">required_dev</span><span class="p">)</span>

            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">test_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
</code></pre></div>
<p>If we ignore <code>WorkLog</code> for a moment,
we can see that <code>Developer.work</code> is:</p>
<div class="highlight"><pre><span></span><code>    <span class="k">def</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">task</span> <span class="o">=</span> <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">dev_queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">required_dev</span><span class="p">)</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">test_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
</code></pre></div>
<p>i.e.,
wait to a get a take from the development queue,
pause for a while to do the work,
and then put the task in the testing queue.</p>
<h2>Recording Work</h2>
<p>So what is <code>WorkLog</code>?
It&rsquo;s a <em>context manager</em>,
i.e.,
a class that does something at the start of a block
and then automatically does some cleanup at the end of the block.
In our case,
what it does at the start is record the start time of the work
and change the state flags of the worker and task:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">WorkLog</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Context manager to keep track of elapsed time.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">worker</span><span class="p">,</span> <span class="n">worker_states</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">task_states</span><span class="p">,</span> <span class="n">key_num</span><span class="p">,</span> <span class="n">key_time</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">worker</span> <span class="o">=</span> <span class="n">worker</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">worker_states</span> <span class="o">=</span> <span class="n">worker_states</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">task</span> <span class="o">=</span> <span class="n">task</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">task_states</span> <span class="o">=</span> <span class="n">task_states</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">key_num</span> <span class="o">=</span> <span class="n">key_num</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">key_time</span> <span class="o">=</span> <span class="n">key_time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Start the clock.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">worker</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">now</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">worker</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">worker_states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">task</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">task_states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div>
<p>At the end of the block—i.e.,
after the simulated work is done—the context manager
records how long the worker spent and how many tasks it has processed,
then changes the states of the task and worker again:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">WorkLog</span><span class="p">:</span>
    <span class="err">…</span><span class="n">previous</span> <span class="n">code</span><span class="err">…</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Stop the clock.&quot;&quot;&quot;</span>

        <span class="n">elapsed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">worker</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">now</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">worker</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">worker_states</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">worker</span><span class="p">[</span><span class="s2">&quot;busy&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">elapsed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">worker</span><span class="p">[</span><span class="s2">&quot;n_task&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">task_states</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">task</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">task_states</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">task</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">key_num</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">task</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">key_time</span><span class="p">]</span> <span class="o">+=</span> <span class="n">elapsed</span>

        <span class="k">return</span> <span class="kc">False</span>
</code></pre></div>
<p>Using <code>WorkLog</code> adds eight lines to what was a three-line simulation loop,
but we&rsquo;ve learned the hard way as this code evolves
that keeping the record keeping for developers and testers in sync is error-prone.
Putting that code in a class,
and ensuring that the end-of-work record keeping is always done,
speeds up development.</p>
<h2>Testers</h2>
<p>The <code>Tester</code> class is similar to the <code>Developer</code> class:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Tester</span><span class="p">(</span><span class="n">Worker</span><span class="p">):</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">task</span> <span class="o">=</span> <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">test_queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>

            <span class="k">with</span> <span class="n">WorkLog</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="p">(</span><span class="n">Worker</span><span class="o">.</span><span class="n">State</span><span class="o">.</span><span class="n">BUSY</span><span class="p">,</span> <span class="n">Worker</span><span class="o">.</span><span class="n">State</span><span class="o">.</span><span class="n">IDLE</span><span class="p">),</span>
                <span class="n">task</span><span class="p">,</span>
                <span class="p">(</span><span class="n">Task</span><span class="o">.</span><span class="n">State</span><span class="o">.</span><span class="n">TEST</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="s2">&quot;n_test&quot;</span><span class="p">,</span>
                <span class="s2">&quot;t_test&quot;</span><span class="p">,</span>
            <span class="p">):</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">required_test</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">rand_rework</span><span class="p">():</span>
                <span class="n">task</span><span class="o">.</span><span class="n">priority</span> <span class="o">=</span> <span class="n">Task</span><span class="o">.</span><span class="n">PRI_HIGH</span>
                <span class="n">task</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">Task</span><span class="o">.</span><span class="n">State</span><span class="o">.</span><span class="n">WAIT_DEV</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">dev_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">task</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">Task</span><span class="o">.</span><span class="n">State</span><span class="o">.</span><span class="n">COMPLETE</span>
</code></pre></div>
<p>This class gets work from the ready-to-test queue,
and then decides once the work is done
whether the task needs to be re-developed or not.
If it does,
it goes back into the ready-to-develop queue with high priority
to ensure that tasks needing rework are done before tasks that haven&rsquo;t been touched yet.
Without this rule,
far fewer tasks are completed,
and far more tasks are half-done at the simulation&rsquo;s end.</p>
<h2>Logging</h2>
<p>It&rsquo;s finally time to look at the <code>Log</code> class that records data.
Its constructor makes space to record snapshots of
the states of all the tasks in the system,
the lengths of all the queues,
and what the developers and testers are doing:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Log</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Keep a log of interesting things.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sim</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sim</span> <span class="o">=</span> <span class="n">sim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snapshot</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;tasks&quot;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="s2">&quot;queues&quot;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="s2">&quot;workers&quot;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="p">}</span>
</code></pre></div>
<p>The generator that does the active work is simplicity itself:
record the state of the simulation,
then wait a fixed interval
(which we will initially set to one clock tick):</p>
<div class="highlight"><pre><span></span><code>    <span class="k">def</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_record</span><span class="p">()</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;log_interval&quot;</span><span class="p">])</span>
</code></pre></div>
<p>The code to record the simulation state is a bit messy,
because it depends on the implementations of various classes,
but in brief it creates records for:</p>
<ol>
<li>
<p>the state of every task in the system;</p>
</li>
<li>
<p>the lengths of the two queues; and</p>
</li>
<li>
<p>the state of each developer and tester.</p>
</li>
</ol>
<div class="highlight"><pre><span></span><code>    <span class="k">def</span><span class="w"> </span><span class="nf">_record</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Record a log entry at a particular moment.&quot;&quot;&quot;</span>

        <span class="n">now</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">now</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">Labeled</span><span class="o">.</span><span class="n">_all</span><span class="p">[</span><span class="n">Task</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">snapshot</span><span class="p">[</span><span class="s2">&quot;tasks&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">{</span><span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">now</span><span class="p">,</span> <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="s2">&quot;state&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">state</span><span class="p">)}</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">queue</span> <span class="ow">in</span> <span class="p">((</span><span class="s2">&quot;dev&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">dev_queue</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;test&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">test_queue</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">snapshot</span><span class="p">[</span><span class="s2">&quot;queues&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">{</span><span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">now</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span> <span class="s2">&quot;length&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="o">.</span><span class="n">items</span><span class="p">)}</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">kind</span><span class="p">,</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="p">((</span><span class="s2">&quot;dev&quot;</span><span class="p">,</span> <span class="n">Developer</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;test&quot;</span><span class="p">,</span> <span class="n">Tester</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">Labeled</span><span class="o">.</span><span class="n">_all</span><span class="p">[</span><span class="bp">cls</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">snapshot</span><span class="p">[</span><span class="s2">&quot;workers&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">{</span><span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">now</span><span class="p">,</span> <span class="s2">&quot;kind&quot;</span><span class="p">:</span> <span class="n">kind</span><span class="p">,</span> <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">w</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="s2">&quot;state&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">state</span><span class="p">)}</span>
                <span class="p">)</span>
</code></pre></div>
<h2>What Have We Learned?</h2>
<p>The first thing we learned from this refactoring is that
roughly half the code is devoted to collecting data.
This won&rsquo;t come as a surprise to anyone who has ever built a monitoring tool:
figuring out what&rsquo;s going on is often as hard as making things happen,
and sometimes harder.</p>
<p>The second thing we&rsquo;ve learned is that our simulation can still surprise us.
The graph on the left shows the lengths of the develpment and testing queues over time,
while the one on the right shows how many tasks are in each of the possible states:</p>
<div class="row">
  <div class="col-6 center">
    <img src="../files/2025/11/30/sample_queues.svg" alt="queue lengths" width="90%">
    <br>
    Queue Lengths
  </div>
  <div class="col-6 center">
    <img src="../files/2025/11/30/sample_tasks.svg" alt="task states" width="90%">
    <br>
    Task States
  </div>
</div>

<p>The steady growth in the number of tasks waiting for a developer makes sense:
we&rsquo;re generating new ones faster than they can be completed.
But why does the length of the testing queue rise and then fall?
Is it just random variation?
Or is it revealing some unexpected property of our development process?
That question will have to wait for tomorrow.</p>
</article>

<article class="post">
  <h2 class="post-title">
    <a href="../2025/11/29/what-changed-revisited/">
      What Changed Revisited
    </a>
  </h2>
  <p><time datetime="2025-11-29" class="post-date">2025-11-29</time></p>
  <p>Let&rsquo;s take another look at the log-scaled version of [yesterday&rsquo;s chart][what-changed]:</p>
<div class="center">
  <img src="../files/2025/11/28/times-log.svg" alt="log-scale time plot" width="90%">
</div>

<p>There hasn&rsquo;t been any turnover in the team or a major rewrite of the product,
so why has the number of bugs that take more than 100 hours to close
been creeping up slowly but steadily?
Luckily,
we have access to the source code of the simulation,
so we can get a definitive answer.
(Yes, this is cheating…)</p>
<p>The first difference is that
the development and testing queues are priority queues:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Simulation</span><span class="p">:</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span> <span class="o">=</span> <span class="n">simpy</span><span class="o">.</span><span class="n">Environment</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dev_queue</span> <span class="o">=</span> <span class="n">simpy</span><span class="o">.</span><span class="n">PriorityStore</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">test_queue</span> <span class="o">=</span> <span class="n">simpy</span><span class="o">.</span><span class="n">PriorityStore</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">)</span>
</code></pre></div>
<p>We have also added constants to define two priority levels—remember,
a lower number is a higher priority:</p>
<div class="highlight"><pre><span></span><code><span class="n">PRI_REWORK</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">PRI_NEW</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div>
<p>We have also made a small but crucial change to
the class that simulates a tester:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Tester</span><span class="p">(</span><span class="n">Labeled</span><span class="p">):</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">item</span> <span class="o">=</span> <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">test_queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="n">priority</span><span class="p">,</span> <span class="n">task</span> <span class="o">=</span> <span class="n">item</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">task</span><span class="p">[</span><span class="s2">&quot;test_time&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">task_rework</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">dev_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">simpy</span><span class="o">.</span><span class="n">PriorityItem</span><span class="p">(</span><span class="n">PRI_REWORK</span><span class="p">,</span> <span class="n">task</span><span class="p">))</span>
</code></pre></div>
<p>The last two lines of <code>work</code> say,
&ldquo;If testing reveals that this task needs to be re-done,
put it back in the development queue with high priority.&rdquo;
If you&rsquo;ll excuse a bit more ASCII art,
this change means that our simulation is now:</p>
<div class="highlight"><pre><span></span><code>+----------------+    +-----------+    +------------+    +------------+    +---------+
| task generator | -&gt; | dev queue | -&gt; | developers | -&gt; | test queue | -&gt; | testers |
+----------------+    +-----------+    +------------+    +------------+    +---------+
                            ^                                                   |
                            |                                                   |
                            +---------------------------------------------------+
</code></pre></div>
<p>From quarter to quarter,
the probability of QA revealing that a task needs to be re-done
has gone from 0% to 50%.
As noted yesterday,
we see a corresponding decrease in the total number of tasks completed each quarter:</p>
<table>
<thead>
<tr>
<th style="text-align: right;">quarter</th>
<th style="text-align: right;">number</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: right;">1</td>
<td style="text-align: right;">2222</td>
</tr>
<tr>
<td style="text-align: right;">2</td>
<td style="text-align: right;">1912</td>
</tr>
<tr>
<td style="text-align: right;">3</td>
<td style="text-align: right;">1525</td>
</tr>
<tr>
<td style="text-align: right;">4</td>
<td style="text-align: right;">993</td>
</tr>
</tbody>
</table>
<p>What these numbers don&rsquo;t tell us is <em>why</em>.
Are our testers getting better at finding bugs?
Are our developers making more mistakes because they&rsquo;re burning out?
Or has there been some sort of change in how work is being tracked?
(0% rework in the first quarter seems suspicious…)
Once again,
data can draw our attention to things that need to be explained,
but we still have to find the explanation.</p>
</article>

<article class="post">
  <h2 class="post-title">
    <a href="../2025/11/28/what-changed/">
      What Changed?
    </a>
  </h2>
  <p><time datetime="2025-11-28" class="post-date">2025-11-28</time></p>
  <p>Your company brought in a new CEO,
and she believes that you can&rsquo;t manage what you don&rsquo;t measure.
One of the first things she does is look at historical data
on how long developers have spent fixing bugs over the past year.
When she plots the data quarter by quarter,
she gets the following:</p>
<div class="center">
  <img src="../files/2025/11/28/times-linear.svg" alt="linear-scale time plot" width="90%">
</div>

<p>The change over time is easier to see when we scale the Y axis logarithmically:</p>
<div class="center">
  <img src="../files/2025/11/28/times-log.svg" alt="log-scale time plot" width="90%">
</div>

<p>The number of bugs taking more than 100 hours to close is clearly going up over time,
but why?
And why has the number of bugs closed per quarter been dropping:</p>
<table>
<thead>
<tr>
<th style="text-align: right;">quarter</th>
<th style="text-align: right;">number</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: right;">1</td>
<td style="text-align: right;">2222</td>
</tr>
<tr>
<td style="text-align: right;">2</td>
<td style="text-align: right;">1912</td>
</tr>
<tr>
<td style="text-align: right;">3</td>
<td style="text-align: right;">1525</td>
</tr>
<tr>
<td style="text-align: right;">4</td>
<td style="text-align: right;">993</td>
</tr>
</tbody>
</table>
<p>There hasn&rsquo;t been any turnover in the team,
or a major rewrite of the product.
What has changed?
I&rsquo;ll post the reason tomorrow;
for today,
see what theories you can come up with
and what data you would need to confirm or refute them.</p>
</article>

<article class="post">
  <h2 class="post-title">
    <a href="../2025/11/27/not-created-equal/">
      Not Created Equal
    </a>
  </h2>
  <p><time datetime="2025-11-27" class="post-date">2025-11-27</time></p>
  <p><a href="../2025/11/26/malice-and-randomness/">Yesterday&rsquo;s post</a> pointed out that
it can be hard to distinguish cause and effect from random variation.
One way to tell them apart is to vary the simulation parameters systematically
to see when various phenomena appear and disappear.
For example,
suppose we modify the simulation to account for the fact that
not all tasks are created equal.
Some bugs and features have higher priority than others,
and our team will generally work on more important items before they work on less important ones.</p>
<p>Alongside the <code>Store</code> we have been using to model our work queue,
<a href="https://simpy.readthedocs.io/">SimPy</a> offers a <code>PriorityStore</code> that keeps items sorted in priority order.
(The lower the item&rsquo;s score, the higher its priority.)
Let&rsquo;s modify the <code>Simulation</code> class to make the development and testing queues priority stores:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Simulation</span><span class="p">:</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span> <span class="o">=</span> <span class="n">simpy</span><span class="o">.</span><span class="n">Environment</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dev_queue</span> <span class="o">=</span> <span class="n">simpy</span><span class="o">.</span><span class="n">PriorityStore</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">test_queue</span> <span class="o">=</span> <span class="n">simpy</span><span class="o">.</span><span class="n">PriorityStore</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queue_log</span> <span class="o">=</span> <span class="p">[]</span>
</code></pre></div>
<p>and then add a new parameter <code>task_priorities</code>
whose value is a list of probabilities:</p>
<div class="highlight"><pre><span></span><code><span class="n">PARAMS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="err">…</span><span class="n">previous</span> <span class="n">code</span><span class="err">…</span>
    <span class="s2">&quot;task_priorities&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">],</span>
<span class="p">}</span>
</code></pre></div>
<p>The list shown above tells us that there&rsquo;s a 10% chance of a new task having priority 0,
a 30% chance of it having priority 1,
and a 60% chance of it having priority 2.
When we create a task,
we assign it a priority at random with these weights:</p>
<div class="highlight"><pre><span></span><code>    <span class="k">def</span><span class="w"> </span><span class="nf">task_priority</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">random</span><span class="o">.</span><span class="n">choices</span><span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;task_priorities&quot;</span><span class="p">]))),</span>
            <span class="n">weights</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;task_priorities&quot;</span><span class="p">],</span>
            <span class="n">k</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div>
<p>(We need the <code>[0]</code> at the end because <code>random.choices</code> always returns a list of choices,
even when we tell it we only want one value.)
Finally,
when we&rsquo;re adding a new task to the development queue
we wrap it in a <code>PriorityItem</code>
to pair the task with its priority:</p>
<div class="highlight"><pre><span></span><code>    <span class="k">def</span><span class="w"> </span><span class="nf">generate</span><span class="p">(</span><span class="n">sim</span><span class="p">):</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">sim</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">task_arrival</span><span class="p">())</span>
            <span class="n">task</span> <span class="o">=</span> <span class="n">Task</span><span class="p">(</span><span class="n">sim</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">sim</span><span class="o">.</span><span class="n">dev_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">simpy</span><span class="o">.</span><span class="n">PriorityItem</span><span class="p">(</span><span class="n">task</span><span class="p">[</span><span class="s2">&quot;priority&quot;</span><span class="p">],</span> <span class="n">task</span><span class="p">))</span>
</code></pre></div>
<div class="row">
  <div class="col-6 center">
    <img src="../files/2025/11/27/queues-136.svg" alt="10/30/60" width="90%">
    <br>
    Queue lengths: 10/30/60
  </div>
  <div class="col-6 center">
    <img src="../files/2025/11/27/queues-334.svg" alt="30/30/40" width="90%">
    <br>
    Queue lengths: 30/30/40
  </div>
</div>
<div class="row">
  <div class="col-6 center">
    <img src="../files/2025/11/27/queues-433.svg" alt="40/30/30" width="90%">
    <br>
    Queue lengths: 40/30/30
  </div>
  <div class="col-6 center">
    <img src="../files/2025/11/27/queues-442.svg" alt="40/40/20" width="90%">
    <br>
    Queue lengths: 40/40/20
  </div>
</div>

<p>The top (green) line in these four charts is the number of priority-2 tasks
waiting in the development queue.
It grows steadily because developers are basically busy at all times with higher-priority tasks;
it&rsquo;s only when 80% or more of tasks are higher priority that
we start to see a backlog of priority-1 tasks build up.
I don&rsquo;t know if I expected this or not,
but I certainly <em>didn&rsquo;t</em> expect that the testers would always be able to keep up
with tasks of all priorities.</p>
<p>These curves look familiar to me.
In my previous role at <a href="https://plot.ly/">Plotly</a>,
I was responsible for managing the backlog of bug reports and feature requests
for the open source libraries.
When I started in April 2025,
nobody had gone through them for several years;
over that summer,
I cleared out enough stale and duplicated items
to get the three main repositories from about 7000 issues down to about 1700.
I then watched as the number grew slowly but steadily over the next twelve months.
Everyone on the team was working hard,
but if your library, tool, or application is useful,
there will <em>always</em> be more work to do than people to do it.
The only &ldquo;solution&rdquo; is to be ruthless about labeling
so that you don&rsquo;t get demoralized.</p>
</article>


    </main>
    <footer>
  &copy; 2004-2025 <a href="../about/">Greg Wilson</a>
  <a href="mailto:gvwilson@third-bit.com"><img src="../assets/icons/envelope.svg" alt="email" class="footer-icon"></a>
  <a href="https://www.linkedin.com/in/gvwilson/"><img src="../assets/icons/linkedin.svg" alt="LinkedIn" class="footer-icon"></a>
  <a href="https://mastodon.social/@gvwilson"><img src="../assets/icons/mastodon.svg" alt="Mastodon" class="footer-icon"></a>
  <a href="https://calendly.com/gvwilson/30min"><img src="../assets/icons/calendar.svg" alt="Calendly" class="footer-icon"></a>
  <a href="https://github.com/gvwilson"><img src="../assets/icons/github.svg" alt="GitHub" class="footer-icon"></a>
  <a href="https://www.youtube.com/channel/UCbDQ7FIeYB3FHRADAjUjfrg"><img src="../assets/icons/youtube.svg" alt="YouTube" class="footer-icon"></a>
  <a href="../bib/"><img src="../assets/icons/orcid.svg" alt="ORCID" class="footer-icon"></a>
  <a href="../atom.xml"><img src="../assets/icons/rss.svg" alt="RSS feed" class="footer-icon"></a>
  <a href="../license/"><img src="../assets/icons/cc-by.svg" alt="license" class="footer-icon"></a>
  <a href="../colophon/"><img src="../assets/icons/pencil.svg" alt="colophon" class="footer-icon"></a>
  <a href="../cv/"><img src="../assets/icons/file.svg" alt="CV" class="footer-icon"></a>
  <br>
  None of the material on this site may be used to train AI models without the express prior permission of the author.
</footer>
  </body>
</html>