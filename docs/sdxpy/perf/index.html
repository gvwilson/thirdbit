<!DOCTYPE html>
<html lang="en">
  <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="repo" content="https://github.com/gvwilson/sdxpy">
  <meta name="build_date" content="2024-04-28">
  <meta name="template" content="default">
  <meta name="major" content="perf">
  <meta name="has_slides" content="true">
  <link rel="icon" type="image/x-icon" href="../favicon.ico">
  <link rel="stylesheet" href="../mccole.css">
  <link rel="stylesheet" href="../tango.css">
  <script defer data-domain="third-bit.com" src="https://plausible.io/js/plausible.js"></script>
  <script>
    MathJax = {
      tex: {
        inlineMath: [['\\(', '\\)']]
      }
    };
  </script>
  <script
    type="text/javascript"
    id="MathJax-script"
    async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
  <script defer src="../mccole.js"></script>
  <title>Software Design by Example: Performance Profiling</title>
</head>

  <body>
    <div class="row">
      <div class="sidebar">
        <p>
  
  <a href="https://www.routledge.com/Software-Design-by-Example-A-Tool-Based-Introduction-with-Python/Wilson/p/book/9781032725215"><img src="../sdxpy-cover.png" alt="Book cover" width="80%" /></a>
  
</p>

<div class="screen-reader-only">
  <a href="#printable">Skip to content</a>
</div>

<ol class="toc-chapter">
  
  <li>
    <a href="../intro/">
      Introduction
    </a>
  </li>
  
  <li>
    <a href="../oop/">
      Objects and Classes
    </a>
  </li>
  
  <li>
    <a href="../dup/">
      Finding Duplicate Files
    </a>
  </li>
  
  <li>
    <a href="../glob/">
      Matching Patterns
    </a>
  </li>
  
  <li>
    <a href="../parse/">
      Parsing Text
    </a>
  </li>
  
  <li>
    <a href="../test/">
      Running Tests
    </a>
  </li>
  
  <li>
    <a href="../interp/">
      An Interpreter
    </a>
  </li>
  
  <li>
    <a href="../func/">
      Functions and Closures
    </a>
  </li>
  
  <li>
    <a href="../protocols/">
      Protocols
    </a>
  </li>
  
  <li>
    <a href="../archive/">
      A File Archiver
    </a>
  </li>
  
  <li>
    <a href="../check/">
      An HTML Validator
    </a>
  </li>
  
  <li>
    <a href="../template/">
      A Template Expander
    </a>
  </li>
  
  <li>
    <a href="../lint/">
      A Code Linter
    </a>
  </li>
  
  <li>
    <a href="../layout/">
      Page Layout
    </a>
  </li>
  
  <li>
    <a href="../perf/">
      <strong>Performance Profiling</strong>
    </a>
  </li>
  
  <li>
    <a href="../persist/">
      Object Persistence
    </a>
  </li>
  
  <li>
    <a href="../binary/">
      Binary Data
    </a>
  </li>
  
  <li>
    <a href="../db/">
      A Database
    </a>
  </li>
  
  <li>
    <a href="../build/">
      A Build Manager
    </a>
  </li>
  
  <li>
    <a href="../pack/">
      A Package Manager
    </a>
  </li>
  
  <li>
    <a href="../ftp/">
      Transferring Files
    </a>
  </li>
  
  <li>
    <a href="../http/">
      Serving Web Pages
    </a>
  </li>
  
  <li>
    <a href="../viewer/">
      A File Viewer
    </a>
  </li>
  
  <li>
    <a href="../undo/">
      Undo and Redo
    </a>
  </li>
  
  <li>
    <a href="../vm/">
      A Virtual Machine
    </a>
  </li>
  
  <li>
    <a href="../debugger/">
      A Debugger
    </a>
  </li>
  
  <li>
    <a href="../finale/">
      Conclusion
    </a>
  </li>
  
</ol>

<ol class="toc-appendix">
  
  <li>
    <a href="../bib/">
      Bibliography
    </a>
  </li>
  
  <li>
    <a href="../bonus/">
      Bonus Material
    </a>
  </li>
  
  <li>
    <a href="../syllabus/">
      Syllabus
    </a>
  </li>
  
  <li>
    <a href="../license/">
      License
    </a>
  </li>
  
  <li>
    <a href="../conduct/">
      Code of Conduct
    </a>
  </li>
  
  <li>
    <a href="../contrib/">
      Contributing
    </a>
  </li>
  
  <li>
    <a href="../glossary/">
      Glossary
    </a>
  </li>
  
  <li>
    <a href="../colophon/">
      Colophon
    </a>
  </li>
  
  <li>
    <a href="../contents/">
      Index
    </a>
  </li>
  
</ol>


<p><a href="../sdxpy-examples.zip" type="application/zip">download examples</a></p>


<p><a href="https://github.com/gvwilson/sdxpy">GitHub repository</a></p>

      </div>
      <div id="printable" class="contents bordered">
        <main>
          
  <h1>Chapter 15: Performance Profiling</h1>


          

	  
<div class="chapterinfo">

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  
  <ul class="syllabus">
  
  <li markdown="1">Create abstract classes to specify interfaces.</li>
  
  <li markdown="1">Store two-dimensional data as rows or as columns.</li>
  
  <li markdown="1">Use reflection to match data to function parameters.</li>
  
  <li markdown="1">Measure performance to evaluate engineering tradeoffs.</li>
  
  </ul>
  

  

  

  

  

  

  

  

  

  

  

  



<p class="definitions">
  Terms defined: <a class="gl-ref" href="../glossary/#gl:batch_processing" markdown="1">batch processing</a>, <a class="gl-ref" href="../glossary/#gl:benchmark" markdown="1">benchmark</a>, <a class="gl-ref" href="../glossary/#gl:column_wise" markdown="1">column-wise storage</a>, <a class="gl-ref" href="../glossary/#gl:data_engineer" markdown="1">data engineer</a>, <a class="gl-ref" href="../glossary/#gl:dataframe" markdown="1">dataframe</a>, <a class="gl-ref" href="../glossary/#gl:docstring" markdown="1">docstring</a>, <a class="gl-ref" href="../glossary/#gl:immutable" markdown="1">immutable</a>, <a class="gl-ref" href="../glossary/#gl:index_database" markdown="1">index (a database)</a>, <a class="gl-ref" href="../glossary/#gl:join" markdown="1">join (tables)</a>, <a class="gl-ref" href="../glossary/#gl:olap" markdown="1">online analytical processing</a>, <a class="gl-ref" href="../glossary/#gl:oltp" markdown="1">online transaction processing</a>, <a class="gl-ref" href="../glossary/#gl:parameter_sweeping" markdown="1">parameter sweeping</a>, <a class="gl-ref" href="../glossary/#gl:profiling" markdown="1">profiling</a>, <a class="gl-ref" href="../glossary/#gl:row_wise" markdown="1">row-wise storage</a>
</p>


</div>


          <div class="page-toc"></div>
          <p>One peril of publishing a book online is obsessing over analytics.
How many people visited the site today?
Which pages did they look at, and for how long?
Whether we use <span class="ix-entry" ix-key="Excel" markdown="1">Excel</span>, <span class="ix-entry" ix-key="SQL" markdown="1">SQL</span>, or Python,
we will almost certainly be analyzing tables
with named columns and multiple rows.
Such tables are called <a class="gl-ref" href="../glossary/#gl:dataframe" title="A two-dimensional data structure for storing tabular data in memory. Rows represent records and columns represent fields." markdown="1">dataframes</a>,
and their performance is important when we are working with large data sets.
This chapter therefore implements dataframes in two ways
and shows how to compare their performance.</p>
<h2 id="perf-options">Section 15.1: Options</h2>
<p>To start,
let&rsquo;s create an <span class="ix-entry" ix-key="abstract class" markdown="1">abstract class</span>
that defines the methods our dataframe classes will support.
This class requires <span class="ix-entry" ix-key="concrete class" markdown="1">concrete classes</span>
to implement the methods shown below:</p>
<div class="code-sample lang-py" title="df_base.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">DataFrame</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">ncol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Report the number of columns.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">nrow</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Report the number of rows.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">cols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the set of column names.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">eq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check equality with another dataframe.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a scalar value.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">names</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Select a named subset of columns.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Select a subset of rows by testing values.&quot;&quot;&quot;</span>
</code></pre></div>
</div>
<div class="callout">
<h3>Docstrings Are Enough</h3>
<p>Every method in Python needs a body,
so many programmers will write <code>pass</code> (Python&rsquo;s &ldquo;do nothing&rdquo; statement).
However,
a <a class="gl-ref" href="../glossary/#gl:docstring" title="A string at the start of a module, class, or function in Python that is not assigned to a variable, which is used to hold the documentation for that part of code." markdown="1">docstring</a> also counts as a body,
so if we write those (which we should)
there&rsquo;s no need to write <code>pass</code>.</p>
</div>
<p>For our first usable implementation,
we will derive a class <code>DfRow</code> that uses
<a class="gl-ref" href="../glossary/#gl:row_wise" title="To organize the memory of a two-dimensional table so that the values in each row are laid out in contiguous blocks." markdown="1">row-wise</a> storage
(<a class="fig-ref" href="../perf/#perf-row-storage">Figure 15.1</a>).
The dataframe is stored as a list of dictionaries,
each of which represents a row.
All of the dictionaries must have the same keys
so that the concept of &ldquo;column&rdquo; is meaningful,
and the values associated with a particular key must all have the same type.</p>
<figure id="perf-row-storage">
<img src="./row_storage.svg" alt="Row-wise storage"/>
<figcaption markdown="1">Figure 15.1: Storing a dataframe&rsquo;s data in rows.</figcaption>
</figure>

<p>Our second implementation,
<code>DfCol</code>,
will use <a class="gl-ref" href="../glossary/#gl:column_wise" title="To organize the memory of a two-dimensional table so that the values in each column are laid out in contiguous blocks." markdown="1">column-wise</a> storage
(<a class="fig-ref" href="../perf/#perf-col-storage">Figure 15.2</a>).
Each column is stored as a list of values,
all of which are of the same type.
The dataframe itself is a dictionary of such lists,
all of which have the same length
so that there are no holes in any of the rows.
How we store the data determines which methods are easy to implement
and which are hard,
and which are fast or slow.</p>
<figure id="perf-col-storage">
<img src="./col_storage.svg" alt="Column-wise storage"/>
<figcaption markdown="1">Figure 15.2: Storing a dataframe&rsquo;s data in columns.</figcaption>
</figure>

<h2 id="perf-row">Section 15.2: Row-Wise Storage</h2>
<p>We start by deriving <code>DfRow</code> from <code>DataFrame</code> and writing its constructor,
which takes a list of dictionaries as an argument,
checks that they&rsquo;re consistent with each other,
and saves them:</p>
<div class="code-sample lang-py" title="df_row.py">
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">df_base</span> <span class="kn">import</span> <span class="n">DataFrame</span>
<span class="kn">from</span> <span class="nn">util</span> <span class="kn">import</span> <span class="n">dict_match</span>

<span class="k">class</span> <span class="nc">DfRow</span><span class="p">(</span><span class="n">DataFrame</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rows</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">dict_match</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">rows</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">rows</span>
</code></pre></div>
</div>
<p>The <span class="ix-entry" ix-key="helper function" markdown="1">helper function</span> to check that a bunch of dictionaries
all have the same keys and the same types of values associated with those keys is:</p>
<div class="code-sample lang-py" title="util.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">dict_match</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">prototype</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">prototype</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">prototype</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">d</span><span class="p">)</span>
</code></pre></div>
</div>
<p class="continue">Notice that <code>DfRow</code>&rsquo;s constructor compares all of the rows against the first row.
Doing this means that we can&rsquo;t create an empty dataframe,
i.e.,
one that has no rows.
This restriction wasn&rsquo;t part of our original design:
it&rsquo;s an accident of implementation that might surprise our users.
It&rsquo;s OK not to fix this while we&rsquo;re prototyping,
but we will look at ways to address it in the exercises.</p>
<p>Four of the methods required by <code>DataFrame</code> are easy to implement
on top of row-wise storage,
though once again our implementation assumes there is at least one row:</p>
<div class="code-sample lang-py" title="df_row.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">ncol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">nrow</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">cols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span>
</code></pre></div>
</div>
<p>Checking equality is also relatively simple.
Two dataframes are the same if they have exactly the same columns
and the same values in every column:</p>
<div class="code-sample lang-py" title="df_row.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">eq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">row</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">cols</span><span class="p">():</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>
</code></pre></div>
</div>
<p class="continue">Notice that we use <code>other.cols()</code> and <code>other.get()</code>
rather than reaching into the other dataframe.
We are planning to implement dataframes in several different ways,
and we might want to compare instances of those different implementations.
Since they might have different internal data structures,
the only safe way to do this is
to rely on the interface defined in the <span class="ix-entry" ix-key="base class" markdown="1">base class</span>.</p>
<p>Our final operations are selection,
which returns a subset of the original dataframe&rsquo;s columns,
and filtering,
which returns a subset of its rows.
Since we don&rsquo;t know how many columns the user might want,
we give the <code>select</code> method a single parameter <code>*names</code>
that will capture zero or more positional arguments.
We then build a new list of dictionaries
that only contain the fields with those names (<a class="fig-ref" href="../perf/#perf-row-select">Figure 15.3</a>):</p>
<div class="code-sample lang-py" title="df_row.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">names</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">names</span><span class="p">)</span>
    <span class="n">rows</span> <span class="o">=</span> <span class="p">[{</span><span class="n">key</span><span class="p">:</span> <span class="n">r</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">names</span><span class="p">}</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">DfRow</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
</code></pre></div>
</div>
<figure id="perf-row-select">
<img src="./row_select.svg" alt="Row-wise select"/>
<figcaption markdown="1">Figure 15.3: Selecting columns from data stored as rows.</figcaption>
</figure>

<p>We now need to decide how to filter rows.
Typical filtering conditions include,
&ldquo;Keep rows where <code>red</code> is non-zero,&rdquo;
&ldquo;Keep rows where <code>red</code> is greater than <code>green</code>,&rdquo;
and, &ldquo;Keep rows where <code>red+green</code> is within 10% of <code>blue</code>.&rdquo;
Rather than trying to anticipate every possible rule,
we require users to define functions
whose parameters match the names of the table&rsquo;s columns.
For example,
if we have this test <span class="ix-entry" ix-key="fixture" markdown="1">fixture</span>:</p>
<div class="code-sample lang-py" title="test_df_row.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">odd_even</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">DfRow</span><span class="p">([{</span><span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="p">{</span><span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">}])</span>
</code></pre></div>
</div>
<p class="continue">then we should be able to write this test:</p>
<div class="code-sample lang-py" title="test_df_row.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">test_filter</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">odd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">odd_even</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">df</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">odd</span><span class="p">)</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">DfRow</span><span class="p">([{</span><span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}]))</span>
</code></pre></div>
</div>
<p>We can implement this  by using <code>**</code> to <span class="ix-entry" ix-key="spread" markdown="1">spread</span> the row
across the function&rsquo;s parameters (<a class="x-ref" href="../oop/">Chapter 2</a>).
If there are keys in the row that don&rsquo;t match parameters in the function
or vice versa,
Python will throw an exception,
but that&rsquo;s probably what we want.
Using this,
the implementation of <code>DfRow.filter</code> is:</p>
<div class="code-sample lang-py" title="df_row.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="k">if</span> <span class="n">func</span><span class="p">(</span><span class="o">**</span><span class="n">r</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">DfRow</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</code></pre></div>
</div>
<p>Notice that the dataframe created by <code>filter</code>
re-uses the rows of the original dataframe (<a class="fig-ref" href="../perf/#perf-row-filter">Figure 15.4</a>).
This is safe and efficient as long as dataframes are <a class="gl-ref" href="../glossary/#gl:immutable" title="Data that cannot be changed after being created. Immutable data is easier to think about, particularly if data structures are shared between several tasks, but may result in higher memory requirements." markdown="1">immutable</a>,
i.e.,
as long as their contents are never changed in place.
Most dataframe libraries work this way:
while recycling memory can save a little time,
it usually also makes bugs much harder to track down.</p>
<figure id="perf-row-filter">
<img src="./row_filter.svg" alt="Row-wise filtering"/>
<figcaption markdown="1">Figure 15.4: Filtering data stored as rows.</figcaption>
</figure>

<h2 id="perf-col">Section 15.3: Column-Wise Storage</h2>
<p>Having done all of this thinking,
our column-wise dataframe class is somewhat easier to write.
We start as before with its constructor:</p>
<div class="code-sample lang-py" title="df_col.py">
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">df_base</span> <span class="kn">import</span> <span class="n">DataFrame</span>
<span class="kn">from</span> <span class="nn">util</span> <span class="kn">import</span> <span class="n">all_eq</span>

<span class="k">class</span> <span class="nc">DfCol</span><span class="p">(</span><span class="n">DataFrame</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="n">all_eq</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">all_eq</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">kwargs</span>
</code></pre></div>
</div>
<p class="continue">and use a helper function <code>all_eq</code> to check that
all of the values in any column have the same types:</p>
<div class="code-sample lang-py" title="util.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">all_eq</span><span class="p">(</span><span class="o">*</span><span class="n">values</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="ow">not</span> <span class="n">values</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">all</span><span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="callout">
<h3>One Allowable Difference</h3>
<p>Notice that <code>DfCol</code>&rsquo;s constructor does <em>not</em> have the same <span class="ix-entry" ix-key="signature" markdown="1">signature</span>
as <code>DfRow</code>&rsquo;s.
At some point in our code we have to decide which of the two classes to construct.
If we design our code well,
that decision will be made in exactly one place
and everything else will rely solely on the common interface defined by <code>DataFrame</code>.
But since we have to type a different class name at the point of construction,
it&rsquo;s OK for the constructors to be different.</p>
</div>
<p>The four methods that were simple to write for <code>DfRow</code>
are equally simple to write for <code>DfCol</code>,
though once again our prototype implementation accidentally disallows empty dataframes:</p>
<div class="code-sample lang-py" title="df_col.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">ncol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">nrow</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">cols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
    <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">col</span><span class="p">])</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">col</span><span class="p">][</span><span class="n">row</span><span class="p">]</span>
</code></pre></div>
</div>
<p>As with <code>DfRow</code>,
the method that checks equality relies on the internal details of its own class
but uses the interface defined by <code>DataFrame</code> to access the other object:</p>
<div class="code-sample lang-py" title="df_col.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">eq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">cols</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">n</span><span class="p">])):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>
</code></pre></div>
</div>
<p>To select columns,
we pick the ones named by the caller
and use them to create a new dataframe.
Again,
this recycles the existing storage:</p>
<div class="code-sample lang-py" title="df_col.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">names</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">names</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">DfCol</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">names</span><span class="p">})</span>
</code></pre></div>
</div>
<figure id="perf-col-select">
<img src="./col_select.svg" alt="Column-wise selection"/>
<figcaption markdown="1">Figure 15.5: Column-wise selection.</figcaption>
</figure>

<p>Finally,
we need to filter the rows of a column-wise dataframe.
Doing this is complex:
since values are stored in columns,
we have to extract the ones belonging to each row
to pass them into the user-defined filter function
(<a class="fig-ref" href="../perf/#perf-col-filter">Figure 15.6</a>).
And if that wasn&rsquo;t enough,
we want to do this solely for the columns that the user&rsquo;s function needs.</p>
<figure id="perf-col-filter">
<img src="./col_filter.svg" alt="Packing column values into rows"/>
<figcaption markdown="1">Figure 15.6: Extracting values from columns to create temporary rows.</figcaption>
</figure>

<p>For now,
we will solve this problem
by requiring the user-defined filter function to define <span class="ix-entry" ix-key="parameter" markdown="1">parameters</span>
to match all of the dataframe&rsquo;s columns
regardless of whether they are used for filtering or not.
We will then build a temporary dictionary with all the values in a &ldquo;row&rdquo;
(i.e.,
the corresponding values across all columns)
and use <code>**</code> to spread it across the filter function.
<a class="x-ref" href="../bonus/">Appendix B</a> looks at a safer, but more complex, way to do this.</p>
<div class="code-sample lang-py" title="df_col.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">()):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">func</span><span class="p">(</span><span class="o">**</span><span class="n">args</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">DfCol</span><span class="p">(</span><span class="o">**</span><span class="n">result</span><span class="p">)</span>
</code></pre></div>
</div>
<p>Time to write some tests.
This one checks that we can construct a dataframe with some values:</p>
<div class="code-sample lang-py" title="test_df_col.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">test_construct_with_two_pairs</span><span class="p">():</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">DfCol</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
    <span class="k">assert</span> <span class="n">df</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="n">df</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="k">assert</span> <span class="n">df</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
    <span class="k">assert</span> <span class="n">df</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span>
</code></pre></div>
</div>
<p class="continue">while this one checks that <code>filter</code> works correctly:</p>
<div class="code-sample lang-py" title="test_df_col.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">test_filter</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">odd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">DfCol</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
    <span class="k">assert</span> <span class="n">df</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">odd</span><span class="p">)</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">DfCol</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
</code></pre></div>
</div>
<h2 id="perf-performance">Section 15.4: Performance</h2>
<p>Our two implementations of dataframes have identical interfaces,
so how can we choose which to use?</p>
<div class="callout">
<h3>Transactions vs. Analysis</h3>
<p>Regardless of data volumes,
different storage schemes are better (or worse) for different kinds of work.
<a class="gl-ref" href="../glossary/#gl:oltp" title="Adding records to a database or querying individual records. The term is used in contrast to OLAP." markdown="1">Online transaction processing</a> (OLTP)
refers to adding or querying individual records,
such as online sales.
<a class="gl-ref" href="../glossary/#gl:olap" title="Analyzing data in bulk. The term is used in contrast to OLTP." markdown="1">Online analytical processing</a> (OLAP),
on the other hand,
processes selected columns of a table in bulk to do things like find averages over time.
Row-wise storage is usually best for OLTP,
but column-wise storage is better suited for OLAP.
If data volumes are large,
<a class="gl-ref" href="../glossary/#gl:data_engineer" title="Someone responsible for designing, developing, and maintaining systems for collecting, storing, and analyzing data." markdown="1">data engineers</a> will sometimes run two databases in parallel,
using <a class="gl-ref" href="../glossary/#gl:batch_processing" title="Executing a set of non-interactive tasks on a computer, such as backing up files or copying data from one database to another overnight." markdown="1">batch processing</a> jobs
to copy new or updated records from the OLTP databases over to the OLAP database.</p>
</div>
<p>To compare the speed of these classes,
let&rsquo;s write a short program to create dataframes of each kind
and time how long it takes to select their columns and filter their rows.
To keep things simple,
we will create dataframes whose columns are called <code>label_1</code>, <code>label_2</code>, and so on,
and whose values are all integers in the range 0–9.
A thorough set of <a class="gl-ref" href="../glossary/#gl:benchmark" title="A program or set of programs used to measure the performance of a computer system." markdown="1">benchmarks</a>
would create columns with other datatypes as well,
but this example is enough to illustrate the technique.</p>
<div class="code-sample lang-py" title="timing.py">
<div class="highlight"><pre><span></span><code><span class="n">RANGE</span> <span class="o">=</span> <span class="mi">10</span>

<span class="k">def</span> <span class="nf">make_col</span><span class="p">(</span><span class="n">nrow</span><span class="p">,</span> <span class="n">ncol</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_col</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[((</span><span class="n">start</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="n">RANGE</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="n">fill</span> <span class="o">=</span> <span class="p">{</span><span class="sa">f</span><span class="s2">&quot;label_</span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">_col</span><span class="p">(</span><span class="n">nrow</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncol</span><span class="p">)}</span>
    <span class="k">return</span> <span class="n">DfCol</span><span class="p">(</span><span class="o">**</span><span class="n">fill</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">make_row</span><span class="p">(</span><span class="n">nrow</span><span class="p">,</span> <span class="n">ncol</span><span class="p">):</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;label_</span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncol</span><span class="p">)]</span>
    <span class="k">def</span> <span class="nf">_row</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="n">c</span><span class="p">:</span> <span class="p">((</span><span class="n">r</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="n">RANGE</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="n">fill</span> <span class="o">=</span> <span class="p">[</span><span class="n">_row</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nrow</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">DfRow</span><span class="p">(</span><span class="n">fill</span><span class="p">)</span>
</code></pre></div>
</div>
<p>To time <code>filter</code>,
we arbitrarily decide to keep rows with an even value in the first column:</p>
<div class="code-sample lang-py" title="timing.py">
<div class="highlight"><pre><span></span><code><span class="n">FILTER</span> <span class="o">=</span> <span class="mi">2</span>

<span class="k">def</span> <span class="nf">time_filter</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">label_0</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">label_0</span> <span class="o">%</span> <span class="n">FILTER</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">df</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
</code></pre></div>
</div>
<p class="continue">Since <code>DfCol</code> and <code>DfRow</code> derive from the same base class,
<code>time_filter</code> doesn&rsquo;t care which we give it.
Again,
if we were doing this for real,
we would look at actual programs
to see what fraction of rows filtering usually kept and simulate that.</p>
<p>To time <code>select</code>,
we arbitrarily decide to keep one-third of the columns:</p>
<div class="code-sample lang-py" title="timing.py">
<div class="highlight"><pre><span></span><code><span class="n">SELECT</span> <span class="o">=</span> <span class="mi">3</span>

<span class="k">def</span> <span class="nf">time_select</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">ncol</span><span class="p">())</span> <span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">%</span> <span class="n">SELECT</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)]</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;label_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">df</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">*</span><span class="n">labels</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
</code></pre></div>
</div>
<p>Finally,
we write a function that takes a list of strings like <code>3x3</code> or <code>100x20</code>,
creates dataframes of each size,
times operations,
and reports the results.
We call this function <code>sweep</code> because
executing code multiple times with different parameters to measure performance
is called <a class="gl-ref" href="../glossary/#gl:parameter_sweeping" title="To execute a program multiple times with different parameters to find out how its behavior or performance depends on those parameters." markdown="1">parameter sweeping</a>:</p>
<div class="code-sample lang-py" title="timing.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">sweep</span><span class="p">(</span><span class="n">sizes</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">nrow</span><span class="p">,</span> <span class="n">ncol</span><span class="p">)</span> <span class="ow">in</span> <span class="n">sizes</span><span class="p">:</span>
        <span class="n">df_col</span> <span class="o">=</span> <span class="n">make_col</span><span class="p">(</span><span class="n">nrow</span><span class="p">,</span> <span class="n">ncol</span><span class="p">)</span>
        <span class="n">df_row</span> <span class="o">=</span> <span class="n">make_row</span><span class="p">(</span><span class="n">nrow</span><span class="p">,</span> <span class="n">ncol</span><span class="p">)</span>
        <span class="n">times</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">time_filter</span><span class="p">(</span><span class="n">df_col</span><span class="p">),</span>
            <span class="n">time_select</span><span class="p">(</span><span class="n">df_col</span><span class="p">),</span>
            <span class="n">time_filter</span><span class="p">(</span><span class="n">df_row</span><span class="p">),</span>
            <span class="n">time_select</span><span class="p">(</span><span class="n">df_row</span><span class="p">),</span>
        <span class="p">]</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">nrow</span><span class="p">,</span> <span class="n">ncol</span><span class="p">,</span> <span class="o">*</span><span class="n">times</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div>
</div>
<p>The results are shown in <a class="tbl-ref" href="../perf/#perf-timing">Table 15.1</a> and <a class="fig-ref" href="../perf/#perf-analysis">Figure 15.7</a>.
For a \( 1000 \times 1000 \) dataframe,
selection is over 250 times faster with column-wise storage than with row-wise,
while filtering is 1.8 times slower.</p>
<div class="table"><table id="perf-timing" class="here"><caption>Table 15.1: Dataframe timings.</caption>
<thead>
<tr>
<th>nrow</th>
<th>ncol</th>
<th>filter col</th>
<th>select col</th>
<th>filter row</th>
<th>select row</th>
</tr>
</thead>
<tbody>
<tr>
<td>10</td>
<td>10</td>
<td>8.87e-05</td>
<td>7.70e-05</td>
<td>4.41e-05</td>
<td>2.50e-05</td>
</tr>
<tr>
<td>100</td>
<td>100</td>
<td>0.00275</td>
<td>4.10e-05</td>
<td>0.00140</td>
<td>8.76e</td>
</tr>
<tr>
<td>1000</td>
<td>1000</td>
<td>0.146</td>
<td>0.000189</td>
<td>0.0787</td>
<td>0.0508</td>
</tr>
<tr>
<td>10000</td>
<td>10000</td>
<td>19.0</td>
<td>0.00234</td>
<td>9.97</td>
<td>5.57</td>
</tr>
</tbody>
</table>
</div>
<figure id="perf-analysis" class="here">
<img src="./analysis.svg" alt="Performance curves"/>
<figcaption markdown="1">Figure 15.7: Relative performance of row-wise and column-wise storage.</figcaption>
</figure>

<p>We can get much more insight by <a class="gl-ref" href="../glossary/#gl:profiling" title="The act of measuring where a program spends its time, which operations consume memory or disk space, etc." markdown="1">profiling</a> our code
using Python <a href="https://docs.python.org/3/library/profile.html"><code>cProfile</code></a> module,
which collects detailed information on how long each function runs
and reports the result:</p>
<div class="code-sample lang-sh" title="profile.sh">
<div class="highlight"><pre><span></span><code>python<span class="w"> </span>-m<span class="w"> </span>cProfile<span class="w"> </span>--sort<span class="o">=</span>tottime<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>timing.py<span class="w"> </span>--silent<span class="w"> </span>10x10<span class="w"> </span>50x50<span class="w"> </span>100x100<span class="w"> </span>500x500<span class="w"> </span>1000x1000
</code></pre></div>
</div>
<div class="code-sample lang-out" title="profile.out">
<div class="highlight"><pre><span></span><code>         3007281 function calls (3003108 primitive calls) in 2.120 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
  2319840    0.671    0.000    0.671    0.000 util.py:10(&lt;genexpr&gt;)
        5    0.271    0.054    0.521    0.104 df_col.py:50(filter)
     1660    0.261    0.000    0.261    0.000 timing.py:20(&lt;dictcomp&gt;)
8066/3916    0.213    0.000    1.056    0.000 {built-in method builtins.all}
     1660    0.191    0.000    0.191    0.000 df_col.py:53(&lt;dictcomp&gt;)
…
</code></pre></div>
</div>
<p>The profiler&rsquo;s output tells us
the number of times each function or method was called,
the total time spent in those calls (which is what we care about most),
the time spent per call,
and the cumulative time spent in that call and all the things it calls.
We can see right away that the <code>dict_match</code> function
that checks the consistency of the rows in a row-oriented dataframe
is eating up a lot of time.
It&rsquo;s only called in the constructor,
but since we&rsquo;re constructing a new dataframe for each <code>filter</code> and <code>select</code>,
removing that safety check would speed things up.</p>
<p>Looking down a little further,
the <span class="ix-entry" ix-key="dictionary comprehension" markdown="1">dictionary comprehension</span> in <code>DfCol.filter</code> takes a lot of time as well.
That isn&rsquo;t surprising:
we&rsquo;re copying the values out of the columns into a temporary dictionary
for every row when we filter,
and building all those temporary dictionaries adds up to a lot of time.</p>
<h2 id="perf-summary">Section 15.5: Summary</h2>
<p><a class="fig-ref" href="../perf/#perf-concept-map">Figure 15.8</a> summarizes the key ideas introduced in this chapter.
The most important is that experiments can help us decide
how to implement key features of our software,
but the results of those experiments depend on
exactly what we measure.
Good software designers collect and analyze data all the time
to find out whether one website design works better than another <span class="bib-ref">[<a class="bib-ref" href="../bib/#Kohavi2020">Kohavi2020</a>]</span>
or to improve the performance of CPUs <span class="bib-ref">[<a class="bib-ref" href="../bib/#Patterson2017">Patterson2017</a>]</span>.
A few simple experiments like these can save weeks or months of misguided effort.</p>
<figure id="perf-concept-map" class="here">
<img src="./concept_map.svg" alt="Concept map for dataframes"/>
<figcaption markdown="1">Figure 15.8: Concepts for dataframes.</figcaption>
</figure>

<h2 id="perf-exercises">Section 15.6: Exercises</h2>
<h3 class="exercise">More Efficient Filtering</h3>
<p>Derive a class from <code>DfCol</code> and override its <code>filter</code> method
so that the user-defined filtering functions take zero or more columns
and a row index called <code>i_row</code> as parameters
and return <code>True</code> or <code>False</code> to signal whether the row passes the test.</p>
<ol>
<li>
<p>How much faster does this make filtering?</p>
</li>
<li>
<p>When would it be useful for filtering functions
    to take no column at all as parameters?</p>
</li>
</ol>
<h3 class="exercise">Empty Dataframes</h3>
<p>An empty dataframe is as reasonable and as useful as an empty string or an empty list.
<code>DfCol</code> can represent this,
but <code>DfRow</code> cannot:
if the list of dictionaries is empty,
we cannot ask for column names.
Derive another dataframe class from <code>DF</code> that uses row-wise storage
but can represent a dataframe with no rows.</p>
<h3 class="exercise">Unified Constructors</h3>
<p>Modify the constructors of <code>DfRow</code> and <code>DfCol</code> to have the same signatures.
Where and why might this be useful?</p>
<h3 class="exercise">Fixture Functions</h3>
<p>Read the documentation for the <code>@fixture</code> <span class="ix-entry" ix-key="decorator" markdown="1">decorator</span> in <a href="https://docs.pytest.org/">pytest</a>
and modify the tests in this chapter to use it.</p>
<h3 class="exercise">Using Arrays</h3>
<p>Derive another dataframe class from <code>DF</code>
that uses Python&rsquo;s <a href="https://docs.python.org/3/library/array.html"><code>array</code></a> module for column-wise storage.
How does it perform compared to other implementations?</p>
<h3 class="exercise">Crossover</h3>
<ol>
<li>
<p>At what ratio of filter operations to select operations
    are <code>DfRow</code> and <code>DfCol</code> equally fast?
    (Your answer may depend on the size of the dataframe.)</p>
</li>
<li>
<p>How does the relative performance of the two classes change
    if tables have a fixed number of columns (such as 10 or 20)
    but an increasing numbers of rows?
    Is this scenario more realistic?</p>
</li>
</ol>
<h3 class="exercise">Conversion</h3>
<p>Write a function to convert a <code>DfRow</code> into a <code>DfCol</code>
and another to do the opposite.
Which one is faster?
How does the difference in performance depend on
the size and shape of the dataframes being converted?</p>
<h3 class="exercise">Filtering by Strings</h3>
<p>Modify the comparison of filter and select to work with tables
that contain columns of strings instead of columns of numbers
and see how that changes performance.
For testing,
create random 4-letter strings using the characters A-Z
and then filter by:</p>
<ul>
<li>an exact match,</li>
<li>strings starting with a specific character, and</li>
<li>strings that contain a specific character.</li>
</ul>
<h3 class="exercise">Inspection</h3>
<p>Rewrite <code>DfCol.filter</code> using Python&rsquo;s <a href="https://docs.python.org/3/library/inspect.html"><code>inspect</code></a> module
so that users&rsquo; filtering functions
only need to define parameters for the columns of interest.</p>
<h3 class="exercise">Join Performance</h3>
<p>A <span class="ix-entry" ix-key="join" markdown="1">join</span> combines data from two tables based on matching keys.
For example,
if the two tables are:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Left</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>a1</td>
</tr>
<tr>
<td>B</td>
<td>b1</td>
</tr>
<tr>
<td>C</td>
<td>c1</td>
</tr>
</tbody>
</table>
<p class="continue">and:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Right</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>a2</td>
</tr>
<tr>
<td>A</td>
<td>a3</td>
</tr>
<tr>
<td>B</td>
<td>b2</td>
</tr>
</tbody>
</table>
<p class="continue">then the join is:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Left</th>
<th>Right</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>a1</td>
<td>a2</td>
</tr>
<tr>
<td>A</td>
<td>a1</td>
<td>a3</td>
</tr>
<tr>
<td>B</td>
<td>b1</td>
<td>b2</td>
</tr>
</tbody>
</table>
<p>Write a test to compare the performance of row-wise vs. column-wise storage
when joining two tables based on matching numeric keys.
Does the answer depend on the fraction of keys that match?</p>
<h3 class="exercise">Join Optimization</h3>
<p>The simplest way to <a class="gl-ref" href="../glossary/#gl:join" title="An operation that combines two tables, typically by matching keys from one with keys from another." markdown="1">join</a> two tables is
to look for matching keys using a double loop.
An alternative is to build an <a class="gl-ref" href="../glossary/#gl:index_database" title="An auxiliary data structure in a database used to speed up search for some entries. An index increases memory and disk requirements but reduces search time." markdown="1">index</a> for each table
and then use it to construct matches.
For example, suppose the tables are:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Left</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>a1</td>
</tr>
<tr>
<td>B</td>
<td>b1</td>
</tr>
<tr>
<td>C</td>
<td>c1</td>
</tr>
</tbody>
</table>
<p class="continue">and:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Right</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>a2</td>
</tr>
<tr>
<td>A</td>
<td>a3</td>
</tr>
<tr>
<td>B</td>
<td>b2</td>
</tr>
</tbody>
</table>
<p>The first step is to create a <code>Map</code> showing where each key is found in the first table:</p>
<div class="highlight"><pre><span></span><code><span class="p">{</span><span class="nx">A</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="mf">0</span><span class="p">],</span><span class="w"> </span><span class="nx">B</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="mf">1</span><span class="p">],</span><span class="w"> </span><span class="nx">C</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="mf">2</span><span class="p">]}</span>
</code></pre></div>
<p class="continue">The second step is to create a similar <code>Map</code> for the second table:</p>
<div class="highlight"><pre><span></span><code><span class="p">{</span><span class="nx">A</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">],</span><span class="w"> </span><span class="nx">B</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="mf">2</span><span class="p">]}</span>
</code></pre></div>
<p class="continue">We can then loop over the keys in one of the maps,
look up values in the second map,
and construct all of the matches.</p>
<p>Write a function that joins two tables this way.
Is it faster or slower than using a double loop?
How does the answer depend on the number of keys and the fraction that match?</p>
        </main>
      </div>
    </div>
  </body>
</html>
