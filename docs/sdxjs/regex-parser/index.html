<!DOCTYPE html>
<html lang="en">
  <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="../favicon.ico">
  <link rel="stylesheet" href="../mccole.css">
  <link rel="stylesheet" href="../tango.css">
  <script defer data-domain="third-bit.com" src="https://plausible.io/js/plausible.js"></script>
  <script>
    MathJax = {
      tex: {
        inlineMath: [['\\(', '\\)']]
      }
    };
  </script>
  <script
    type="text/javascript"
    id="MathJax-script"
    async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
  <script defer src="../mccole.js"></script>
  <title>Software Design by Example: Parsing Expressions</title>
</head>

  <body>
    <div class="row">
      <div class="sidebar">
        <p>
  
  <a href="https://www.taylorfrancis.com/books/mono/10.1201/9781003317807/software-design-example-greg-wilson"><img src="../sdxjs-cover.png" alt="Book cover" width="80%" /></a>
  
</p>
<ol class="toc-chapter">
  
  <li>
    <a href="../introduction/">
      Introduction
    </a>
  </li>
  
  <li>
    <a href="../systems-programming/">
      Systems Programming
    </a>
  </li>
  
  <li>
    <a href="../async-programming/">
      Asynchronous Programming
    </a>
  </li>
  
  <li>
    <a href="../unit-test/">
      Unit Testing
    </a>
  </li>
  
  <li>
    <a href="../file-backup/">
      File Backup
    </a>
  </li>
  
  <li>
    <a href="../data-table/">
      Data Tables
    </a>
  </li>
  
  <li>
    <a href="../pattern-matching/">
      Pattern Matching
    </a>
  </li>
  
  <li>
    <a href="../regex-parser/">
      <strong>Parsing Expressions</strong>
    </a>
  </li>
  
  <li>
    <a href="../page-templates/">
      Page Templates
    </a>
  </li>
  
  <li>
    <a href="../build-manager/">
      Build Manager
    </a>
  </li>
  
  <li>
    <a href="../layout-engine/">
      Layout Engine
    </a>
  </li>
  
  <li>
    <a href="../file-interpolator/">
      File Interpolator
    </a>
  </li>
  
  <li>
    <a href="../module-loader/">
      Module Loader
    </a>
  </li>
  
  <li>
    <a href="../style-checker/">
      Style Checker
    </a>
  </li>
  
  <li>
    <a href="../code-generator/">
      Code Generator
    </a>
  </li>
  
  <li>
    <a href="../doc-generator/">
      Documentation Generator
    </a>
  </li>
  
  <li>
    <a href="../module-bundler/">
      Module Bundler
    </a>
  </li>
  
  <li>
    <a href="../package-manager/">
      Package Manager
    </a>
  </li>
  
  <li>
    <a href="../virtual-machine/">
      Virtual Machine
    </a>
  </li>
  
  <li>
    <a href="../debugger/">
      Debugger
    </a>
  </li>
  
  <li>
    <a href="../conclusion/">
      Conclusion
    </a>
  </li>
  
</ol>
<ol class="toc-appendix">
  
  <li>
    <a href="../license/">
      License
    </a>
  </li>
  
  <li>
    <a href="../conduct/">
      Code of Conduct
    </a>
  </li>
  
  <li>
    <a href="../contributing/">
      Contributing
    </a>
  </li>
  
  <li>
    <a href="../bibliography/">
      Bibliography
    </a>
  </li>
  
  <li>
    <a href="../glossary/">
      Glossary
    </a>
  </li>
  
  <li>
    <a href="../contents/">
      Index
    </a>
  </li>
  
</ol>

<p><a href="../sdxjs-examples.zip" type="application/zip" alt="examples">download examples</a></p>


      </div>
      <div id="printable" class="contents bordered">
        <main>
          
  <h1>Chapter 8: Parsing Expressions</h1>


          
            

            

            
<p class="definitions">
  Terms defined: <a class="gl-ref" href="../glossary/#fsm" markdown="1">finite state machine</a>, <a class="gl-ref" href="../glossary/#literal" markdown="1">literal</a>, <a class="gl-ref" href="../glossary/#parser" markdown="1">parser</a>, <a class="gl-ref" href="../glossary/#precedence" markdown="1">precedence</a>, <a class="gl-ref" href="../glossary/#token" markdown="1">token</a>, <a class="gl-ref" href="../glossary/#turing_machine" markdown="1">Turing Machine</a>, <a class="gl-ref" href="../glossary/#well_formed" markdown="1">well formed</a>, <a class="gl-ref" href="../glossary/#yaml" markdown="1">YAML</a>
</p>


            <div class="page-toc"></div>
            <p>In <a class="x-ref" href="../pattern-matching/">Chapter 7</a> we created regular expressions by constructing objects.
It takes a lot less typing to write them as strings as we did for HTML selectors,
but if we&rsquo;re going to do that we need something to convert those strings to the required objects.
In other words, we need to write a <span class="ix-entry" ix-key="parser" markdown="1"><a class="gl-ref" href="../glossary/#parser" markdown="1">parser</a></span>.</p>
<div class="table"><table id="regex-parser-grammar-codes" class="table-here"><caption>Table 8.1: Regular expression grammar.</caption>
<thead>
<tr>
<th>Meaning</th>
<th>Character</th>
</tr>
</thead>
<tbody>
<tr>
<td>Any literal character <em>c</em></td>
<td><em>c</em></td>
</tr>
<tr>
<td>Beginning of input</td>
<td>^</td>
</tr>
<tr>
<td>End of input</td>
<td>$</td>
</tr>
<tr>
<td>Zero or more of the previous thing</td>
<td>*</td>
</tr>
<tr>
<td>Either/or</td>
<td>|</td>
</tr>
<tr>
<td>Grouping</td>
<td>(â€¦)</td>
</tr>
</tbody>
</table>
</div>
<p><a class="tbl-ref" href="../regex-parser/#regex-parser-grammar-codes">Table 8.1</a> shows the grammar we will handle.
When we are done
we should be able to parse <code>/^(a|b|$)*z$/</code> as
&ldquo;start of text&rdquo;,
&ldquo;any number of &lsquo;a&rsquo;, &lsquo;b&rsquo;, or &lsquo;$&rsquo;&ldquo;,
&ldquo;a single &lsquo;z&rsquo;,
and &ldquo;end of text&rdquo;.
(We write regular expressions inside slashes to distinguish them from strings.)
To keep things simple,
we will create a tree of objects (<a class="fig-ref" href="../regex-parser/#regex-parser-expression-tree">Figure 8.1</a>)
rather than instances of the regular expression classes from <a class="x-ref" href="../pattern-matching/">Chapter 7</a>;
the exercises will tackle the latter.</p>
<figure id="regex-parser-expression-tree">
  <img src="./expression-tree.svg" alt="Expression tree for regular expression"/>
  <figcaption markdown="1">Figure 8.1: Representing the result of parsing a regular expression as an tree.</figcaption>
</figure>

<div class="callout">
<h3>Please don&rsquo;t write parsers</h3>
<p>Languages that are comfortable for people to read are usually difficult for computers to understand
and vice versa,
so we need parsers to translate human-friendly notation into computer-friendly representations.
However,
<span class="ix-entry" ix-key="parser!reasons not to write" markdown="1">the world doesn&rsquo;t need more file formats</span>;
if you need a configuration file or lookup table,
please use CSV, JSON, <a class="gl-ref" href="../glossary/#yaml" markdown="1">YAML</a>,
or something else that already has an acronym
rather than inventing a format of your own.</p>
</div>
<h2 id="regex-parser-tokenize">Section 8.2: How can we break text into tokens?</h2>
<p>A <span class="ix-entry" ix-key="token (in parsing)" markdown="1"><a class="gl-ref" href="../glossary/#token" markdown="1">token</a></span> is an atom of text,
such as the digits making up a number or the letters making up a variable name.
In our grammar the tokens are the special characters <code>*</code>, <code>|</code>, <code>(</code>, <code>)</code>, <code>^</code>, and <code>$</code>,
plus any sequence of one or more other characters (which count as one multi-letter token).
This classification guides the design of our parser:</p>
<ol>
<li>
<p>If a character is special, create a token for it.</p>
</li>
<li>
<p>If it is a <span class="ix-entry" ix-key="literal (in parsing)" markdown="1"><a class="gl-ref" href="../glossary/#literal" markdown="1">literal</a></span> then
    combine it with the current literal if there is one
    or start a new literal.</p>
</li>
<li>
<p>Since <code>^</code> and <code>$</code> are either special or regular depending on position,
    we must treat them as separate tokens or as part of a literal
    based on where they appear.</p>
</li>
</ol>
<p>We can translate these rules almost directly into code
to create a list of objects whose keys are <code>kind</code> and <code>loc</code> (short for location),
with the extra key <code>value</code> for literal values:</p>
<div class="code-sample lang-js" title="tokenizer-collapse.js">
<div class="highlight"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="nx">SIMPLE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="s1">&#39;*&#39;</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Any&#39;</span><span class="p">,</span>
<span class="w">  </span><span class="s1">&#39;|&#39;</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Alt&#39;</span><span class="p">,</span>
<span class="w">  </span><span class="s1">&#39;(&#39;</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;GroupStart&#39;</span><span class="p">,</span>
<span class="w">  </span><span class="s1">&#39;)&#39;</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;GroupEnd&#39;</span>
<span class="p">}</span>

<span class="kd">const</span><span class="w"> </span><span class="nx">tokenize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">text</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">let</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">text</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">text</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">c</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nx">SIMPLE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="nx">SIMPLE</span><span class="p">[</span><span class="nx">c</span><span class="p">],</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">})</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">c</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">&#39;^&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">i</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Start&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">})</span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">combineOrPush</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span><span class="w"> </span><span class="nx">c</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="p">)</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">c</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">&#39;$&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">i</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="p">(</span><span class="nx">text</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;End&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">})</span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">combineOrPush</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span><span class="w"> </span><span class="nx">c</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="p">)</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">combineOrPush</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span><span class="w"> </span><span class="nx">c</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">result</span>
<span class="p">}</span>


<span class="k">export</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="nx">tokenize</span>
</code></pre></div>
</div>
<p>The helper function <code>combineOrPush</code> does exactly what its name says.
If the thing most recently added to the list of tokens isn&rsquo;t a literal,
the new character becomes a new token;
otherwise,
we append the new character to the literal we&rsquo;re building:</p>
<div class="code-sample lang-js" title="tokenizer-collapse.js">
<div class="highlight"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="nx">combineOrPush</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">soFar</span><span class="p">,</span><span class="w"> </span><span class="nx">character</span><span class="p">,</span><span class="w"> </span><span class="nx">location</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">topIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">soFar</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="nx">soFar</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="nx">soFar</span><span class="p">[</span><span class="nx">topIndex</span><span class="p">].</span><span class="nx">token</span><span class="w"> </span><span class="o">!==</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">soFar</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="nx">character</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="nx">location</span><span class="w"> </span><span class="p">})</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">soFar</span><span class="p">[</span><span class="nx">topIndex</span><span class="p">].</span><span class="nx">value</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nx">character</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
</div>
<p>We can try this out with a three-line test program:</p>
<div class="code-sample lang-js" title="tokenizer-collapse-example.js">
<div class="highlight"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">tokenize</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;./tokenizer-collapse.js&#39;</span>

<span class="kd">const</span><span class="w"> </span><span class="nx">test</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;^a^b*&#39;</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">tokenize</span><span class="p">(</span><span class="nx">test</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span><span class="w"> </span><span class="kc">null</span><span class="p">,</span><span class="w"> </span><span class="mf">2</span><span class="p">))</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="tokenizer-collapse-example.out">
<div class="highlight"><pre><span></span><code>[
  {
    &quot;kind&quot;: &quot;Start&quot;,
    &quot;loc&quot;: 0
  },
  {
    &quot;kind&quot;: &quot;Lit&quot;,
    &quot;value&quot;: &quot;a&quot;,
    &quot;loc&quot;: 1
  },
  {
    &quot;kind&quot;: &quot;Lit&quot;,
    &quot;value&quot;: &quot;^&quot;,
    &quot;loc&quot;: 2
  },
  {
    &quot;kind&quot;: &quot;Lit&quot;,
    &quot;value&quot;: &quot;b&quot;,
    &quot;loc&quot;: 3
  },
  {
    &quot;kind&quot;: &quot;Any&quot;,
    &quot;loc&quot;: 4
  }
]
</code></pre></div>
</div>
<p>This simple tokenizer is readable, efficient, and wrong.
The problem is that the expression <code>/ab*/</code> means &ldquo;a single <code>a</code> followed by zero or more <code>b</code>&rdquo;.
If we combine the <code>a</code> and <code>b</code> as we read them,
though,
we wind up with &ldquo;zero or more repetitions of <code>ab</code>&rdquo;.
(Don&rsquo;t feel bad if you didn&rsquo;t spot this:
we didn&rsquo;t notice the problem until we were implementing the next step.)</p>
<p>The solution is to treat each regular character as its own literal in this stage
and then combine things later.
Doing this lets us get rid of the nested <code>if</code> for handling <code>^</code> and <code>$</code> as well:</p>
<div class="code-sample lang-js" title="tokenizer.js">
<div class="highlight"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="nx">SIMPLE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="s1">&#39;*&#39;</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Any&#39;</span><span class="p">,</span>
<span class="w">  </span><span class="s1">&#39;|&#39;</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Alt&#39;</span><span class="p">,</span>
<span class="w">  </span><span class="s1">&#39;(&#39;</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;GroupStart&#39;</span><span class="p">,</span>
<span class="w">  </span><span class="s1">&#39;)&#39;</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;GroupEnd&#39;</span>
<span class="p">}</span>

<span class="kd">const</span><span class="w"> </span><span class="nx">tokenize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">text</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">let</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">text</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">text</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">c</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nx">SIMPLE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="nx">SIMPLE</span><span class="p">[</span><span class="nx">c</span><span class="p">],</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">})</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="nx">c</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">&#39;^&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="nx">i</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mf">0</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Start&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">})</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="nx">c</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">&#39;$&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="nx">i</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="p">(</span><span class="nx">text</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;End&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">})</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="p">})</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">result</span>
<span class="p">}</span>

<span class="k">export</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="nx">tokenize</span>
</code></pre></div>
</div>
<p>Software isn&rsquo;t done until it&rsquo;s tested,
so let&rsquo;s build some <span class="ix-entry" ix-key="Mocha" markdown="1"><a href="https://mochajs.org/">Mocha</a></span> tests for our tokenizer.
The listing below shows a few of these
along with the output for the full set:</p>
<div class="code-sample lang-js" title="test-tokenizer.js">
<div class="highlight"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">assert</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;assert&#39;</span>

<span class="k">import</span><span class="w"> </span><span class="nx">tokenize</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;../tokenizer.js&#39;</span>

<span class="nx">describe</span><span class="p">(</span><span class="s1">&#39;tokenizes correctly&#39;</span><span class="p">,</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">it</span><span class="p">(</span><span class="s1">&#39;tokenizes a single character&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">assert</span><span class="p">.</span><span class="nx">deepStrictEqual</span><span class="p">(</span><span class="nx">tokenize</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">),</span><span class="w"> </span><span class="p">[</span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="p">])</span>
<span class="w">  </span><span class="p">})</span>

<span class="w">  </span><span class="nx">it</span><span class="p">(</span><span class="s1">&#39;tokenizes a sequence of characters&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">assert</span><span class="p">.</span><span class="nx">deepStrictEqual</span><span class="p">(</span><span class="nx">tokenize</span><span class="p">(</span><span class="s1">&#39;ab&#39;</span><span class="p">),</span><span class="w"> </span><span class="p">[</span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="p">},</span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="p">])</span>
<span class="w">  </span><span class="p">})</span>

<span class="w">  </span><span class="nx">it</span><span class="p">(</span><span class="s1">&#39;tokenizes start anchor alone&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">assert</span><span class="p">.</span><span class="nx">deepStrictEqual</span><span class="p">(</span><span class="nx">tokenize</span><span class="p">(</span><span class="s1">&#39;^&#39;</span><span class="p">),</span><span class="w"> </span><span class="p">[</span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Start&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="p">])</span>
<span class="w">  </span><span class="p">})</span>

<span class="w">  </span><span class="nx">it</span><span class="p">(</span><span class="s1">&#39;tokenizes start anchor followed by characters&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">assert</span><span class="p">.</span><span class="nx">deepStrictEqual</span><span class="p">(</span><span class="nx">tokenize</span><span class="p">(</span><span class="s1">&#39;^a&#39;</span><span class="p">),</span><span class="w"> </span><span class="p">[</span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Start&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="p">},</span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="p">])</span>
<span class="w">  </span><span class="p">})</span>

<span class="w">  </span><span class="nx">it</span><span class="p">(</span><span class="s1">&#39;tokenizes a complex expression&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">assert</span><span class="p">.</span><span class="nx">deepStrictEqual</span><span class="p">(</span><span class="nx">tokenize</span><span class="p">(</span><span class="s1">&#39;^a*(bcd|e^)*f$gh$&#39;</span><span class="p">),</span><span class="w"> </span><span class="p">[</span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Start&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="p">},</span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;a&#39;</span><span class="w"> </span><span class="p">},</span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Any&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">2</span><span class="w"> </span><span class="p">},</span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;GroupStart&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">3</span><span class="w"> </span><span class="p">},</span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">4</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;b&#39;</span><span class="w"> </span><span class="p">},</span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">5</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;c&#39;</span><span class="w"> </span><span class="p">},</span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">6</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;d&#39;</span><span class="w"> </span><span class="p">},</span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Alt&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">7</span><span class="w"> </span><span class="p">},</span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">8</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;e&#39;</span><span class="w"> </span><span class="p">},</span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">9</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;^&#39;</span><span class="w"> </span><span class="p">},</span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;GroupEnd&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">10</span><span class="w"> </span><span class="p">},</span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Any&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">11</span><span class="w"> </span><span class="p">},</span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">12</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;f&#39;</span><span class="w"> </span><span class="p">},</span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">13</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;$&#39;</span><span class="w"> </span><span class="p">},</span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">14</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;g&#39;</span><span class="w"> </span><span class="p">},</span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">15</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;h&#39;</span><span class="w"> </span><span class="p">},</span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;End&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">16</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="p">])</span>
<span class="w">  </span><span class="p">})</span>
<span class="p">})</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="tokenizer-test.out">
<div class="highlight"><pre><span></span><code>&gt; stjs@1.0.0 test /u/stjs
&gt; mocha */test/test-*.js &quot;-g&quot; &quot;tokenizes correctly&quot;



  tokenizes correctly
    âœ“ tokenizes a single character
    âœ“ tokenizes a sequence of characters
    âœ“ tokenizes start anchor alone
    âœ“ tokenizes start anchor followed by characters
    âœ“ tokenizes circumflex not at start
    âœ“ tokenizes start anchor alone
    âœ“ tokenizes end anchor preceded by characters
    âœ“ tokenizes dollar sign not at end
    âœ“ tokenizes repetition alone
    âœ“ tokenizes repetition in string
    âœ“ tokenizes repetition at end of string
    âœ“ tokenizes alternation alone
    âœ“ tokenizes alternation in string
    âœ“ tokenizes alternation at start of string
    âœ“ tokenizes the start of a group alone
    âœ“ tokenizes the start of a group in a string
    âœ“ tokenizes the end of a group alone
    âœ“ tokenizes the end of a group at the end of a string
    âœ“ tokenizes a complex expression


  19 passing (12ms)
</code></pre></div>
</div>
<h2 id="regex-parser-tree">Section 8.3: How can we turn a list of tokens into a tree?</h2>
<p>We now have a list of tokens,
but we need a tree that captures the nesting introduced by parentheses
and the way that <code>*</code> applies to whatever comes before it.
Let&rsquo;s trace a few cases in order to see how to build this tree:</p>
<ol>
<li>
<p>If the regular expression is <code>/a/</code>, we create a <code>Lit</code> token for the letter <code>a</code>
    (where &ldquo;create&rdquo; means &ldquo;append to the output list&rdquo;).</p>
</li>
<li>
<p>What if the regular expression is <code>/a*/</code>?
    We first create a <code>Lit</code> token for the <code>a</code> and append it to the output list.
    When we see the <code>*</code>,
    we take that <code>Lit</code> token off the tail of the output list
    and replace it with an <code>Any</code> token that has the <code>Lit</code> token as its child.</p>
</li>
<li>
<p>Our next thought experiment is <code>/(ab)/</code>.
    We don&rsquo;t know how long the group is going to be when we see the <code>(</code>,
    so we put the parenthesis onto the output as a marker.
    We then add the <code>Lit</code> tokens for the <code>a</code> and <code>b</code>
    until we see the <code>)</code>,
    at which point we pull tokens off the end of the output list
    until we get back to the <code>(</code> marker.
    When we find it,
    we put everything we have temporarily collected into a <code>Group</code> token and append it to the output list.
    This algorithm automatically handles <code>/(a*)/</code> and <code>/(a(b*)c)/</code>.</p>
</li>
<li>
<p>What about <code>/a|b/</code>?
    We append a <code>Lit</code> token for <code>a</code>, get the <code>|</code> and&mdash;and we&rsquo;re stuck,
    because we don&rsquo;t yet have the next token we need to finish building the <code>Alt</code>.</p>
</li>
</ol>
<p class="continue">One way to solve this problem is to check if the thing on the top of the stack is waiting to combine
each time we append a new token.
However,
this doesn&rsquo;t handle <code>/a|b*/</code> properly.
The pattern is supposed to mean &ldquo;one <code>a</code> or any number of <code>b</code>&rdquo;,
but the <span class="ix-entry" ix-key="parser!check-and-combine" markdown="1">check-and-combine strategy</span> will turn it into the equivalent of <code>/(a|b)*/</code>.</p>
<p>A better (i.e., correct) solution is
to leave some partially-completed tokens in the output and <span class="ix-entry" ix-key="parser!post-hoc compression strategy" markdown="1">compress</span> them later
(<a class="fig-ref" href="../regex-parser/#regex-parser-mechanics">Figure 8.2</a>).
If our input is the pattern <code>/a|b/</code>, we can:</p>
<ol>
<li>
<p>Append a <code>Lit</code> token for <code>a</code>.</p>
</li>
<li>
<p>When we see <code>|</code>,
    make that <code>Lit</code> token the left child of the <code>Alt</code>
    and append that without filling in the right child.</p>
</li>
<li>
<p>Append the <code>Lit</code> token for <code>b</code>.</p>
</li>
<li>
<p>After all tokens have been handled,
    look for partially-completed <code>Alt</code> tokens and make whatever comes after them their right child.</p>
</li>
</ol>
<p class="continue">Again, this automatically handles patterns like <code>/(ab)|c*|(de)/</code>.</p>
<figure id="regex-parser-mechanics">
  <img src="./mechanics.svg" alt="Mechanics of combining tokens"/>
  <figcaption markdown="1">Figure 8.2: Mechanics of combining tokens while parsing regular expressions.</figcaption>
</figure>

<p>It&rsquo;s time to turn these ideas into code.
The main structure of our parser is:</p>
<div class="code-sample lang-js" title="parser.js">
<div class="highlight"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">assert</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;assert&#39;</span>

<span class="k">import</span><span class="w"> </span><span class="nx">tokenize</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;./tokenizer.js&#39;</span>

<span class="kd">const</span><span class="w"> </span><span class="nx">parse</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">text</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">allTokens</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">tokenize</span><span class="p">(</span><span class="nx">text</span><span class="p">)</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">let</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">allTokens</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">allTokens</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">last</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="nx">allTokens</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1</span>
<span class="w">    </span><span class="nx">handle</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span><span class="w"> </span><span class="nx">token</span><span class="p">,</span><span class="w"> </span><span class="nx">last</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">compress</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>
<span class="p">}</span>


<span class="k">export</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="nx">parse</span>
</code></pre></div>
</div>
<p>We handle tokens case-by-case
(with a few assertions to check that patterns are <a class="gl-ref" href="../glossary/#well_formed" markdown="1">well formed</a>):</p>
<div class="code-sample lang-js" title="parser.js">
<div class="highlight"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="nx">handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">result</span><span class="p">,</span><span class="w"> </span><span class="nx">token</span><span class="p">,</span><span class="w"> </span><span class="nx">last</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">token</span><span class="p">.</span><span class="nx">kind</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">token</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">token</span><span class="p">.</span><span class="nx">kind</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">&#39;Start&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">assert</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span>
<span class="w">      </span><span class="s1">&#39;Should not have start token after other tokens&#39;</span><span class="p">)</span>
<span class="w">    </span><span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">token</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">token</span><span class="p">.</span><span class="nx">kind</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">&#39;End&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">assert</span><span class="p">(</span><span class="nx">last</span><span class="p">,</span>
<span class="w">      </span><span class="s1">&#39;Should not have end token before other tokens&#39;</span><span class="p">)</span>
<span class="w">    </span><span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">token</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">token</span><span class="p">.</span><span class="nx">kind</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">&#39;GroupStart&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">token</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">token</span><span class="p">.</span><span class="nx">kind</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">&#39;GroupEnd&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">groupEnd</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span><span class="w"> </span><span class="nx">token</span><span class="p">))</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">token</span><span class="p">.</span><span class="nx">kind</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">&#39;Any&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">assert</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span>
<span class="w">      </span><span class="sb">`No operand for &#39;*&#39; (location </span><span class="si">${</span><span class="nx">token</span><span class="p">.</span><span class="nx">loc</span><span class="si">}</span><span class="sb">)`</span><span class="p">)</span>
<span class="w">    </span><span class="nx">token</span><span class="p">.</span><span class="nx">child</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">result</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span>
<span class="w">    </span><span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">token</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">token</span><span class="p">.</span><span class="nx">kind</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">&#39;Alt&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">assert</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span>
<span class="w">      </span><span class="sb">`No operand for &#39;*&#39; (location </span><span class="si">${</span><span class="nx">token</span><span class="p">.</span><span class="nx">loc</span><span class="si">}</span><span class="sb">)`</span><span class="p">)</span>
<span class="w">    </span><span class="nx">token</span><span class="p">.</span><span class="nx">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">result</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span>
<span class="w">    </span><span class="nx">token</span><span class="p">.</span><span class="nx">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span>
<span class="w">    </span><span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">token</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">assert</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;UNIMPLEMENTED&#39;</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
</div>
<p>When we find the <code>)</code> that marks the end of a group,
we take items from the end of the output list
until we find the matching start
and use them to create a group:</p>
<div class="code-sample lang-js" title="parser.js">
<div class="highlight"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="nx">groupEnd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">result</span><span class="p">,</span><span class="w"> </span><span class="nx">token</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">group</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Group&#39;</span><span class="p">,</span>
<span class="w">    </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="kc">null</span><span class="p">,</span>
<span class="w">    </span><span class="nx">end</span><span class="o">:</span><span class="w"> </span><span class="nx">token</span><span class="p">.</span><span class="nx">loc</span><span class="p">,</span>
<span class="w">    </span><span class="nx">children</span><span class="o">:</span><span class="w"> </span><span class="p">[]</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">assert</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span>
<span class="w">           </span><span class="sb">`Unmatched end parenthesis (location </span><span class="si">${</span><span class="nx">token</span><span class="p">.</span><span class="nx">loc</span><span class="si">}</span><span class="sb">)`</span><span class="p">)</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">child</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">result</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">child</span><span class="p">.</span><span class="nx">kind</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">&#39;GroupStart&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">group</span><span class="p">.</span><span class="nx">loc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">child</span><span class="p">.</span><span class="nx">loc</span>
<span class="w">      </span><span class="k">break</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">group</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">unshift</span><span class="p">(</span><span class="nx">child</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">group</span>
<span class="p">}</span>
</code></pre></div>
</div>
<p>Finally,
when we have finished with the input,
we go through the output list one last time to fill in the right side of <code>Alt</code>s:</p>
<div class="code-sample lang-js" title="parser.js">
<div class="highlight"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="nx">compress</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">raw</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">cooked</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="nx">raw</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">raw</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">token</span><span class="p">.</span><span class="nx">kind</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">&#39;Alt&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">assert</span><span class="p">(</span><span class="nx">cooked</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span>
<span class="w">             </span><span class="sb">`No right operand for alt (location </span><span class="si">${</span><span class="nx">token</span><span class="p">.</span><span class="nx">loc</span><span class="si">}</span><span class="sb">)`</span><span class="p">)</span>
<span class="w">      </span><span class="nx">token</span><span class="p">.</span><span class="nx">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">cooked</span><span class="p">.</span><span class="nx">shift</span><span class="p">()</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">cooked</span><span class="p">.</span><span class="nx">unshift</span><span class="p">(</span><span class="nx">token</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">cooked</span>
<span class="p">}</span>
</code></pre></div>
</div>
<p>Once again,
it&rsquo;s not done until we&rsquo;ve tested it:</p>
<div class="code-sample lang-js" title="test-parser.js">
<div class="highlight"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">assert</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;assert&#39;</span>

<span class="k">import</span><span class="w"> </span><span class="nx">parse</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;../parser.js&#39;</span>

<span class="nx">describe</span><span class="p">(</span><span class="s1">&#39;parses correctly&#39;</span><span class="p">,</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">it</span><span class="p">(</span><span class="s1">&#39;parses the empty string&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">assert</span><span class="p">.</span><span class="nx">deepStrictEqual</span><span class="p">(</span><span class="nx">parse</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">),</span><span class="w"> </span><span class="p">[])</span>
<span class="w">  </span><span class="p">})</span>

<span class="w">  </span><span class="nx">it</span><span class="p">(</span><span class="s1">&#39;parses a single literal&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">assert</span><span class="p">.</span><span class="nx">deepStrictEqual</span><span class="p">(</span><span class="nx">parse</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">),</span><span class="w"> </span><span class="p">[</span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;a&#39;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="p">])</span>
<span class="w">  </span><span class="p">})</span>

<span class="w">  </span><span class="nx">it</span><span class="p">(</span><span class="s1">&#39;parses multiple literals&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">assert</span><span class="p">.</span><span class="nx">deepStrictEqual</span><span class="p">(</span><span class="nx">parse</span><span class="p">(</span><span class="s1">&#39;ab&#39;</span><span class="p">),</span><span class="w"> </span><span class="p">[</span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;a&#39;</span><span class="w"> </span><span class="p">},</span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;b&#39;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="p">])</span>
<span class="w">  </span><span class="p">})</span>


<span class="w">  </span><span class="nx">it</span><span class="p">(</span><span class="s1">&#39;parses alt of groups&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">assert</span><span class="p">.</span><span class="nx">deepStrictEqual</span><span class="p">(</span><span class="nx">parse</span><span class="p">(</span><span class="s1">&#39;a|(bc)&#39;</span><span class="p">),</span><span class="w"> </span><span class="p">[</span>
<span class="w">      </span><span class="p">{</span>
<span class="w">        </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Alt&#39;</span><span class="p">,</span>
<span class="w">        </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span>
<span class="w">        </span><span class="nx">left</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;a&#39;</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="nx">right</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Group&#39;</span><span class="p">,</span>
<span class="w">          </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">2</span><span class="p">,</span>
<span class="w">          </span><span class="nx">end</span><span class="o">:</span><span class="w"> </span><span class="mf">5</span><span class="p">,</span>
<span class="w">          </span><span class="nx">children</span><span class="o">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">            </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">3</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;b&#39;</span><span class="w"> </span><span class="p">},</span>
<span class="w">            </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">4</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;c&#39;</span><span class="w"> </span><span class="p">}</span>
<span class="w">          </span><span class="p">]</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">])</span>
<span class="w">  </span><span class="p">})</span>
<span class="p">})</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="parser-test.out">
<div class="highlight"><pre><span></span><code>&gt; stjs@1.0.0 test /u/stjs
&gt; mocha */test/test-*.js &quot;-g&quot; &quot;parses correctly&quot;



  parses correctly
    âœ“ parses the empty string
    âœ“ parses a single literal
    âœ“ parses multiple literals
    âœ“ parses start anchors
    âœ“ handles circumflex not at start
    âœ“ parses end anchors
    âœ“ parses circumflex not at start
    âœ“ parses empty groups
    âœ“ parses groups containing characters
    âœ“ parses two groups containing characters
    âœ“ parses any
    âœ“ parses any of group
    âœ“ parses alt
    âœ“ parses alt of any
    âœ“ parses alt of groups


  15 passing (11ms)
</code></pre></div>
</div>
<p>While our final parser is less than 90 lines of code,
it is doing a lot of complex things.
Compared to parsers for things like JSON and YAML,
though,
it is still very simple.
If we have more operators with different <span class="ix-entry" ix-key="operator precedence!implementing" markdown="1"><a class="gl-ref" href="../glossary/#precedence" markdown="1">precedences</a></span>
we should switch to the <span class="ix-entry" ix-key="shunting-yard algorithm;parser!shunting-yard algorithm" markdown="1"><a href="https://en.wikipedia.org/wiki/Shunting-yard_algorithm">shunting-yard algorithm</a></span>,
and if we need to handle a language like JavaScript we should explore tools like <span class="ix-entry" ix-key="ANTLR" markdown="1"><a href="https://www.antlr.org/">ANTLR</a></span>,
which can generate a parser automatically given a description of the language to be parsed.
As we said at the start,
though,
if our design requires us to write a parser we should try to come up with a better design.
CSV, JSON, YAML, and other formats <a href="https://third-bit.com/2015/06/11/why-we-cant-have-nice-things/">have their quirks</a>,
but at least they&rsquo;re broken the same way everywhere.</p>
<div class="callout">
<h3>The limits of computing</h3>
<p>One of the most important theoretical results in computer science is that
every formal language corresponds to a type of abstract machine and vice versa,
and that some languages (or machines) are more or less powerful than others.
For example,
every regular expression corresponds to a <span class="ix-entry" ix-key="finite state machine!correspondence with regular expressions" markdown="1"><a class="gl-ref" href="../glossary/#fsm" markdown="1">finite state machine</a></span> (FSM)
like the one in <a class="fig-ref" href="../regex-parser/#regex-parser-finite-state-machine">Figure 8.3</a>.
As powerful as FSMs are,
they cannot match things like nested parentheses or HTML tags,
and <span class="ix-entry" ix-key="sin!using regular expressions to parse HTML" markdown="1"><a href="https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454">attempting to do so is a sin</a></span>.
If you add a stack to the system you can process a much richer set of languages,
and if you add two stacks you have something equivalent to a <span class="ix-entry" ix-key="Turing Machine" markdown="1"><a class="gl-ref" href="../glossary/#turing_machine" markdown="1">Turing Machine</a></span>
that can do any conceivable computation.
<span class="bib-ref">[<a class="bib-ref" href="../bibliography/#Conery2021">Conery2021</a>]</span> presents this idea and others for self-taught developers.</p>
</div>
<figure id="regex-parser-finite-state-machine">
  <img src="./finite-state-machine.svg" alt="Finite state machine"/>
  <figcaption markdown="1">Figure 8.3: A finite state machine equivalent to a regular expression.</figcaption>
</figure>

<h2 id="regex-parser-exercises">Section 8.4: Exercises</h2>
<h3 class="exercise">Create objects</h3>
<p>Modify the parser to return instances of classes derived from <code>RegexBase</code>.</p>
<h3 class="exercise">Escape characters</h3>
<p>Modify the parser to handle escape characters,
so that (for example) <code>\*</code> is interpreted as &ldquo;a literal asterisk&rdquo;
and <code>\\</code> is interpreted as &ldquo;a literal backslash&rdquo;.</p>
<h3 class="exercise">Lazy matching</h3>
<p>Modify the parser so that <code>*?</code> is interpreted as a single token
meaning &ldquo;lazy match zero or more&rdquo;.</p>
<h3 class="exercise">Character sets</h3>
<p>Modify the parser so that expressions like <code>[xyz]</code> are interpreted to mean
&ldquo;match any one of the characters x, y, or z&rdquo;.</p>
<h3 class="exercise">Back reference</h3>
<p>Modify the tokenizer so that it recognizes <code>\1</code>, <code>\2</code>, and so on to mean &ldquo;back reference&rdquo;.
The number may contain any number of digits.</p>
<h3 class="exercise">Named groups</h3>
<ol>
<li>
<p>Modify the tokenizer to recognize named groups.
    For example, the named group <code>/(?&lt;triple&gt;aaa)/</code>
    would create a named group called <code>triple</code> that matches exactly three consecutive occurrences of &lsquo;a&rsquo;.</p>
</li>
<li>
<p>Write Mocha tests for your modified tokenizer.
    Does it handle nested named groups?</p>
</li>
</ol>
<h3 class="exercise">Object streams</h3>
<p>Write a parser that turns files of key-value pairs separated by blank lines into objects.
For example, if the input is:</p>
<div class="highlight"><pre><span></span><code>left: &quot;left value&quot;
first: 1

middle: &quot;middle value&quot;
second: 2

right: &quot;right value&quot;
third: 3
</code></pre></div>
<p class="continue">then the output will be:</p>
<div class="highlight"><pre><span></span><code><span class="p">[</span>
<span class="w">  </span><span class="p">{</span><span class="nx">left</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;left value&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">first</span><span class="o">:</span><span class="w"> </span><span class="mf">1</span><span class="p">},</span>
<span class="w">  </span><span class="p">{</span><span class="nx">middle</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;middle value&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">second</span><span class="o">:</span><span class="w"> </span><span class="mf">2</span><span class="p">},</span>
<span class="w">  </span><span class="p">{</span><span class="nx">right</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;right value&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">third</span><span class="o">:</span><span class="w"> </span><span class="mf">3</span><span class="p">}</span>
<span class="p">]</span>
</code></pre></div>
<p>Keys are always upper- and lower-case characters;
values may be strings in double quotes or unquoted numbers.</p>
<h3 class="exercise">Tokenize HTML</h3>
<ol>
<li>
<p>Write a tokenizer for a subset of HTML that consists of:</p>
<ul>
<li>Opening tags without attributes, such as <code>&lt;div&gt;</code> and <code>&lt;p&gt;</code></li>
<li>Closing tags, such as <code>&lt;/p&gt;</code> and <code>&lt;/div&gt;</code></li>
<li>Plain text between tags that does <em>not</em> contain &lsquo;&lt;&rsquo; or &lsquo;&gt;&rsquo; characters</li>
</ul>
</li>
<li>
<p>Modify the tokenizer to handle <code>key="value"</code> attributes in opening tags.</p>
</li>
<li>
<p>Write Mocha tests for your tokenizer.</p>
</li>
</ol>
<h3 class="exercise">The Shunting-Yard Algorithm</h3>
<ol>
<li>
<p>Use the <a href="https://en.wikipedia.org/wiki/Shunting-yard_algorithm">shunting-yard algorithm</a>
    to implement a tokenizer for a simple subset of arithmetic that includes:</p>
<ul>
<li>single-letter variable names</li>
<li>single-digit numbers</li>
<li>the <code>+</code>, <code>*</code>, and <code>^</code> operators, where <code>+</code> has the lowest precedence and <code>^</code> has the highest</li>
</ul>
</li>
<li>
<p>Write Mocha tests for your tokenizer.</p>
</li>
</ol>
<h3 class="exercise">Handling errors</h3>
<ol>
<li>
<p>What does the regular expression tokenizer do
    with expressions that contain unmatched opening parentheses like <code>/a(b/</code>?
    What about expressions that contain unmatched closing parentheses like <code>/ab)/</code>?</p>
</li>
<li>
<p>Modify it so it produces a more useful error message.</p>
</li>
</ol>
          
        </main>
      </div>
    </div>
  </body>
</html>
