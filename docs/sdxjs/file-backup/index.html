<!DOCTYPE html>
<html lang="en">
  <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="../favicon.ico">
  <link rel="stylesheet" href="../mccole.css">
  <link rel="stylesheet" href="../tango.css">
  <script defer data-domain="third-bit.com" src="https://plausible.io/js/plausible.js"></script>
  <script>
    MathJax = {
      tex: {
        inlineMath: [['\\(', '\\)']]
      }
    };
  </script>
  <script
    type="text/javascript"
    id="MathJax-script"
    async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
  <script defer src="../mccole.js"></script>
  <title>Software Design by Example: File Backup</title>
</head>

  <body>
    <div class="row">
      <div class="sidebar">
        <p>
  
  <a href="https://www.taylorfrancis.com/books/mono/10.1201/9781003317807/software-design-example-greg-wilson"><img src="../sdxjs-cover.png" alt="Book cover" width="80%" /></a>
  
</p>
<ol class="toc-chapter">
  
  <li>
    <a href="../introduction/">
      Introduction
    </a>
  </li>
  
  <li>
    <a href="../systems-programming/">
      Systems Programming
    </a>
  </li>
  
  <li>
    <a href="../async-programming/">
      Asynchronous Programming
    </a>
  </li>
  
  <li>
    <a href="../unit-test/">
      Unit Testing
    </a>
  </li>
  
  <li>
    <a href="../file-backup/">
      <strong>File Backup</strong>
    </a>
  </li>
  
  <li>
    <a href="../data-table/">
      Data Tables
    </a>
  </li>
  
  <li>
    <a href="../pattern-matching/">
      Pattern Matching
    </a>
  </li>
  
  <li>
    <a href="../regex-parser/">
      Parsing Expressions
    </a>
  </li>
  
  <li>
    <a href="../page-templates/">
      Page Templates
    </a>
  </li>
  
  <li>
    <a href="../build-manager/">
      Build Manager
    </a>
  </li>
  
  <li>
    <a href="../layout-engine/">
      Layout Engine
    </a>
  </li>
  
  <li>
    <a href="../file-interpolator/">
      File Interpolator
    </a>
  </li>
  
  <li>
    <a href="../module-loader/">
      Module Loader
    </a>
  </li>
  
  <li>
    <a href="../style-checker/">
      Style Checker
    </a>
  </li>
  
  <li>
    <a href="../code-generator/">
      Code Generator
    </a>
  </li>
  
  <li>
    <a href="../doc-generator/">
      Documentation Generator
    </a>
  </li>
  
  <li>
    <a href="../module-bundler/">
      Module Bundler
    </a>
  </li>
  
  <li>
    <a href="../package-manager/">
      Package Manager
    </a>
  </li>
  
  <li>
    <a href="../virtual-machine/">
      Virtual Machine
    </a>
  </li>
  
  <li>
    <a href="../debugger/">
      Debugger
    </a>
  </li>
  
  <li>
    <a href="../conclusion/">
      Conclusion
    </a>
  </li>
  
</ol>
<ol class="toc-appendix">
  
  <li>
    <a href="../license/">
      License
    </a>
  </li>
  
  <li>
    <a href="../conduct/">
      Code of Conduct
    </a>
  </li>
  
  <li>
    <a href="../contributing/">
      Contributing
    </a>
  </li>
  
  <li>
    <a href="../bibliography/">
      Bibliography
    </a>
  </li>
  
  <li>
    <a href="../glossary/">
      Glossary
    </a>
  </li>
  
  <li>
    <a href="../contents/">
      Index
    </a>
  </li>
  
</ol>

<p><a href="../sdxjs-examples.zip" type="application/zip" alt="examples">download examples</a></p>


      </div>
      <div id="printable" class="contents bordered">
        <main>
          
  <h1>Chapter 5: File Backup</h1>


          
            

            

            
<p class="definitions">
  Terms defined: <a class="gl-ref" href="../glossary/#api" markdown="1">Application Programming Interface</a>, <a class="gl-ref" href="../glossary/#collision" markdown="1">collision</a>, <a class="gl-ref" href="../glossary/#csv" markdown="1">comma-separated values</a>, <a class="gl-ref" href="../glossary/#utc" markdown="1">Coordinated Universal Time</a>, <a class="gl-ref" href="../glossary/#cryptographic_hash_function" markdown="1">cryptographic hash function</a>, <a class="gl-ref" href="../glossary/#data_migration" markdown="1">data migration</a>, <a class="gl-ref" href="../glossary/#handler" markdown="1">handler</a>, <a class="gl-ref" href="../glossary/#hash_code" markdown="1">hash code</a>, <a class="gl-ref" href="../glossary/#hash_function" markdown="1">hash function</a>, <a class="gl-ref" href="../glossary/#json" markdown="1">JavaScript Object Notation</a>, <a class="gl-ref" href="../glossary/#mock_object" markdown="1">mock object</a>, <a class="gl-ref" href="../glossary/#pipe" markdown="1">pipe</a>, <a class="gl-ref" href="../glossary/#race_condition" markdown="1">race condition</a>, <a class="gl-ref" href="../glossary/#sha_1" markdown="1">SHA-1 hash</a>, <a class="gl-ref" href="../glossary/#stream" markdown="1">stream</a>, <a class="gl-ref" href="../glossary/#streaming_api" markdown="1">streaming API</a>, <a class="gl-ref" href="../glossary/#toctou" markdown="1">Time of check/time of use</a>, <a class="gl-ref" href="../glossary/#timestamp" markdown="1">timestamp</a>, <a class="gl-ref" href="../glossary/#version_control_system" markdown="1">version control system</a>
</p>


            <div class="page-toc"></div>
            <p>Now that we can test software, we have something worth saving.
A <span class="ix-entry" ix-key="version control system" markdown="1"><a class="gl-ref" href="../glossary/#version_control_system" markdown="1">version control system</a></span>
like <span class="ix-entry" ix-key="Git;version control system!Git" markdown="1"><a href="https://git-scm.com/">Git</a></span>
keeps track of changes to files
so that we can recover old versions if we want to.
Its core is a way to archive files that:</p>
<ol>
<li>records which versions of which files existed at the same time
    (so that we can go back to a consistent previous state), and</li>
<li>stores any particular version of a file only once,
    so that we don&rsquo;t waste disk space.</li>
</ol>
<p>In this chapter we will build a tool for doing both tasks.
It won&rsquo;t do everything Git does:
in particular, it won&rsquo;t let us create and merge branches.
If you would like to know how that works,
please see <span class="ix-entry" ix-key="Cook, Mary Rose" markdown="1"><a href="https://maryrosecook.com/">Mary Rose Cook&rsquo;s</a></span> excellent <a href="http://gitlet.maryrosecook.com/">Gitlet</a> project.</p>
<h2 id="file-backup-unique">Section 5.1: How can we uniquely identify files?</h2>
<p>To avoid storing redundant copies of files,
we need a way to tell when two files contain the same data.
We can&rsquo;t rely on names because files can be renamed or moved over time;
we could compare the files byte-by-byte,
but a quicker way is to use a <span class="ix-entry" ix-key="hash function" markdown="1"><a class="gl-ref" href="../glossary/#hash_function" markdown="1">hash function</a></span>
that turns arbitrary data into a fixed-length string of bits
(<a class="fig-ref" href="../file-backup/#file-backup-hash-function">Figure 5.1</a>).</p>
<figure id="file-backup-hash-function">
  <img src="./hash-function.svg" alt="Hash functions"/>
  <figcaption markdown="1">Figure 5.1: How hash functions speed up lookup.</figcaption>
</figure>

<p>A hash function always produces the same <span class="ix-entry" ix-key="hash code" markdown="1"><a class="gl-ref" href="../glossary/#hash_code" markdown="1">hash code</a></span> for a given input.
A <span class="ix-entry" ix-key="cryptographic hash function;hash function!cryptographic" markdown="1"><a class="gl-ref" href="../glossary/#cryptographic_hash_function" markdown="1">cryptographic hash function</a></span>
has two extra properties:</p>
<ol>
<li>
<p>The output depends on the entire input:
    changing even a single byte results in a different hash code.</p>
</li>
<li>
<p>The outputs look like random numbers:
    they are unpredictable and evenly distributed
    (i.e., the odds of getting any specific hash code are the same).</p>
</li>
</ol>
<p>It&rsquo;s easy to write a bad hash function,
but very hard to write one that qualifies as cryptographic.
We will therefore use a library to calculate 160-bit <span class="ix-entry" ix-key="hash code!SHA-1;SHA-1 hash code" markdown="1"><a class="gl-ref" href="../glossary/#sha_1" markdown="1">SHA-1</a></span> hashes for our files.
These are not random enough to keep data secret from a patient, well-funded attacker,
but that&rsquo;s not what we&rsquo;re using them for:
we just want hashes that are random to make <span class="ix-entry" ix-key="hash function!collision;collision (in hashing)" markdown="1"><a class="gl-ref" href="../glossary/#collision" markdown="1">collision</a></span> extremely unlikely.</p>
<div class="callout">
<h3>The Birthday Problem</h3>
<p>The odds that two people share a birthday are 1/365 (ignoring February 29).
The odds that they <em>don&rsquo;t</em> are therefore 364/365.
When we add a third person,
the odds that they don&rsquo;t share a birthday with either of the preceding two people are 363/365,
so the overall odds that nobody shares a birthday are (365/365)×(364/365)×(363/365).
If we keep calculating, there&rsquo;s a 50% chance of two people sharing a birthday in a group of just 23 people,
and a 99.9% chance with 70 people.</p>
<p>We can use the same math to calculate how many files we need to hash before there&rsquo;s a 50% chance of a collision.
Instead of 365, we use \(2^{160}\) (the number of values that are 160 bits long),
and after checking <a href="https://en.wikipedia.org/wiki/Birthday_problem#A_simple_exponentiation">Wikipedia</a>
and doing a few calculations with <span class="ix-entry" ix-key="Wolfram Alpha" markdown="1"><a href="http://wolframalpha.com">Wolfram Alpha</a></span>,
we calculate that we would need to have approximately \(10^{24}\) files
in order to have a 50% chance of a collision.
We&rsquo;re willing to take that risk.</p>
</div>
<p><a href="https://nodejs.org/en/">Node&rsquo;s</a> <a href="https://nodejs.org/api/crypto.html"><code>crypto</code></a> module provides tools to create a SHA-1 hash.
To use them,
we create an object that keeps track of the current state of the hashing calculations,
tell it how we want to encode (or represent) the hash value,
and then feed it some bytes.
When we are done,
we call its <code>.end</code> method
and then use its <code>.read</code> method to get the final result:</p>
<div class="code-sample lang-js" title="hash-text.js">
<div class="highlight"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">crypto</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;crypto&#39;</span>

<span class="c1">// create a SHA1 hasher</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">crypto</span><span class="p">.</span><span class="nx">createHash</span><span class="p">(</span><span class="s1">&#39;sha1&#39;</span><span class="p">)</span>

<span class="c1">// encode as hex (rather than binary)</span>
<span class="nx">hash</span><span class="p">.</span><span class="nx">setEncoding</span><span class="p">(</span><span class="s1">&#39;hex&#39;</span><span class="p">)</span>

<span class="c1">// send it some text</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">text</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">process</span><span class="p">.</span><span class="nx">argv</span><span class="p">[</span><span class="mf">2</span><span class="p">]</span>
<span class="nx">hash</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="nx">text</span><span class="p">)</span>

<span class="c1">// signal end of text</span>
<span class="nx">hash</span><span class="p">.</span><span class="nx">end</span><span class="p">()</span>

<span class="c1">// display the result</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">sha1sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">hash</span><span class="p">.</span><span class="nx">read</span><span class="p">()</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`SHA1 of &quot;</span><span class="si">${</span><span class="nx">text</span><span class="si">}</span><span class="sb">&quot; is </span><span class="si">${</span><span class="nx">sha1sum</span><span class="si">}</span><span class="sb">`</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="code-sample lang-sh" title="hash-text.sh">
<div class="highlight"><pre><span></span><code>node<span class="w"> </span>hash-text.js<span class="w"> </span>something
</code></pre></div>
</div>
<div class="code-sample lang-out" title="hash-text.out">
<div class="highlight"><pre><span></span><code>SHA1 of &quot;something&quot; is 1af17e73721dbe0c40011b82ed4bb1a7dbe3ce29
</code></pre></div>
</div>
<p>Hashing a file instead of a fixed string is straightforward:
we just read the file&rsquo;s contents and pass those characters to the hashing object:</p>
<div class="code-sample lang-js" title="hash-file.js">
<div class="highlight"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">fs</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;fs&#39;</span>
<span class="k">import</span><span class="w"> </span><span class="nx">crypto</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;crypto&#39;</span>

<span class="kd">const</span><span class="w"> </span><span class="nx">filename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">process</span><span class="p">.</span><span class="nx">argv</span><span class="p">[</span><span class="mf">2</span><span class="p">]</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">fs</span><span class="p">.</span><span class="nx">readFileSync</span><span class="p">(</span><span class="nx">filename</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>

<span class="kd">const</span><span class="w"> </span><span class="nx">hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">crypto</span><span class="p">.</span><span class="nx">createHash</span><span class="p">(</span><span class="s1">&#39;sha1&#39;</span><span class="p">).</span><span class="nx">setEncoding</span><span class="p">(</span><span class="s1">&#39;hex&#39;</span><span class="p">)</span>
<span class="nx">hash</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
<span class="nx">hash</span><span class="p">.</span><span class="nx">end</span><span class="p">()</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">sha1sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">hash</span><span class="p">.</span><span class="nx">read</span><span class="p">()</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`SHA1 of &quot;</span><span class="si">${</span><span class="nx">filename</span><span class="si">}</span><span class="sb">&quot; is </span><span class="si">${</span><span class="nx">sha1sum</span><span class="si">}</span><span class="sb">`</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="code-sample lang-sh" title="hash-file.sh">
<div class="highlight"><pre><span></span><code>node<span class="w"> </span>hash-file.js<span class="w"> </span>hash-file.js
</code></pre></div>
</div>
<div class="code-sample lang-out" title="hash-file.out">
<div class="highlight"><pre><span></span><code>SHA1 of &quot;hash-file.js&quot; is c54c8ee3e576770d29ae2d0d73568e5a5c49eac0
</code></pre></div>
</div>
<p>However,
it is more efficient to process the file as a <a class="gl-ref" href="../glossary/#stream" markdown="1">stream</a>:</p>
<div class="code-sample lang-js" title="hash-stream.js">
<div class="highlight"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">fs</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;fs&#39;</span>
<span class="k">import</span><span class="w"> </span><span class="nx">crypto</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;crypto&#39;</span>

<span class="kd">const</span><span class="w"> </span><span class="nx">filename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">process</span><span class="p">.</span><span class="nx">argv</span><span class="p">[</span><span class="mf">2</span><span class="p">]</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">crypto</span><span class="p">.</span><span class="nx">createHash</span><span class="p">(</span><span class="s1">&#39;sha1&#39;</span><span class="p">).</span><span class="nx">setEncoding</span><span class="p">(</span><span class="s1">&#39;hex&#39;</span><span class="p">)</span>
<span class="nx">fs</span><span class="p">.</span><span class="nx">createReadStream</span><span class="p">(</span><span class="nx">filename</span><span class="p">).</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">hash</span><span class="p">)</span>
<span class="nx">hash</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;finish&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="kr">final</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">hash</span><span class="p">.</span><span class="nx">read</span><span class="p">()</span>
<span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;final&#39;</span><span class="p">,</span><span class="w"> </span><span class="kr">final</span><span class="p">)</span>
<span class="p">})</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;program ends&#39;</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="code-sample lang-sh" title="hash-stream.sh">
<div class="highlight"><pre><span></span><code>node<span class="w"> </span>hash-stream.js<span class="w"> </span>hash-stream.js
</code></pre></div>
</div>
<div class="code-sample lang-out" title="hash-stream.out">
<div class="highlight"><pre><span></span><code>program ends
final dc9e6c231e243860dace2dbf52845b121062b60e
</code></pre></div>
</div>
<p class="continue">This kind of interface is called
a <span class="ix-entry" ix-key="streaming API;execution!streaming" markdown="1"><a class="gl-ref" href="../glossary/#streaming_api" markdown="1">streaming</a></span> <a class="gl-ref" href="../glossary/#api" markdown="1">API</a>
because it is designed to process a stream of data one chunk at a time
rather than requiring all of the data to be in memory at once.
Many applications use streams
so that programs don&rsquo;t have to read entire (possibly large) files into memory.</p>
<p>To start,
this program asks the <code>fs</code> library to create a reading stream for a file
and to <a class="gl-ref" href="../glossary/#pipe" markdown="1">pipe</a> the data from that stream to the hashing object
(<a class="fig-ref" href="../file-backup/#file-backup-streaming">Figure 5.2</a>).
It then tells the hashing object what to do when there is no more data
by providing a <span class="ix-entry" ix-key="event handler!streaming API;streaming API!event handler" markdown="1"><a class="gl-ref" href="../glossary/#handler" markdown="1">handler</a></span> for the &ldquo;finish&rdquo; event.
This is called asynchronously:
as the output shows,
the main program ends before the task handling the end of data is scheduled and run.
Most programs also provide a handler for &ldquo;data&rdquo; events to do something with each block of data as it comes in;
the <code>hash</code> object in our program does that for us.</p>
<figure id="file-backup-streaming">
  <img src="./streaming.svg" alt="Streaming file operations"/>
  <figcaption markdown="1">Figure 5.2: Processing files as streams of chunks.</figcaption>
</figure>

<h2 id="file-backup-backup">Section 5.2: How can we back up files?</h2>
<p>Many files only change occasionally after they&rsquo;re created, or not at all.
It would be wasteful for a version control system to make copies
each time the user wanted to save a snapshot of a project,
so instead our tool will copy each unique file to something like <code>abcd1234.bck</code>,
where <code>abcd1234</code> is a hash of the file&rsquo;s contents.
It will then store a data structure that records the filenames and hash keys for each snapshot.
The hash keys tell it which unique files are part of the snapshot,
while the filenames tell us what each file&rsquo;s contents were called when the snapshot was made
(since files can be moved or renamed).
To restore a particular snapshot,
all we have to do is copy the saved <code>.bck</code> files back to where they were
(<a class="fig-ref" href="../file-backup/#file-backup-storage">Figure 5.3</a>).</p>
<figure id="file-backup-storage">
  <img src="./storage.svg" alt="Backup file storage"/>
  <figcaption markdown="1">Figure 5.3: Organization of backup file storage.</figcaption>
</figure>

<p>We can build the tools we need to do this using promises (<a class="x-ref" href="../async-programming/">Chapter 3</a>).
The main function creates a promise that uses the asynchronous version of <code>glob</code> to find files
and then:</p>
<ol>
<li>
<p>checks that entries in the list are actually files;</p>
</li>
<li>
<p>reads each file into memory; and</p>
</li>
<li>
<p>calculates hashes for those files.</p>
</li>
</ol>
<div class="code-sample lang-js" title="hash-existing-promise.js">
<div class="highlight"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">fs</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;fs-extra-promise&#39;</span>
<span class="k">import</span><span class="w"> </span><span class="nx">glob</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;glob-promise&#39;</span>
<span class="k">import</span><span class="w"> </span><span class="nx">crypto</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;crypto&#39;</span>

<span class="kd">const</span><span class="w"> </span><span class="nx">hashExisting</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">rootDir</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">pattern</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sb">`</span><span class="si">${</span><span class="nx">rootDir</span><span class="si">}</span><span class="sb">/**/*`</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span><span class="w"> </span><span class="nx">reject</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">glob</span><span class="p">(</span><span class="nx">pattern</span><span class="p">,</span><span class="w"> </span><span class="p">{})</span>
<span class="w">      </span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">matches</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">(</span>
<span class="w">        </span><span class="nx">matches</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">path</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">statPath</span><span class="p">(</span><span class="nx">path</span><span class="p">))))</span>
<span class="w">      </span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">pairs</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">pairs</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span>
<span class="w">        </span><span class="p">([</span><span class="nx">path</span><span class="p">,</span><span class="w"> </span><span class="nx">stat</span><span class="p">])</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">stat</span><span class="p">.</span><span class="nx">isFile</span><span class="p">()))</span>
<span class="w">      </span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">pairs</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">(</span>
<span class="w">        </span><span class="nx">pairs</span><span class="p">.</span><span class="nx">map</span><span class="p">(([</span><span class="nx">path</span><span class="p">,</span><span class="w"> </span><span class="nx">stat</span><span class="p">])</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">readPath</span><span class="p">(</span><span class="nx">path</span><span class="p">))))</span>
<span class="w">      </span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">pairs</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">(</span>
<span class="w">        </span><span class="nx">pairs</span><span class="p">.</span><span class="nx">map</span><span class="p">(([</span><span class="nx">path</span><span class="p">,</span><span class="w"> </span><span class="nx">content</span><span class="p">])</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">hashPath</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span><span class="w"> </span><span class="nx">content</span><span class="p">))))</span>
<span class="w">      </span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">pairs</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">resolve</span><span class="p">(</span><span class="nx">pairs</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">err</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">reject</span><span class="p">(</span><span class="nx">err</span><span class="p">))</span>
<span class="w">  </span><span class="p">})</span>
<span class="p">}</span>
</code></pre></div>
</div>
<p class="continue">This function uses <code>Promise.all</code>
to wait for the operations on all of the files in the list to complete
before going on to the next step.
A different design would combine stat, read, and hash into a single step
so that each file would be handled independently
and use one <code>Promise.all</code> at the end to bring them all together.</p>
<p>The first two <span class="ix-entry" ix-key="helper function" markdown="1">helper functions</span> that <code>hashExisting</code> relies on
wrap asynchronous operation in promises:</p>
<div class="code-sample lang-js" title="hash-existing-promise.js">
<div class="highlight"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="nx">statPath</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">path</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span><span class="w"> </span><span class="nx">reject</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">fs</span><span class="p">.</span><span class="nx">statAsync</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span>
<span class="w">      </span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">stat</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">resolve</span><span class="p">([</span><span class="nx">path</span><span class="p">,</span><span class="w"> </span><span class="nx">stat</span><span class="p">]))</span>
<span class="w">      </span><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">err</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">reject</span><span class="p">(</span><span class="nx">err</span><span class="p">))</span>
<span class="w">  </span><span class="p">})</span>
<span class="p">}</span>

<span class="kd">const</span><span class="w"> </span><span class="nx">readPath</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">path</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span><span class="w"> </span><span class="nx">reject</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">fs</span><span class="p">.</span><span class="nx">readFileAsync</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
<span class="w">      </span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">content</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">resolve</span><span class="p">([</span><span class="nx">path</span><span class="p">,</span><span class="w"> </span><span class="nx">content</span><span class="p">]))</span>
<span class="w">      </span><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">err</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">reject</span><span class="p">(</span><span class="nx">err</span><span class="p">))</span>
<span class="w">  </span><span class="p">})</span>
<span class="p">}</span>
</code></pre></div>
</div>
<p>The final helper function calculates the hash synchronously,
but we can use <code>Promise.all</code> to wait on those operations finishing anyway:</p>
<div class="code-sample lang-js" title="hash-existing-promise.js">
<div class="highlight"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="nx">hashPath</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">path</span><span class="p">,</span><span class="w"> </span><span class="nx">content</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">hasher</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">crypto</span><span class="p">.</span><span class="nx">createHash</span><span class="p">(</span><span class="s1">&#39;sha1&#39;</span><span class="p">).</span><span class="nx">setEncoding</span><span class="p">(</span><span class="s1">&#39;hex&#39;</span><span class="p">)</span>
<span class="w">  </span><span class="nx">hasher</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="nx">content</span><span class="p">)</span>
<span class="w">  </span><span class="nx">hasher</span><span class="p">.</span><span class="nx">end</span><span class="p">()</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">[</span><span class="nx">path</span><span class="p">,</span><span class="w"> </span><span class="nx">hasher</span><span class="p">.</span><span class="nx">read</span><span class="p">()]</span>
<span class="p">}</span>
</code></pre></div>
</div>
<p>Let&rsquo;s try running it:</p>
<div class="code-sample lang-js" title="run-hash-existing-promise.js">
<div class="highlight"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">hashExisting</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;./hash-existing-promise.js&#39;</span>

<span class="kd">const</span><span class="w"> </span><span class="nx">root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">process</span><span class="p">.</span><span class="nx">argv</span><span class="p">[</span><span class="mf">2</span><span class="p">]</span>
<span class="nx">hashExisting</span><span class="p">(</span><span class="nx">root</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">pairs</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">pairs</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span>
<span class="w">  </span><span class="p">([</span><span class="nx">path</span><span class="p">,</span><span class="w"> </span><span class="nx">hash</span><span class="p">])</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span><span class="w"> </span><span class="nx">hash</span><span class="p">)</span>
<span class="p">))</span>
</code></pre></div>
</div>
<div class="code-sample lang-sh" title="run-hash-existing-promise.sh">
<div class="highlight"><pre><span></span><code>node<span class="w"> </span>run-hash-existing-promise.js<span class="w"> </span>.<span class="w"> </span><span class="p">|</span><span class="w"> </span>fgrep<span class="w"> </span>-v<span class="w"> </span>test/<span class="w"> </span><span class="p">|</span><span class="w"> </span>fgrep<span class="w"> </span>-v<span class="w"> </span><span class="s1">&#39;~&#39;</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="run-hash-existing-promise.slice.out">
<div class="highlight"><pre><span></span><code>./backup.js 11422489e11be3d8ff76278503457665f6152ebe
./check-existing-files.js 66b933cf9e792e9a9204171d04e0f8b530ec3f4f
./figures/hash-function.pdf 0eb82de379a95ee2be3f00b38c0102e2f2f8170e
./figures/hash-function.svg 563996575d581f2a08e3e954d7faba4d189d0773
./figures/mock-fs.pdf 0b3bba44e69122ee53bcc9d777c186c84b7c2ff2
...
./x-from-to.md f0f63b3576042dfc0050029ddfcccc3c42fe275d
./x-io-streams.md 1fb4d8b7785c5e7b2f1e29588e2ba28d101ced1a
./x-json-manifests.md 223e0e4167acc6d4d81b76ba1287b90234c95e22
./x-mock-hashes.md 580edfc0cb8eaca4f3700307002ae10ee97af8d2
./x-pre-commit.md b7d945af4554fc0f64b708fe735417bee8b33eef
</code></pre></div>
</div>
<p>The code we have written is clearer than it would be with callbacks
(try rewriting it if you don&rsquo;t believe this)
but the layer of promises around everything still obscures its meaning.
The same operations are easier to read when written using <code>async</code> and <code>await</code>:</p>
<div class="code-sample lang-js" title="hash-existing-async.js">
<div class="highlight"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="nx">statPath</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="p">(</span><span class="nx">path</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">stat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">fs</span><span class="p">.</span><span class="nx">statAsync</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">[</span><span class="nx">path</span><span class="p">,</span><span class="w"> </span><span class="nx">stat</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">const</span><span class="w"> </span><span class="nx">readPath</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="p">(</span><span class="nx">path</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">content</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">fs</span><span class="p">.</span><span class="nx">readFileAsync</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">[</span><span class="nx">path</span><span class="p">,</span><span class="w"> </span><span class="nx">content</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">const</span><span class="w"> </span><span class="nx">hashPath</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">path</span><span class="p">,</span><span class="w"> </span><span class="nx">content</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">hasher</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">crypto</span><span class="p">.</span><span class="nx">createHash</span><span class="p">(</span><span class="s1">&#39;sha1&#39;</span><span class="p">).</span><span class="nx">setEncoding</span><span class="p">(</span><span class="s1">&#39;hex&#39;</span><span class="p">)</span>
<span class="w">  </span><span class="nx">hasher</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="nx">content</span><span class="p">)</span>
<span class="w">  </span><span class="nx">hasher</span><span class="p">.</span><span class="nx">end</span><span class="p">()</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">[</span><span class="nx">path</span><span class="p">,</span><span class="w"> </span><span class="nx">hasher</span><span class="p">.</span><span class="nx">read</span><span class="p">()]</span>
<span class="p">}</span>

<span class="kd">const</span><span class="w"> </span><span class="nx">hashExisting</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="p">(</span><span class="nx">rootDir</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">pattern</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sb">`</span><span class="si">${</span><span class="nx">rootDir</span><span class="si">}</span><span class="sb">/**/*`</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">options</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{}</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">matches</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">glob</span><span class="p">(</span><span class="nx">pattern</span><span class="p">,</span><span class="w"> </span><span class="nx">options</span><span class="p">)</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">stats</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">(</span><span class="nx">matches</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">path</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">statPath</span><span class="p">(</span><span class="nx">path</span><span class="p">)))</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">files</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">stats</span><span class="p">.</span><span class="nx">filter</span><span class="p">(([</span><span class="nx">path</span><span class="p">,</span><span class="w"> </span><span class="nx">stat</span><span class="p">])</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">stat</span><span class="p">.</span><span class="nx">isFile</span><span class="p">())</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">contents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">(</span>
<span class="w">    </span><span class="nx">files</span><span class="p">.</span><span class="nx">map</span><span class="p">(([</span><span class="nx">path</span><span class="p">,</span><span class="w"> </span><span class="nx">stat</span><span class="p">])</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">readPath</span><span class="p">(</span><span class="nx">path</span><span class="p">)))</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">hashes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">contents</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span>
<span class="w">    </span><span class="p">([</span><span class="nx">path</span><span class="p">,</span><span class="w"> </span><span class="nx">content</span><span class="p">])</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">hashPath</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span><span class="w"> </span><span class="nx">content</span><span class="p">))</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">hashes</span>
<span class="p">}</span>
</code></pre></div>
</div>
<p class="continue">This version creates and resolves exactly the same promises as the previous one,
but those promises are created for us automatically by Node.
To check that it works,
let&rsquo;s run it for the same input files:</p>
<div class="code-sample lang-js" title="run-hash-existing-async.js">
<div class="highlight"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">hashExisting</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;./hash-existing-async.js&#39;</span>

<span class="kd">const</span><span class="w"> </span><span class="nx">root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">process</span><span class="p">.</span><span class="nx">argv</span><span class="p">[</span><span class="mf">2</span><span class="p">]</span>
<span class="nx">hashExisting</span><span class="p">(</span><span class="nx">root</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span>
<span class="w">  </span><span class="nx">pairs</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">pairs</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(([</span><span class="nx">path</span><span class="p">,</span><span class="w"> </span><span class="nx">hash</span><span class="p">])</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span><span class="w"> </span><span class="nx">hash</span><span class="p">)))</span>
</code></pre></div>
</div>
<div class="code-sample lang-sh" title="run-hash-existing-async.sh">
<div class="highlight"><pre><span></span><code>node<span class="w"> </span>run-hash-existing-async.js<span class="w"> </span>.<span class="w"> </span><span class="p">|</span><span class="w"> </span>fgrep<span class="w"> </span>-v<span class="w"> </span>test/<span class="w"> </span><span class="p">|</span><span class="w"> </span>fgrep<span class="w"> </span>-v<span class="w"> </span><span class="s1">&#39;~&#39;</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="run-hash-existing-async.slice.out">
<div class="highlight"><pre><span></span><code>./backup.js 11422489e11be3d8ff76278503457665f6152ebe
./check-existing-files.js 66b933cf9e792e9a9204171d04e0f8b530ec3f4f
./figures/hash-function.pdf 0eb82de379a95ee2be3f00b38c0102e2f2f8170e
./figures/hash-function.svg 563996575d581f2a08e3e954d7faba4d189d0773
./figures/mock-fs.pdf 0b3bba44e69122ee53bcc9d777c186c84b7c2ff2
...
./x-from-to.md f0f63b3576042dfc0050029ddfcccc3c42fe275d
./x-io-streams.md 1fb4d8b7785c5e7b2f1e29588e2ba28d101ced1a
./x-json-manifests.md 223e0e4167acc6d4d81b76ba1287b90234c95e22
./x-mock-hashes.md 580edfc0cb8eaca4f3700307002ae10ee97af8d2
./x-pre-commit.md b7d945af4554fc0f64b708fe735417bee8b33eef
</code></pre></div>
</div>
<h2 id="file-backup-track">Section 5.3: How can we track which files have already been backed up?</h2>
<p>The second part of our backup tool keeps track of which files have and haven&rsquo;t been backed up already.
It stores backups in a directory that contains backup files like <code>abcd1234.bck</code>
and files describing the contents of particular snapshots.
The latter are named <code>ssssssssss.csv</code>,
where <code>ssssssssss</code> is the <a class="gl-ref" href="../glossary/#utc" markdown="1">UTC</a> <a class="gl-ref" href="../glossary/#timestamp" markdown="1">timestamp</a> of the backup&rsquo;s creation
and the <code>.csv</code> extension indicates that the file is formatted as <a class="gl-ref" href="../glossary/#csv" markdown="1">comma-separated values</a>.
(We could store these files as <a class="gl-ref" href="../glossary/#json" markdown="1">JSON</a>, but CSV is easier for people to read.)</p>
<div class="callout">
<h3>Time of check/time of use</h3>
<p>Our naming convention for index files will fail if we try to create more than one backup per second.
This might seem very unlikely,
but many faults and security holes are the result of programmers assuming things weren&rsquo;t going to happen.</p>
<p>We could try to avoid this problem by using a two-part naming scheme <code>ssssssss-a.csv</code>,
<code>ssssssss-b.csv</code>, and so on,
but this leads to a <span class="ix-entry" ix-key="race condition" markdown="1"><a class="gl-ref" href="../glossary/#race_condition" markdown="1">race condition</a></span>
called <span class="ix-entry" ix-key="race condition!time of check/time of use;time of check/time of use" markdown="1"><a class="gl-ref" href="../glossary/#toctou" markdown="1">time of check/time of use</a></span>.
If two users run the backup tool at the same time,
they will both see that there isn&rsquo;t a file (yet) with the current timestamp,
so they will both try to create the first one.</p>
</div>
<div class="code-sample lang-js" title="check-existing-files.js">
<div class="highlight"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">glob</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;glob-promise&#39;</span>
<span class="k">import</span><span class="w"> </span><span class="nx">path</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;path&#39;</span>

<span class="kd">const</span><span class="w"> </span><span class="nx">findNew</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="p">(</span><span class="nx">rootDir</span><span class="p">,</span><span class="w"> </span><span class="nx">pathHashPairs</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">hashToPath</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">pathHashPairs</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">obj</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="nx">path</span><span class="p">,</span><span class="w"> </span><span class="nx">hash</span><span class="p">])</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">obj</span><span class="p">[</span><span class="nx">hash</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">path</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">obj</span>
<span class="w">  </span><span class="p">},</span><span class="w"> </span><span class="p">{})</span>

<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">pattern</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sb">`</span><span class="si">${</span><span class="nx">rootDir</span><span class="si">}</span><span class="sb">/*.bck`</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">options</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{}</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">existingFiles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">glob</span><span class="p">(</span><span class="nx">pattern</span><span class="p">,</span><span class="w"> </span><span class="nx">options</span><span class="p">)</span>

<span class="w">  </span><span class="nx">existingFiles</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">filename</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">stripped</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">path</span><span class="p">.</span><span class="nx">basename</span><span class="p">(</span><span class="nx">filename</span><span class="p">).</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/\.bck$/</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="w">    </span><span class="ow">delete</span><span class="w"> </span><span class="nx">hashToPath</span><span class="p">[</span><span class="nx">stripped</span><span class="p">]</span>
<span class="w">  </span><span class="p">})</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">hashToPath</span>
<span class="p">}</span>

<span class="k">export</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="nx">findNew</span>
</code></pre></div>
</div>
<p>To test our program,
let&rsquo;s manually create testing directories with manufactured (shortened) hashes:</p>
<div class="code-sample lang-sh" title="tree-test.sh">
<div class="highlight"><pre><span></span><code>tree<span class="w"> </span><span class="nb">test</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="tree-test.out">
<div class="highlight"><pre><span></span><code>test
├── bck-0-csv-0
├── bck-1-csv-1
│   ├── 0001.csv
│   └── abcd1234.bck
├── bck-4-csv-2
│   ├── 0001.csv
│   ├── 3028.csv
│   ├── 3456cdef.bck
│   ├── abcd1234.bck
│   └── bcde2345.bck
├── test-backup.js
├── test-find-mock.js
└── test-find.js

3 directories, 10 files
</code></pre></div>
</div>
<p>We use <span class="ix-entry" ix-key="Mocha" markdown="1"><a href="https://mochajs.org/">Mocha</a></span> to manage our tests.
Every test is an <code>async</code> function;
Mocha automatically waits for them all to complete before reporting results.
To run them,
we add the line:</p>
<div class="highlight"><pre><span></span><code><span class="s2">&quot;test&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;mocha */test/test-*.js&quot;</span>
</code></pre></div>
<p class="continue">in the <code>scripts</code> section of our project&rsquo;s <code>package.json</code> file
so that when we run <code>npm run test</code>,
Mocha looks for files in <code>test</code> sub-directories of the directories holding our lessons.</p>
<p>Here are our first few tests:</p>
<div class="code-sample lang-js" title="test-find.js">
<div class="highlight"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">assert</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;assert&#39;</span>

<span class="k">import</span><span class="w"> </span><span class="nx">findNew</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;../check-existing-files.js&#39;</span>

<span class="nx">describe</span><span class="p">(</span><span class="s1">&#39;pre-existing hashes and actual filesystem&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">it</span><span class="p">(</span><span class="s1">&#39;finds no pre-existing files when none given or exist&#39;</span><span class="p">,</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">expected</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{}</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">actual</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">findNew</span><span class="p">(</span><span class="s1">&#39;file-backup/test/bck-0-csv-0&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">[])</span>
<span class="w">    </span><span class="nx">assert</span><span class="p">.</span><span class="nx">deepStrictEqual</span><span class="p">(</span><span class="nx">expected</span><span class="p">,</span><span class="w"> </span><span class="nx">actual</span><span class="p">,</span>
<span class="w">      </span><span class="s1">&#39;Expected no files&#39;</span><span class="p">)</span>
<span class="w">  </span><span class="p">})</span>

<span class="w">  </span><span class="nx">it</span><span class="p">(</span><span class="s1">&#39;finds some files when one is given and none exist&#39;</span><span class="p">,</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">check</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[[</span><span class="s1">&#39;somefile.txt&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;9876fedc&#39;</span><span class="p">]]</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">expected</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="s1">&#39;9876fedc&#39;</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;somefile.txt&#39;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">actual</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">findNew</span><span class="p">(</span><span class="s1">&#39;file-backup/test/bck-0-csv-0&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">check</span><span class="p">)</span>
<span class="w">    </span><span class="nx">assert</span><span class="p">.</span><span class="nx">deepStrictEqual</span><span class="p">(</span><span class="nx">expected</span><span class="p">,</span><span class="w"> </span><span class="nx">actual</span><span class="p">,</span>
<span class="w">      </span><span class="s1">&#39;Expected one file&#39;</span><span class="p">)</span>
<span class="w">  </span><span class="p">})</span>

<span class="w">  </span><span class="nx">it</span><span class="p">(</span><span class="s1">&#39;finds nothing needs backup when there is a match&#39;</span><span class="p">,</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">check</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[[</span><span class="s1">&#39;alpha.js&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;abcd1234&#39;</span><span class="p">]]</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">expected</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{}</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">actual</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">findNew</span><span class="p">(</span><span class="s1">&#39;file-backup/test/bck-1-csv-1&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">check</span><span class="p">)</span>
<span class="w">    </span><span class="nx">assert</span><span class="p">.</span><span class="nx">deepStrictEqual</span><span class="p">(</span><span class="nx">expected</span><span class="p">,</span><span class="w"> </span><span class="nx">actual</span><span class="p">,</span>
<span class="w">      </span><span class="s1">&#39;Expected no files&#39;</span><span class="p">)</span>
<span class="w">  </span><span class="p">})</span>

<span class="w">  </span><span class="nx">it</span><span class="p">(</span><span class="s1">&#39;finds something needs backup when there is a mismatch&#39;</span><span class="p">,</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">check</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[[</span><span class="s1">&#39;alpha.js&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;a1b2c3d4&#39;</span><span class="p">]]</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">expected</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">a1b2c3d4</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;alpha.js&#39;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">actual</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">findNew</span><span class="p">(</span><span class="s1">&#39;file-backup/test/bck-1-csv-1&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">check</span><span class="p">)</span>
<span class="w">    </span><span class="nx">assert</span><span class="p">.</span><span class="nx">deepStrictEqual</span><span class="p">(</span><span class="nx">expected</span><span class="p">,</span><span class="w"> </span><span class="nx">actual</span><span class="p">,</span>
<span class="w">      </span><span class="s1">&#39;Expected one file&#39;</span><span class="p">)</span>
<span class="w">  </span><span class="p">})</span>

<span class="w">  </span><span class="nx">it</span><span class="p">(</span><span class="s1">&#39;finds mixed matches&#39;</span><span class="p">,</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">check</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span>
<span class="w">      </span><span class="p">[</span><span class="s1">&#39;matches.js&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;3456cdef&#39;</span><span class="p">],</span>
<span class="w">      </span><span class="p">[</span><span class="s1">&#39;matches.txt&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;abcd1234&#39;</span><span class="p">],</span>
<span class="w">      </span><span class="p">[</span><span class="s1">&#39;mismatch.txt&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;12345678&#39;</span><span class="p">]</span>
<span class="w">    </span><span class="p">]</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">expected</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">12345678</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;mismatch.txt&#39;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">actual</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">findNew</span><span class="p">(</span><span class="s1">&#39;file-backup/test/bck-4-csv-2&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">check</span><span class="p">)</span>
<span class="w">    </span><span class="nx">assert</span><span class="p">.</span><span class="nx">deepStrictEqual</span><span class="p">(</span><span class="nx">expected</span><span class="p">,</span><span class="w"> </span><span class="nx">actual</span><span class="p">,</span>
<span class="w">      </span><span class="s1">&#39;Expected one file&#39;</span><span class="p">)</span>
<span class="w">  </span><span class="p">})</span>
<span class="p">})</span>
</code></pre></div>
</div>
<p class="continue">and here is Mocha&rsquo;s report:</p>
<div class="code-sample lang-out" title="test-check-filesystem.out">
<div class="highlight"><pre><span></span><code>&gt; stjs@1.0.0 test
&gt; mocha */test/test-*.js &quot;-g&quot; &quot;pre-existing hashes&quot;


  pre-existing hashes and actual filesystem
    ✓ finds no pre-existing files when none given or exist
    ✓ finds some files when one is given and none exist
    ✓ finds nothing needs backup when there is a match
    ✓ finds something needs backup when there is a mismatch
    ✓ finds mixed matches


  5 passing (16ms)
</code></pre></div>
</div>
<h2 id="file-backup-test">Section 5.4: How can we test code that modifies files?</h2>
<p>The final thing our tool needs to do
is copy the files that need copying and create a new index file.
The code itself will be relatively simple,
but testing will be complicated by the fact
that our tests will need to create directories and files before they run
and then delete them afterward
(so that they don&rsquo;t contaminate subsequent tests).</p>
<p>A better approach is to use a <span class="ix-entry" ix-key="mock object!for testing;unit test!using mock object" markdown="1"><a class="gl-ref" href="../glossary/#mock_object" markdown="1">mock object</a></span>
instead of the real filesystem.
A mock object has the same interface as the function, object, class, or library that it replaces,
but is designed to be used solely for testing.
Node&rsquo;s <a href="https://www.npmjs.com/package/mock-fs"><code>mock-fs</code></a> library provides the same functions as the <code>fs</code> library,
but stores everything in memory
(<a class="fig-ref" href="../file-backup/#file-backup-mock-fs">Figure 5.4</a>).
This prevents our tests from accidentally disturbing the filesystem,
and also makes tests much faster
(since in-memory operations are thousands of times faster than operations that touch the disk).</p>
<figure id="file-backup-mock-fs">
  <img src="./mock-fs.svg" alt="Mock filesystem"/>
  <figcaption markdown="1">Figure 5.4: Using a mock filesystem to simplify testing.</figcaption>
</figure>

<p>We can create a mock filesystem by giving the library a JSON description of
the files and what they should contain:</p>
<div class="code-sample lang-js" title="test-find-mock.js">
<div class="highlight"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">assert</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;assert&#39;</span>
<span class="k">import</span><span class="w"> </span><span class="nx">mock</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;mock-fs&#39;</span>

<span class="k">import</span><span class="w"> </span><span class="nx">findNew</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;../check-existing-files.js&#39;</span>

<span class="nx">describe</span><span class="p">(</span><span class="s1">&#39;checks for pre-existing hashes using mock filesystem&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">beforeEach</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">mock</span><span class="p">({</span>
<span class="w">      </span><span class="s1">&#39;bck-0-csv-0&#39;</span><span class="o">:</span><span class="w"> </span><span class="p">{},</span>
<span class="w">      </span><span class="s1">&#39;bck-1-csv-1&#39;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="s1">&#39;0001.csv&#39;</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;alpha.js,abcd1234&#39;</span><span class="p">,</span>
<span class="w">        </span><span class="s1">&#39;abcd1234.bck&#39;</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;alpha.js content&#39;</span>
<span class="w">      </span><span class="p">},</span>
<span class="w">      </span><span class="s1">&#39;bck-4-csv-2&#39;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="s1">&#39;0001.csv&#39;</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="s1">&#39;alpha.js,abcd1234&#39;</span><span class="p">,</span>
<span class="w">          </span><span class="s1">&#39;beta.txt,bcde2345&#39;</span><span class="p">].</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;\n&#39;</span><span class="p">),</span>
<span class="w">        </span><span class="s1">&#39;3024.csv&#39;</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="s1">&#39;alpha.js,abcd1234&#39;</span><span class="p">,</span>
<span class="w">          </span><span class="s1">&#39;gamma.png,3456cdef&#39;</span><span class="p">,</span>
<span class="w">          </span><span class="s1">&#39;subdir/renamed.txt,bcde2345&#39;</span><span class="p">].</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;\n&#39;</span><span class="p">),</span>
<span class="w">        </span><span class="s1">&#39;3456cdef.bck&#39;</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;gamma.png content&#39;</span><span class="p">,</span>
<span class="w">        </span><span class="s1">&#39;abcd1234.bck&#39;</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;alpha content&#39;</span><span class="p">,</span>
<span class="w">        </span><span class="s1">&#39;bcde2345.bck&#39;</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;beta.txt became subdir/renamed.txt&#39;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">})</span>
<span class="w">  </span><span class="p">})</span>

<span class="w">  </span><span class="nx">afterEach</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">mock</span><span class="p">.</span><span class="nx">restore</span><span class="p">()</span>
<span class="w">  </span><span class="p">})</span>

<span class="p">})</span>
</code></pre></div>
</div>
<p class="continue"><span class="ix-entry" ix-key="Mocha!beforeEach" markdown="1">Mocha</span> automatically calls <code>beforeEach</code> before running each tests,
and <span class="ix-entry" ix-key="Mocha!afterEach" markdown="1"><code>afterEach</code></span> after each tests completes
(which is yet another <span class="ix-entry" ix-key="protocol!for unit testing" markdown="1">protocol</span>).
All of the tests stay exactly the same,
and since <code>mock-fs</code> replaces the functions in the standard <code>fs</code> library with its own,
nothing in our application needs to change either.</p>
<p>We are finally ready to write the program that actually backs up files:</p>
<div class="code-sample lang-js" title="backup.js">
<div class="highlight"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">fs</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;fs-extra-promise&#39;</span>

<span class="k">import</span><span class="w"> </span><span class="nx">hashExisting</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;./hash-existing-async.js&#39;</span>
<span class="k">import</span><span class="w"> </span><span class="nx">findNew</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;./check-existing-files.js&#39;</span>

<span class="kd">const</span><span class="w"> </span><span class="nx">backup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="p">(</span><span class="nx">src</span><span class="p">,</span><span class="w"> </span><span class="nx">dst</span><span class="p">,</span><span class="w"> </span><span class="nx">timestamp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">timestamp</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">timestamp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Math</span><span class="p">.</span><span class="nx">round</span><span class="p">((</span><span class="ow">new</span><span class="w"> </span><span class="nb">Date</span><span class="p">()).</span><span class="nx">getTime</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">1000</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="nx">timestamp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span><span class="p">(</span><span class="nx">timestamp</span><span class="p">).</span><span class="nx">padStart</span><span class="p">(</span><span class="mf">10</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;0&#39;</span><span class="p">)</span>

<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">existing</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">hashExisting</span><span class="p">(</span><span class="nx">src</span><span class="p">)</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">needToCopy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">findNew</span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span><span class="w"> </span><span class="nx">existing</span><span class="p">)</span>
<span class="w">  </span><span class="k">await</span><span class="w"> </span><span class="nx">copyFiles</span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span><span class="w"> </span><span class="nx">needToCopy</span><span class="p">)</span>
<span class="w">  </span><span class="k">await</span><span class="w"> </span><span class="nx">saveManifest</span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span><span class="w"> </span><span class="nx">timestamp</span><span class="p">,</span><span class="w"> </span><span class="nx">existing</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">const</span><span class="w"> </span><span class="nx">copyFiles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span><span class="w"> </span><span class="nx">needToCopy</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">promises</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">needToCopy</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">hash</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">srcPath</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">needToCopy</span><span class="p">[</span><span class="nx">hash</span><span class="p">]</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">dstPath</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sb">`</span><span class="si">${</span><span class="nx">dst</span><span class="si">}</span><span class="sb">/</span><span class="si">${</span><span class="nx">hash</span><span class="si">}</span><span class="sb">.bck`</span>
<span class="w">    </span><span class="nx">fs</span><span class="p">.</span><span class="nx">copyFileAsync</span><span class="p">(</span><span class="nx">srcPath</span><span class="p">,</span><span class="w"> </span><span class="nx">dstPath</span><span class="p">)</span>
<span class="w">  </span><span class="p">})</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">(</span><span class="nx">promises</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">const</span><span class="w"> </span><span class="nx">saveManifest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span><span class="w"> </span><span class="nx">timestamp</span><span class="p">,</span><span class="w"> </span><span class="nx">pathHash</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">pathHash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">pathHash</span><span class="p">.</span><span class="nx">sort</span><span class="p">()</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">content</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">pathHash</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span>
<span class="w">    </span><span class="p">([</span><span class="nx">path</span><span class="p">,</span><span class="w"> </span><span class="nx">hash</span><span class="p">])</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="sb">`</span><span class="si">${</span><span class="nx">path</span><span class="si">}</span><span class="sb">,</span><span class="si">${</span><span class="nx">hash</span><span class="si">}</span><span class="sb">`</span><span class="p">).</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;\n&#39;</span><span class="p">)</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">manifest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sb">`</span><span class="si">${</span><span class="nx">dst</span><span class="si">}</span><span class="sb">/</span><span class="si">${</span><span class="nx">timestamp</span><span class="si">}</span><span class="sb">.csv`</span>
<span class="w">  </span><span class="nx">fs</span><span class="p">.</span><span class="nx">writeFileAsync</span><span class="p">(</span><span class="nx">manifest</span><span class="p">,</span><span class="w"> </span><span class="nx">content</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">export</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="nx">backup</span>
</code></pre></div>
</div>
<p>The tests for this are more complicated than tests we have written previously
because we want to check with actual file hashes.
Let&rsquo;s set up some fixtures to run tests on:</p>
<div class="code-sample lang-js" title="test-backup.js">
<div class="highlight"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">backup</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;../backup.js&#39;</span>

<span class="kd">const</span><span class="w"> </span><span class="nx">hashString</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">data</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">hasher</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">crypto</span><span class="p">.</span><span class="nx">createHash</span><span class="p">(</span><span class="s1">&#39;sha1&#39;</span><span class="p">).</span><span class="nx">setEncoding</span><span class="p">(</span><span class="s1">&#39;hex&#39;</span><span class="p">)</span>
<span class="w">  </span><span class="nx">hasher</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
<span class="w">  </span><span class="nx">hasher</span><span class="p">.</span><span class="nx">end</span><span class="p">()</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">hasher</span><span class="p">.</span><span class="nx">read</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">const</span><span class="w"> </span><span class="nx">Contents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">aaa</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;AAA&#39;</span><span class="p">,</span>
<span class="w">  </span><span class="nx">bbb</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;BBB&#39;</span><span class="p">,</span>
<span class="w">  </span><span class="nx">ccc</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;CCC&#39;</span>
<span class="p">}</span>

<span class="kd">const</span><span class="w"> </span><span class="nx">Hashes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">Contents</span><span class="p">).</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">obj</span><span class="p">,</span><span class="w"> </span><span class="nx">key</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">obj</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">hashString</span><span class="p">(</span><span class="nx">Contents</span><span class="p">[</span><span class="nx">key</span><span class="p">])</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">obj</span>
<span class="p">},</span><span class="w"> </span><span class="p">{})</span>

<span class="kd">const</span><span class="w"> </span><span class="nx">Fixture</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">source</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="s1">&#39;alpha.txt&#39;</span><span class="o">:</span><span class="w"> </span><span class="nx">Contents</span><span class="p">.</span><span class="nx">aaa</span><span class="p">,</span>
<span class="w">    </span><span class="s1">&#39;beta.txt&#39;</span><span class="o">:</span><span class="w"> </span><span class="nx">Contents</span><span class="p">.</span><span class="nx">bbb</span><span class="p">,</span>
<span class="w">    </span><span class="nx">gamma</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="s1">&#39;delta.txt&#39;</span><span class="o">:</span><span class="w"> </span><span class="nx">Contents</span><span class="p">.</span><span class="nx">ccc</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">},</span>
<span class="w">  </span><span class="nx">backup</span><span class="o">:</span><span class="w"> </span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">const</span><span class="w"> </span><span class="nx">InitialBackups</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">Hashes</span><span class="p">).</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">set</span><span class="p">,</span><span class="w"> </span><span class="nx">filename</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">set</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="sb">`backup/</span><span class="si">${</span><span class="nx">Hashes</span><span class="p">[</span><span class="nx">filename</span><span class="p">]</span><span class="si">}</span><span class="sb">.bck`</span><span class="p">)</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">set</span>
<span class="p">},</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Set</span><span class="p">())</span>
</code></pre></div>
</div>
<p class="continue">and then run some tests:</p>
<div class="code-sample lang-js" title="test-backup.js">
<div class="highlight"><pre><span></span><code><span class="nx">describe</span><span class="p">(</span><span class="s1">&#39;check entire backup process&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">beforeEach</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">mock</span><span class="p">(</span><span class="nx">Fixture</span><span class="p">)</span>
<span class="w">  </span><span class="p">})</span>

<span class="w">  </span><span class="nx">afterEach</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">mock</span><span class="p">.</span><span class="nx">restore</span><span class="p">()</span>
<span class="w">  </span><span class="p">})</span>

<span class="w">  </span><span class="nx">it</span><span class="p">(</span><span class="s1">&#39;creates an initial CSV manifest&#39;</span><span class="p">,</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">await</span><span class="w"> </span><span class="nx">backup</span><span class="p">(</span><span class="s1">&#39;source&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;backup&#39;</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span>

<span class="w">    </span><span class="nx">assert</span><span class="p">.</span><span class="nx">strictEqual</span><span class="p">((</span><span class="k">await</span><span class="w"> </span><span class="nx">glob</span><span class="p">(</span><span class="s1">&#39;backup/*&#39;</span><span class="p">)).</span><span class="nx">length</span><span class="p">,</span><span class="w"> </span><span class="mf">4</span><span class="p">,</span>
<span class="w">      </span><span class="s1">&#39;Expected 4 files&#39;</span><span class="p">)</span>

<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">actualBackups</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Set</span><span class="p">(</span><span class="k">await</span><span class="w"> </span><span class="nx">glob</span><span class="p">(</span><span class="s1">&#39;backup/*.bck&#39;</span><span class="p">))</span>
<span class="w">    </span><span class="nx">assert</span><span class="p">.</span><span class="nx">deepStrictEqual</span><span class="p">(</span><span class="nx">actualBackups</span><span class="p">,</span><span class="w"> </span><span class="nx">InitialBackups</span><span class="p">,</span>
<span class="w">      </span><span class="s1">&#39;Expected 3 backup files&#39;</span><span class="p">)</span>

<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">actualManifests</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">glob</span><span class="p">(</span><span class="s1">&#39;backup/*.csv&#39;</span><span class="p">)</span>
<span class="w">    </span><span class="nx">assert</span><span class="p">.</span><span class="nx">deepStrictEqual</span><span class="p">(</span><span class="nx">actualManifests</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="s1">&#39;backup/0000000000.csv&#39;</span><span class="p">],</span>
<span class="w">      </span><span class="s1">&#39;Expected one manifest&#39;</span><span class="p">)</span>
<span class="w">  </span><span class="p">})</span>

<span class="w">  </span><span class="nx">it</span><span class="p">(</span><span class="s1">&#39;does not duplicate files unnecessarily&#39;</span><span class="p">,</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">await</span><span class="w"> </span><span class="nx">backup</span><span class="p">(</span><span class="s1">&#39;source&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;backup&#39;</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span>
<span class="w">    </span><span class="nx">assert</span><span class="p">.</span><span class="nx">strictEqual</span><span class="p">((</span><span class="k">await</span><span class="w"> </span><span class="nx">glob</span><span class="p">(</span><span class="s1">&#39;backup/*&#39;</span><span class="p">)).</span><span class="nx">length</span><span class="p">,</span><span class="w"> </span><span class="mf">4</span><span class="p">,</span>
<span class="w">      </span><span class="s1">&#39;Expected 4 files after first backup&#39;</span><span class="p">)</span>

<span class="w">    </span><span class="k">await</span><span class="w"> </span><span class="nx">backup</span><span class="p">(</span><span class="s1">&#39;source&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;backup&#39;</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span>
<span class="w">    </span><span class="nx">assert</span><span class="p">.</span><span class="nx">strictEqual</span><span class="p">((</span><span class="k">await</span><span class="w"> </span><span class="nx">glob</span><span class="p">(</span><span class="s1">&#39;backup/*&#39;</span><span class="p">)).</span><span class="nx">length</span><span class="p">,</span><span class="w"> </span><span class="mf">5</span><span class="p">,</span>
<span class="w">      </span><span class="s1">&#39;Expected 5 files after second backup&#39;</span><span class="p">)</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">actualBackups</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Set</span><span class="p">(</span><span class="k">await</span><span class="w"> </span><span class="nx">glob</span><span class="p">(</span><span class="s1">&#39;backup/*.bck&#39;</span><span class="p">))</span>
<span class="w">    </span><span class="nx">assert</span><span class="p">.</span><span class="nx">deepStrictEqual</span><span class="p">(</span><span class="nx">actualBackups</span><span class="p">,</span><span class="w"> </span><span class="nx">InitialBackups</span><span class="p">,</span>
<span class="w">      </span><span class="s1">&#39;Expected 3 backup files after second backup&#39;</span><span class="p">)</span>

<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">actualManifests</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">await</span><span class="w"> </span><span class="nx">glob</span><span class="p">(</span><span class="s1">&#39;backup/*.csv&#39;</span><span class="p">)).</span><span class="nx">sort</span><span class="p">()</span>
<span class="w">    </span><span class="nx">assert</span><span class="p">.</span><span class="nx">deepStrictEqual</span><span class="p">(</span><span class="nx">actualManifests</span><span class="p">,</span>
<span class="w">      </span><span class="p">[</span><span class="s1">&#39;backup/0000000000.csv&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;backup/0000000001.csv&#39;</span><span class="p">],</span>
<span class="w">      </span><span class="s1">&#39;Expected two manifests&#39;</span><span class="p">)</span>
<span class="w">  </span><span class="p">})</span>

<span class="w">  </span><span class="nx">it</span><span class="p">(</span><span class="s1">&#39;adds a file as needed&#39;</span><span class="p">,</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">await</span><span class="w"> </span><span class="nx">backup</span><span class="p">(</span><span class="s1">&#39;source&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;backup&#39;</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span>
<span class="w">    </span><span class="nx">assert</span><span class="p">.</span><span class="nx">strictEqual</span><span class="p">((</span><span class="k">await</span><span class="w"> </span><span class="nx">glob</span><span class="p">(</span><span class="s1">&#39;backup/*&#39;</span><span class="p">)).</span><span class="nx">length</span><span class="p">,</span><span class="w"> </span><span class="mf">4</span><span class="p">,</span>
<span class="w">      </span><span class="s1">&#39;Expected 4 files after first backup&#39;</span><span class="p">)</span>

<span class="w">    </span><span class="k">await</span><span class="w"> </span><span class="nx">fs</span><span class="p">.</span><span class="nx">writeFileAsync</span><span class="p">(</span><span class="s1">&#39;source/newfile.txt&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;NNN&#39;</span><span class="p">)</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">hashOfNewFile</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">hashString</span><span class="p">(</span><span class="s1">&#39;NNN&#39;</span><span class="p">)</span>

<span class="w">    </span><span class="k">await</span><span class="w"> </span><span class="nx">backup</span><span class="p">(</span><span class="s1">&#39;source&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;backup&#39;</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span>
<span class="w">    </span><span class="nx">assert</span><span class="p">.</span><span class="nx">strictEqual</span><span class="p">((</span><span class="k">await</span><span class="w"> </span><span class="nx">glob</span><span class="p">(</span><span class="s1">&#39;backup/*&#39;</span><span class="p">)).</span><span class="nx">length</span><span class="p">,</span><span class="w"> </span><span class="mf">6</span><span class="p">,</span>
<span class="w">      </span><span class="s1">&#39;Expected 6 files after second backup&#39;</span><span class="p">)</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">expected</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Set</span><span class="p">(</span><span class="nx">InitialBackups</span><span class="p">)</span>
<span class="w">      </span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="sb">`backup/</span><span class="si">${</span><span class="nx">hashOfNewFile</span><span class="si">}</span><span class="sb">.bck`</span><span class="p">)</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">actualBackups</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Set</span><span class="p">(</span><span class="k">await</span><span class="w"> </span><span class="nx">glob</span><span class="p">(</span><span class="s1">&#39;backup/*.bck&#39;</span><span class="p">))</span>
<span class="w">    </span><span class="nx">assert</span><span class="p">.</span><span class="nx">deepStrictEqual</span><span class="p">(</span><span class="nx">actualBackups</span><span class="p">,</span><span class="w"> </span><span class="nx">expected</span><span class="p">,</span>
<span class="w">      </span><span class="s1">&#39;Expected 4 backup files after second backup&#39;</span><span class="p">)</span>

<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">actualManifests</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">await</span><span class="w"> </span><span class="nx">glob</span><span class="p">(</span><span class="s1">&#39;backup/*.csv&#39;</span><span class="p">)).</span><span class="nx">sort</span><span class="p">()</span>
<span class="w">    </span><span class="nx">assert</span><span class="p">.</span><span class="nx">deepStrictEqual</span><span class="p">(</span><span class="nx">actualManifests</span><span class="p">,</span>
<span class="w">      </span><span class="p">[</span><span class="s1">&#39;backup/0000000000.csv&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;backup/0000000001.csv&#39;</span><span class="p">],</span>
<span class="w">      </span><span class="s1">&#39;Expected two manifests&#39;</span><span class="p">)</span>
<span class="w">  </span><span class="p">})</span>
<span class="p">})</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="test-backup.out">
<div class="highlight"><pre><span></span><code>&gt; stjs@1.0.0 test
&gt; mocha */test/test-*.js &quot;-g&quot; &quot;check entire backup process&quot;



  check entire backup process
    ✓ creates an initial CSV manifest
    ✓ does not duplicate files unnecessarily
    ✓ adds a file as needed


  3 passing (18ms)
</code></pre></div>
</div>
<div class="callout">
<h3>Design for test</h3>
<p>One of the best ways&mdash;maybe <em>the</em> best way&mdash;to evaluate software design
is by thinking about <span class="ix-entry" ix-key="testability!as design criterion;software design!testability" markdown="1">testability</span> <span class="bib-ref">[<a class="bib-ref" href="../bibliography/#Feathers2004">Feathers2004</a>]</span>.
We were able to use a mock filesystem instead of a real one
because the filesystem has a well-defined API
that is provided to us in a single library,
so replacing it is a matter of changing one thing in one place.
If you have to change several parts of your code in order to test it,
the code is telling you to consolidate those parts into one component.</p>
</div>
<h2 id="file-backup-exercises">Section 5.5: Exercises</h2>
<h3 class="exercise">Odds of collision</h3>
<p>If hashes were only 2 bits long,
then the chances of collision with each successive file
assuming no previous collision are:</p>
<table>
<thead>
<tr>
<th>Number of Files</th>
<th>Odds of Collision</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0%</td>
</tr>
<tr>
<td>2</td>
<td>25%</td>
</tr>
<tr>
<td>3</td>
<td>50%</td>
</tr>
<tr>
<td>4</td>
<td>75%</td>
</tr>
<tr>
<td>5</td>
<td>100%</td>
</tr>
</tbody>
</table>
<p>A colleague of yours says this means that if we hash four files,
there&rsquo;s only a 75% chance of any collision occurring.
What are the actual odds?</p>
<h3 class="exercise">Streaming I/O</h3>
<p>Write a small program using <code>fs.createReadStream</code> and <code>fs.createWriteStream</code>
that copies a file piece-by-piece
instead of reading it into memory and then writing it out again.</p>
<h3 class="exercise">Sequencing backups</h3>
<p>Modify the backup program so that manifests are numbered sequentially
as <code>00000001.csv</code>, <code>00000002.csv</code>, and so on
rather than being timestamped.
Why doesn&rsquo;t this solve the time of check/time of use race condition mentioned earlier?</p>
<h3 class="exercise">JSON manifests</h3>
<ol>
<li>
<p>Modify <code>backup.js</code> so that it can save JSON manifests as well as CSV manifests
    based on a command-line flag.</p>
</li>
<li>
<p>Write another program called <code>migrate.js</code> that converts a set of manifests
    from CSV to JSON.
    (The program&rsquo;s name comes from the term <a class="gl-ref" href="../glossary/#data_migration" markdown="1">data migration</a>.)</p>
</li>
<li>
<p>Modify <code>backup.js</code> programs so that each manifest stores the user name of the person who created it
    along with file hashes,
    and then modify <code>migrate.js</code> to transform old files into the new format.</p>
</li>
</ol>
<h3 class="exercise">Mock hashes</h3>
<ol>
<li>
<p>Modify the file backup program so that it uses a function called <code>ourHash</code> to hash files.</p>
</li>
<li>
<p>Create a replacement that returns some predictable value, such as the first few characters of the data.</p>
</li>
<li>
<p>Rewrite the tests to use this function.</p>
</li>
</ol>
<p class="continue">How did you modify the main program so that the tests could control which hashing function is used?</p>
<h3 class="exercise">Comparing manifests</h3>
<p>Write a program <code>compare-manifests.js</code> that reads two manifest files and reports:</p>
<ul>
<li>
<p>Which files have the same names but different hashes
    (i.e., their contents have changed).</p>
</li>
<li>
<p>Which files have the same hashes but different names
    (i.e., they have been renamed).</p>
</li>
<li>
<p>Which files are in the first hash but neither their names nor their hashes are in the second
    (i.e., they have been deleted).</p>
</li>
<li>
<p>Which files are in the second hash but neither their names nor their hashes are in the first
    (i.e., they have been added).</p>
</li>
</ul>
<h3 class="exercise">From one state to another</h3>
<ol>
<li>
<p>Write a program called <code>from-to.js</code> that takes the name of a directory
    and the name of a manifest file
    as its command-line arguments,
    then adds, removes, and/or renames files in the directory
    to restore the state described in the manifest.
    The program should only perform file operations when it needs to,
    e.g.,
    it should not delete a file and re-add it if the contents have not changed.</p>
</li>
<li>
<p>Write some tests for <code>from-to.js</code> using Mocha and <code>mock-fs</code>.</p>
</li>
</ol>
<h3 class="exercise">File history</h3>
<ol>
<li>
<p>Write a program called <code>file-history.js</code>
    that takes the name of a file as a command-line argument
    and displays the history of that file
    by tracing it back in time through the available manifests.</p>
</li>
<li>
<p>Write tests for your program using Mocha and <code>mock-fs</code>.</p>
</li>
</ol>
<h3 class="exercise">Pre-commit hooks</h3>
<p>Modify <code>backup.js</code> to load and run a function called <code>preCommit</code> from a file called <code>pre-commit.js</code>
stored in the root directory of the files being backed up.
If <code>preCommit</code> returns <code>true</code>, the backup proceeds;
if it returns <code>false</code> or throws an exception,
no backup is created.</p>
          
        </main>
      </div>
    </div>
  </body>
</html>
