---
layout: post
root: ../../..
title: "So Far Behind"
date: 2008-10-10 12:27:02
---
I'd like to start this lengthy set of reviews by apologizing to the authors and editors who've been waiting so patiently for me to tell the world about their work.  Buying a house, getting married, selling a house, and taking on a new batch of graduate students is an explanation, but it's not an excuse.

I'd also like to apologize for the fact that these reviews aren't as detailed as they ought to be.  The distractions listed above are part of the reason; the real cause is that academic life doesn't leave me time for programming, so I'm not able or qualified to delve into technical detail the way I used to.  I miss it a lot, and worry that in another couple of years, I will be too out of touch to be able to guide my students.  (And that a couple of years after that, I'll have to wear a tie to work...)

But for now, though, I have a pile o' books here that you might want to read, and the one you'll probably like most is Charles Petzold's <cite>The Annotated Turing</cite>.  My first reaction when I heard about it was, "Why didn't I think of that?" and my second was, "I wonder if he can pull it off?"  The answer to the latter is definitely "yes", and I expect to see "AT" on shelves beside <cite>Godel, Escher, Bach</cite> and other thinkalong books in years to come.

Petzold's idea is simple: take Alan Turing's classic paper "On Computable Numbers, with an Application to the Entscheidungsproblem"---the paper for which he invented the Turing machine---and interpolate enough explanation to make it accessible to a lay reader.  The original paper is broken into chunks ranging in size from a line or two to half a page, and typeset on gray.  In between, Petzold's commentary explains the background to Turing's work, why his "machine" has the features it does, what the significance of various parts of the proof are, and so on.  It would be a great text for a sophomore course on computability, but it's also simply a fun read for anyone who's curious about the intellectual underpinnings of our field.  Five out of five, and I hope it inspires some imitators.

I'd like a lot of people to imitate Neal Ford's <cite>The Productive Programmer</cite> as well.  In fact, I'd like people to imitate Mr. Ford, and the whole point of this book is to make that easy.  In a little over 200 pages, he describes the things he does that allow him to produce more working software per day than most of his peers.  Some are micro-level tricks, like using clipboards that can hold multiple items.  Others, like running code through state-of-the-art static analysis tools or practicing test-driven development, are higher level, but no more or less important.  I came away from the book feeling like I'd just watched one of those cooking shows where you get to see exactly how a great pastry chef makes a pie crust that tastes so much better than yours.   I'll probably never do everything Ford recommends, but I've already switched to a better desktop shortcut tool, and don't plan to switch back.

"Uncle Bob" Martin's <cite>Clean Code</cite> is similar in spirit, and just as worthwhile.  Where Ford touches on everything a developer does in a working day, Martin focuses on what developers produce: code.  I expected most of the topics, such as choosing good variable names and information hiding.  What pleasantly surprised me was how many new things Martin had to say about them, and how well his examples illustrated his points.  I particularly liked Chapter 14, in which he refactors a Java class for handling command-line arguments step by step.  It's the clearest explanation of what refactoring is actually <em>for</em> that I've ever read, and I'm already using it in my software engineering classes.  Don't let the table of contents fool you: no matter how experienced you are, there's enough in here to make owning a copy worthwhile.

Kent Beck's <cite>Implementation Patterns</cite> draws on an equal depth of experience, but focuses more on the ideas that go into the code.  The author says in the introduction that it's meant to sit between the Gang of Four's classic <cite>Design Patterns</cite> and a Java language manual.  I think he does himself a disservice: what he's actually done is catalog the mental building blocks people use to write sequential imperative software.  The chapter on "Methods", for example, includes a few paragraphs on each of 23 micro-patterns, including:
<ul>
	<li>Composed Method---Compose methods out of calls to other methods.</li>
	<li>Intention-Revealing Name---Name methods after what they are intended to do.</li>
	<li>Conversion Constructor---For most conversions, provide a method on the ocnverted object's class that takes the source object as a parameter.</li>
</ul>
It's tempting to say, "Well, everyone knows <em>that</em>," but of course everyone doesn't, and even if they did, categorizing and naming the obvious often reveals a lot that isn't.  As I read the book, I thought about how cool it would be if the status bar in Eclipse could tell me which of these micro-patterns I was using in real time as I typed.  It would be a great teaching tool, and would keep a lot of corner-cutting programmers (myself included) honest.

Stepping back for a moment, Ford, Martin, and Beck's books are all trying to teach a way of seeing the world.  This is much harder than teaching the syntax of Python 3.0 or how to configure Basie, and it's very easy for authors who try to start preaching.  (I know, because that's what I do.)  FM&amp;B all have very definite opinions on how you should think when you're programming; what makes all three books worthwhile is that they set these opinions on the dinner table and hand you a knife and fork, rather than trying to force-feed you or persuade you that yes, you really do like pickled beets.

Lindberg's <cite>Intellectual Property and Open Source</cite> also tries to convey a particular way of thinking.  In this case, the "way" is the one embodied in America's legal code, which, like every other legal code, is contradictory, biased, and out of date.  As you can guess from the title, Lindberg's target is software developers who know at most a few basic terms (and are probably even confused about some of those).  The book is divided into two parts: an eight-chapter introduction to IP law that covers patents, trademarks, copyrights, trade secrets, and their interaction with open source, and six "how to" chapters to help you figure out who owns your idea (and patches that other people submit), apply a license to your code, skirt around the landmines of reverse engineering, and formalize your project.

The writing is clear, and the examples accessible; my only complaints are that some of Lindberg's analogies are a bit of a stretch, and that like most books in this area, his only covers the US.  Those quibbles aside, I really enjoyed it, and think it deserves a place beside Karl Fogel's <cite>Producing Open Source Software</cite> on every open source developer's bookshelf.

Next up are five Pythonic books.  Younker's <cite>Foundations of Agile Python Development</cite> and Ziad&eacute;'s <cite>Expert Python Programming</cite> overlap in many ways: both have chapter-long introductions to version control, talk about packaging Python applications for distribution, preach the agile gospel, and so on.  The major difference is that Ziad&eacute;'s book devotes more space to the advanced features of Python itself, while Younker devotes that space to database programming and setting up build farms.  It would be worth browsing either a few months after starting your first big Python project, just to make sure you hadn't missed anything, but if you have read <cite>The Pragmatic Programmer</cite> or any of its kin, you will already have seen half or more of their contents.  In addition, Ziad&eacute;'s book could use a closer proof-reading: some of the examples have been incorrectly indented during typesetting, and if you don't already understand decorators, the description in Chapter 2 isn't going to make a lot of sense.

Copeland's <cite>Essential SQLAlchemy</cite> and Bennett's <cite>Practical Django Projects</cite> aren't about Python per se, but rather about two popular programming tools built on top of it.  SQLAlchemy is a full-featured object/relational mapping tool that does a very good job of managing persistence, thanks in large part to creative use of Python's metaprogramming features.  I've never used more than a small subset of SQLAlchemy's features, but this book laid out the rest (especially inheritance handling) clearly and in a logical order.

Django, on the other hand, is the most popular of several Rails-style web application frameworks for Python (but uses its own ORM, rather than SQLAlchemy, which tells you all you need to know about why Python's various offerings are still eating Rails' dust).  While Bennett's book was written before the final Django 1.0 release, the examples all seem to work with 1.0.  The writing is clear, and it isn't bedevilled by the typos that made Holovaty and Kaplan-Moss's <cite>Definitive Guide to Django</cite> so frustrating.  Like <cite>Essential SQLAlchemy</cite>, it is a solid, if somewhat predictable, introductions to its subject: here's how to install, here's a "hello, world" application, here's what you need to know to write something that's actually useful, and so on.  I wouldn't have minded a few more screenshots, but on the other hand, not having them <em>did</em> force me to actually run more of the code.

The last book in this batch is Kinser's <cite>Python for Bioinformatics</cite>.  The second part of the title is more important to the author than the first: Kinser's aim is clearly to help scientists do things like analyze gene sequences, and Python is "just" a useful tool for doing that.  Thus, there are chapters on dynamic programming and text mining, rather than on generators or building distribution packages.  I think his just-in-time approach will work well for his intended audience, and the extensive examples are a good way for programmers to learn a little bioinformatics.

Python is my favorite language, but I'm paying more attention to JavaScript with each passing day.  I don't particularly like it, but it has become the C of the internet: the thing that everything else depends on.  I was therefore more than a little excited to get Douglas Crockford's <cite>JavaScript: The Good Parts</cite> in the (physical) mail.  Crockford contributed a very entertaining chapter to <cite>Beautiful Code</cite>, and knows as much about JavaScript as anyone.  In this book, he "...digs through a pile of ogod intentions and blunders to give you a detailed look at all of the genuinely elegant parts of JavaScript..."

At least, that's what the blurb on the back promises.  The actual content was a mixed bag, ranging from unnecessarily-detailed descriptions of the language's syntax (complete with railroad diagrams) and commentary on the APIs of some built-in types to fairly advanced discussion of how closures and objects work, and how best to use them.  A month after finishing it, I'm still not sure who the intended audience is: many parts will leave newcomers bewildered, while experienced programmers will frequently be bored.  It isn't even really the guide to good practice that the title and blurb suggest, as there is too little discussion of why you would do things one way or another.

Adams et al's <cite>Art \&amp; Science of Javascript</cite> seems to have a better idea of who it's for and what its readers already know.  The subtitle, "Inspirational, cutting-edge JavaScript from the world's best", is not far off the mark.  Each of the book's seven chapters walks the reader through building a 3D maze, metaprogramming, debugging with Firebug, and other topics.  There are plenty of annotated code samples, lots of full-color pictures, and most importantly, a refreshing sense of, "Gosh, isn't this cool!"  It definitely shouldn't be anyone's first (or even second) book on JavaScript, but if you're already comfortable with AJAX and drawing on a browser canvas, there are plenty of ideas here for you.

Gill et al's <cite>Mastering Dojo</cite> is a nice counterpoint to the Adams book.  For those who haven't run into it yet, Dojo is a large (some would say "overly large") JavaScript library for building client-side web applications.  Comparable in size to early editions of the Microsoft Foundation Classes or Java's SWING GUI library, it hides most of the differences between various browsers and does what it can to shield programmers from the legacy of design decisions made in the language's early days.  Like Copeland's book on SQLAlchemy, this one does what O'Reilly books do best: it lays out everything a programmer needs to know to use Dojo effectively in a readable order, provides plenty of examples, and isn't shy about describing its limitations and ways to work around them.  I would have liked more illustrations, but the index is well-organized, and the examples are well explained.

While I haven't been paying as much attention to Windows PowerShell (formerly Monad) as I have to JavaScript, I suspect it will have just as much impact on programmers' lives in the long run.  If you haven't seen it, PowerShell takes the Unix pipe-and-filter model to the next level by allowing components to pass streams of objects around.  It might sound like a small change, but it's not: being able to pipe complex data structures through a bunch of filters, and to take advantage of polymorphism, allows PowerShell to do some pretty amazing things.

Kumaravel et al's <cite>Windows PowerShell Programming</cite> assumes readers already get this, and spends most of its time explaining how to extend PowerShell with new capabilities.  You'll need to know a bit about .NET programming to follow the examples, but the payoff is being able to build new power tools with just a few dozen lines of code.  It definitely isn't your grandmother's command line any more...

Finally, there is Allemang and Hendler's <cite>Semantic Web for the Working Ontologist</cite>, a (very) detailed introduction to the semantic web's approach to modeling data.  You won't find a lot of code in the traditional sense in this book; instead, the authors present one real-world data management problem after another, and show how to represent and solve it using RDF, SPARQL, and related technologies.  A friend of mine with a master's degree in library science littered her copy of this book with sticky notes, some of which had double exclamation marks on it.  I wasn't quite as enthusiastic, but that's probably just a reflection of the fact that I don't usually have data complex enough to need this depth of analysis.  If I ever get around to rewriting <cite>Data Crunching</cite>, though, I'll go through this book again very carefully: while the authors occasionally lose the forest in the trees, they are very careful to motivate every new twist and wrinkle they introduce, and their "challenge problems" do a good job of testing the reader's understanding of the material.

And that's all---fifteen books, read over five months, and reviewed in as many days.  As I said at the outset, I don't have time to program any more, so I may have missed some crucial details.  If so, I apologize in advance; corrections are awlays welcome.  Until then, it's a beautiful day outside, and I'm going to take my daughter to the park to play on the slide.  The big slide, mind you, not the little one---it really does make a difference, and I'm very happy to be re-learning it.

<hr />
<ol>
	<li>Dean Allemang and James Hendler: <a href="http://www.amazon.com/Semantic-Web-Working-Ontologist-Effective/dp/0123735564"><cite>Semantic Web for the Working Ontologist</cite></a>.  Morgan Kaufmann, 0123735564, 2008, 352 pages.</li>
	<li>Cameron Adams, James Edwards, Christian Heilmann, Michael Mahemoff, Ara Pehlivanian, Dan Webb, and Simon Willison: <a href="http://www.amazon.com/Art-Science-JavaScript-Cameron-Adams/dp/0980285844"><cite>The Art &amp; Science of JavaScript</cite></a>.  SitePoint, 2007, 0980285844, 300 pages.</li>
	<li>Kent Beck: <a href="http://www.amazon.com/Implementation-Patterns-Addison-Wesley-Signature-Kent/dp/0321413091"><cite>Implementation Patterns</cite></a>.  Addison-Wesley, 2007, 0321413091, 176 pages.</li>
	<li>James Bennett: <a href="http://www.amazon.com/Practical-Django-Projects-Pratical/dp/1590599969"><cite>Practical Django Projects</cite></a>.  Apress, 2008, 1590599969, 256 pages.</li>
	<li>Rick Copeland: <a href="http://www.amazon.com/Essential-SQLAlchemy-Rick-Copeland/dp/0596516142"><cite>Essential SQLAlchemy</cite></a>.  O'Reilly, 2008, 0596516142, 230 pages.</li>
	<li>Douglas Crockford: <a href="http://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742"><cite>JavaScript: The Good Parts</cite></a>.  O'Reilly, 2008, 0596517742, 170 pages.</li>
	<li>Neal Ford: <a href="http://www.amazon.com/Productive-Programmer-Theory-Practice-OReilly/dp/0596519788"><cite>The Productive Programmer</cite></a>.  O'Reilly, 2008, 0596519788, 222 pages.</li>
	<li>Rawld Gill, Craig Riecke, and Alex Russell: <a href="http://www.amazon.com/Mastering-Dojo-JavaScript-Experiences-Programmers/dp/1934356115"><cite>Mastering Dojo</cite></a>.  Pragmatic Bookshelf, 2008, 1934356115, 568 pages.</li>
	<li>Jason Kinser: <a href="http://www.amazon.com/Python-Bioinformatics-Bartlett-Biomedical-Informatics/dp/0763751863"><cite>Python for Bioinformatics</cite></a>.  Jones &amp; Bartlett, 2008, 0763751863, 417 pages.</li>
	<li>Arul Kumaravel, Jon White, Maixin Li, Scott Happell, Guohui Xie, and Krishna C. Vutukuri: <a href="http://www.amazon.com/Professional-Windows-PowerShell-Programming-Providers/dp/0470173939"><cite>Professional Windows PowerShell Programming</cite></a>. Wrox, 2008, 0470173939, 336 pages.</li>
	<li>Van Lindberg: <a href="http://www.amazon.com/Intellectual-Property-Open-Source-Protecting/dp/0596517963"><cite>Intellectual Property and Open Source</cite></a>.  O'Reilly, 2008, 0596517963, 390 pages.</li>
	<li>Robert C. Martin: <a href="http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882"><cite>Clean Code: A Handbook of Agile Software Craftsmanship</cite></a>.  Prentice Hall PTR, 2008, 0132350882, 464 pages.</li>
	<li>Charles Petzold: <a href="http://www.amazon.com/Annotated-Turing-Through-Historic-Computability/dp/0470229055"><cite>The Annotated Turing</cite></a>.  Wiley, 2008, 0470229055, 384 pages.</li>
	<li>Jeff Younker: <a href="http://www.amazon.com/Foundations-Python-Development-Experts-Source/dp/1590599810"><cite>Foundations of Agile Python Development</cite></a>.  Apress, 2008, 1590599810, 416 pages.</li>
	<li>Tarek Ziad&eacute;: <a href="http://www.amazon.com/Expert-Python-Programming-Tarek-Ziad&eacute;/dp/184719494X"><cite>Expert Python Programming</cite></a>.  Packt Publishing, 2008, 184719494X, 372 pages.</li>
</ol>
