---
layout: post
date: 2019-02-16 02:21
title: "Late Binding"
---

I've been working on [a new Jekyll template for lessons](https://github.com/merely-useful/template)
that can also be used to produce nicely-formatted PDFs,
mostly to give myself an excuse to do a little programming every once in a while.
I wanted to do the whole thing in pure GitHub Pages-compatible Jekyll without any plugins or compilation,
but section references defeated me,
so authors still have to run a little script to regenerate a table of contents and commit it.

What I noticed while building this template is I'm still very much a static programmer.
Thirty-nine years after I started writing Pascal,
I still think in terms of compiling things to completion before letting anyone see any results.
For example,
I started writing a script to find cross-references in the pages generated by Jekyll
and fix them up
so that I could commit the post-processed HTML to Git;
I really had to struggle to give myself permission to write a few lines of JavaScript
to do this in the pages as they were loaded
(which is simpler in several ways).
Similarly,
I wrote a short Python script to tidy up the LaTeX that Pandoc generates from that HTML.
It originally contained a list of transformation functions;
I knew that I could look them up dynamically,
but my early-80s instincts kept telling me, "Nope, that's too clever, something will go wrong."

Paradoxically,
I trend the other way when teaching.
Toby Hodges and I have put together
[a tutorial on JavaScript for data scientists](https://software-tools-in-javascript.github.io/js-vs-ds/),
but I don't think I'll ever teach it exactly as written.
I always improvise based on who's in my audience and whatever bright ideas I had in the shower that morning.
It makes co-instruction harder,
but if I'm teaching on my own,
I find it more effective and more fun.

And maybe that's the difference.
Dynamic function lookup can be elegant,
but it imposes a higher cognitive load on someone who's trying to figure out
exactly what's going to happen in what order,
because that order is implied by control structure rather than written out explicitly.
Maybe I prefer static code over dynamic code because the former is easier for the next person to understand,
and I'm always coding with the next person in mind.
Maybe I like dynamic teaching because I still think of it as a solo activity.
