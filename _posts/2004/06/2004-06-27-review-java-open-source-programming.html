---
layout: post
root: ../../..
title: "Review: Java Open Source Programming"
date: 2004-06-27 20:17:02
---
Joe Walnes, Ara Abrahamian, Mike Cannon-Brookes, and Pat Lightbody:
Java Open Source Programming.  Wiley, 2004, 0471463620, 459 pages.

<hr />In physics, the Standard Model is today's baseline explanation of How
It All Works.  It encompasses quarks, leptons, force-carrying
particles---pretty much everything except gravity.  From subatomic
physics to cosmology, practically everyone builds their theory in its
image, hoping to create a new standard to supplant today's.

For developers of my generation, the Standard Model of programming
consisted of C, Emacs, Make, Unix command-line tools like cat and
grep, CVS, and character streams.  Now, twenty-five years later, a
replacement is taking shape.  Its main elements are:
<ul>
	<li>Java</li>
	<li>Eclipse and its many plugins</li>
	<li>Ant (for building), JUnit (for testing), and Subversion (for version
control)</li>
	<li>reflection for making systems extensible; and</li>
	<li>XML as a universal storage format.</li>
</ul>
So much of this New Standard Model is open source that most of the
books describing it---including this new one from Walnes et al---have
the word in their title.  The first half of JOSP shows readers how
to build yet another on-line pet store.  Instead of starting with
servlets, however, the authors begin by explaining how they will test
the application with JUnit and dynamically-generated mock objects, and
how they will use Hibernate to handle database persistence.

The application itself is then built using WebWork (a
Model-View-Controller framework) and SiteMesh (for layout).  Search is
added using Lucene, XDoclet is used to generate configuration files
from metadata embedded in the Java source, and then the authors pause
to describe how they communicate via CVS, wikis, mailing lists, IRC,
and so on.

And we're not even at page 200 yet...

The second half of the book goes back over the application, replacing
the simple throwaway prototypes of the first half with versions that
could carry their weight in the real world.  Want to know how an
experienced developer figures out how to manage object lifecycles and
dependencies?  That's Chapter 14.  Look and feel?  Chapter 17.
There's even some discussion of security, although this material felt
like an afterthought, and didn't quite live up to the standard set by
the rest of the book.

Which is quite high.  The writing is clean, the examples are explained
well, and the authors didn't waste time grinding methodological axes.
It's definitely not for beginners, but every professional developer
will find something useful in this clear, topical survey.
