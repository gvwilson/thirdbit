---
title: "Given Infinite Minions"
date: 2016-10-19 07:00
year: 2016
---
<p>
  My browser home page has a "to do" list and a "to don't" list.
  The former is things that I should be working on;
  the latter is things that I shouldn't let myself do
  (at least, not yet).
  There's more than this,
  like fiction I want to finish,
  but that's <a href="http://sensibleadventures.com">a story for a different site</a>.
  Maybe some day I'll reconcile myself to the knowledge that
  there just isn't time to do it all.
  Meanwhile,
  if you're interested in doing any of these,
  or already have,
  please give me a shout.
</p>

<dl>

<dt>An undergraduate course in empirical software engineering</dt>
<dd>
  <p>
    <a href="http://third-bit.com/2014/10/02/a-better-software-engineering-course.html">This post</a> describes the idea,
    and <a href="http://third-bit.com/2015/11/29/exaptation.html">this one</a> explains why the time is right.
  </p>
</dd>

<dt>Teach programmers how to run grassroots get-into-coding groups</dt>
<dd>
  <p>
    Ironically,
    programmers create get-into-coding groups so that people won't have to teach themselves how to write Javascript,
    but then reinvent all the wheels when it comes to teaching, running a non-profit, or organizing a community.
    I think it would be cool to combine the Software Carpentry instructor training course
    with material on <a href="https://www.amazon.com/Building-Powerful-Community-Organizations-Personal/dp/0977151808/">building community organizations</a>
    to fill in those gaps.
  </p>
</dd>

<dt><a href="https://www.amazon.com/Discussion-Book-Great-People-Talking/dp/1119049717/"><em>The Discussion Book</em></a> online</dt>
<dd>
  <p>
    Today's MOOC platforms use the Internet like television.
    What would they look like if they directly supported some of the techniques described in
    <a href="https://www.amazon.com/Discussion-Book-Great-People-Talking/dp/1119049717/">this useful book</a>?
  </p>
</dd>

<dt><a href="http://third-bit.com/browsercast/">Browsercast</a></dt>
<dd>
  <p>
    Allow people to create synchronized voiceovers for HTML slideshows.
    I've had several summer students take a run at this;
    the hard part is the authoring tool to add time marks,
    but as the demo linked in the title shows,
    the idea itself works.
  </p>
</dd>

<dt><a href="http://aosabook.org/en/buy.html#fh"><em>500 Lines or Less</em></a> - for science!</dt>
<dd>
  <p>
    Can you write a climate simulator in less than 500 lines of Python?
    What about constructing phylogenetic trees in less than 500 lines of R?
    This collection would show readers how science is turned into code across a broad range of disciplines.
    Each entry is 200-300 lines of scientific code,
    and another 200-300 lines showing readers how to <em>test</em> simple versions of a broad range of scientific applications.
  </p>
</dd>

<dt><em>A Hundred Broken Programs</em></dt>
<dd>
  <p>
    In the spirit of Johnson's <a href="https://www.amazon.com/GUI-Bloopers-2-0-Second-Technologies/dp/0123706432/"><em>GUI Bloopers</em></a>,
    this book teaches debugging by working through a hundred short examples,
    each showing a different kind of fault, a different method of diagnosis, or a different kind of fix.
  </p>
</dd>

<dt><em>The Encyclopedia of Error Handling</em></dt>
<dd>
  <p>
    How do programmers detect and handle errors?
    This companion to <em>A Hundred Broken Programs</em> would cover everything from type-checking during compilation
    to exception handling, rolling back transactions, and re-starting servers.
  </p>
</dd>

<dt>An Empirical Comparison of the Syntax of Python, R, MATLAB, and Julia</dt>
<dd>
  <p>
    We tried to repeat <a href="http://neverworkintheory.org/2014/01/29/stefik-siebert-syntax.html">Stefik et al's study of programming language syntax</a>
    for languages commonly used in science,
    but weren't able to get enough subjects.
    I think it's worth trying again,
    both for its own sake and to show that this kind of work can and should be done.
  </p>
</dd>

<dt><a href="https://hapgood.us/2016/05/13/choral-explanations/">Choral Explanations</a></dt>
<dd>
  <p>
    Just as MOOCs are mistakenly treating the Internet like television,
    Caulfield's notion of choral explanations has me thinking that
    I've been mistaken in trying to treat lesson construction as software development.
    A "lesson" platform that uses Stack Overflow as its model rather than GitHub or Wikipedia
    would be fascinating to explore,
    as would <a href="{{'/2016/09/12/collaborative-choral-software-exegesis/' | relative_url}}">collaborative choral software exegesis</a>.
  </p>
</dd>

<dt><a href="https://blog.jonudell.net/2011/01/24/seven-ways-to-think-like-the-web/">Teaching People to Think Like the Web</a></dt>
<dd>
  <p>
    Jon Udell's <a href="https://blog.jonudell.net/elmcity-project-faq/">Elm City</a> calendar syndication project wasn't really about calendars:
    it was about teaching people how to think like the web.
    I have yet to see a better approach,
    and it would be exciting to resurrect this project and try again.
  </p>
</dd>

<dt><em>Software Tools</em> for the 21st Century</dt>
<dd>
  <p>
    I firmly believe that the Kernighan Trilogy
    (<a href="https://www.amazon.com/Software-Tools-Brian-W-Kernighan/dp/020103669X/"><em>Software Tools</em></a>,
    <a href="https://www.amazon.com/Unix-Programming-Environment-Prentice-Hall-Software/dp/013937681X/"><em>The Unix Programming Environment</em></a>,
    and <a href="https://www.amazon.com/Programming-Language-Brian-W-Kernighan/dp/0131103628/"><em>The C Programming Language</em></a>)
    are the main reason that Unix succeeded.
    I would really like an update that uses a modern operating system and a modern programming language (preferably functional),
    borrows heavily from <a href="https://en.wikipedia.org/wiki/PowerShell">PowerShell</a> and the like,
    and takes Udell's "seven ways" to heart.
  </p>
</dd>

<dt><em>Managing Research Software Projects</em></dt>
<dd>
  <p>
    Your graduate degree is in ecology,
    but now you're running a three-person team responsible for building and maintaining a hundred thousand lines of code?
    This book (or course, or whatever) is everything you absolutely, positively need to know
    <em>after</em> you know how to program.
    (We've started work on this,
    but more hands would be welcome.)
  </p>
</dd>

<dt>Temporal cluster analysis to find <em>actual</em> design patterns</dt>
<dd>
  <p>
    I often use Sajaniemi et al's <a href="http://www.cs.joensuu.fi/~saja/var_roles/stud_vers/stud_Python3_eng.html">roles of variables</a> in teaching,
    but like <a href="https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/">the classic design patterns</a>,
    they were "discovered" by eyeballing novice code.
    I think that cluster analysis of patterns of class and variable use would uncover more patterns,
    and confirm my suspicion that some of the classics are really just different names for the same thing.
  </p>
</dd>

<dt><em>The Undergraduate Owner's Manual</em></dt>
<dd>
  <p>
    I would really like to run a one-semester course for first-year undergraduates whose subject was themselves.
    What happens in your brain when you learn something, and how can you learn more efficiently?
    What's the effect of sleep deprivation on the quality of work?
    How can you analyze the social dynamics of a classroom, or change them to make participation fairer?
    How can you run a small group project?
    Who decides what gets taught at universities and who gets to take part?
  </p>
</dd>

</dl>
