---
layout: post
title: "Five Books on Architecture and Engineering"
date: 2006-08-03 13:39:43
---
I've been teaching a course on software architecture at the <a href="http://www.cs.utoronto.ca">University of Toronto</a> this summer, while working wit colleagues to rationalize the three-course sequence on software engineering.  As part of that, I've been looking for good textbooks on these subjects, where "good" means "will appeal to senior undergraduate students". Most of these students have never seen anything that was more than a few thousand lines long, and will feel cheated if all they're given is checklists of common sense items.  They'll feel equally cheated by a book that does nothing except exhort them to "plan for change" or "put the customer first", without actually showing them what that means in code.

The best forthe first purpose is Gorton's <a href="http://www.amazon.com/gp/product/3540287132"><cite>Essential Software Architecture</cite></a>.  Like most books on software architecture, Gorton's starts by surveying the many different definitions of the term, and describing what an architect actually does.  He then introduces a small case study, which is used as a running example through the next few chapters, and then talks about the qualities architects strive for, such as performance, scalability, modifiability, security, availability, integration.

With that foundation in place, Gorton moves on to a 40-page guide to middleware, 20 pages on process, and 10 pages (more or less) on how to document an architecture.  These chapters (particularly the one on middleware) are a readable mix of description and advice.  When talking about message brokers, for example, Gorton outlines the kinds of problems they're meant to solve, <em>and</em> the problems they're likely to introduce.

The rest of the book continues in this refreshingly practical vein. He revisits his case study, then moves on to software product lines, aspect-oriented programming (I'm still sceptical, despite his even-handed treatment), model-driven and service-oriented architecture, the semantic web, and agent-based systems.  The last few chapters are co-authored with others, and while the language is sometimes uneven, the content remains rock-solid throughout.

<a href="http://www.amazon.com/gp/product/3540287132"><cite>Essential Software Architecture</cite></a> is head and shoulders above other books on the subject that I've read.  Its only drawback from a teaching point of view is that it's only available in hardcover: students these days are so accustomed to free material on the web that persuading them to part with $60 or more for a book is as big a challenge as convincing them that they ought to be writing more tests.

Where Gorton looks at architecture, Bittner and Spence's <a href="http://www.amazon.com/gp/product/032126889X"><cite>Managing Iterative Software Development Projects</cite></a> looks at process. In a way, this book (and Kroll and MacIsaac's, reviewed below) are a tacit acknowledgment that agile programming's advocates have been winning the "ceremony vs. speed" argument.  Bittner and Spence's hearts are still with the former; they still stress up-front analysis and planning far more than the XP crowd.  However, they put more stress on the need for short iterations and incremental delivery than books from this side of the fence used to.  The result is a very even-handed approach to managing large software projects.

Bittner and Spence start with four chapters on basic principles. Unlike most such discussions, theirs contains a lot of implementable advice, from avoiding feature creep and increasing morale to an explanation of why time boxing works better than scope boxing.  This section of the book also introduces their four-part division of iterations into "inception", "elaboration", "construction", and "transition" phases, a distinction that is one of the most important differences between their methodology and "pure" agile alternatives.

Part II of the book is titled "Planning and Managing an Iterative Project", and that's exactly what it covers.  They almost lost me with the first section, which discusses management layers and responsibilities---deeply-nested org charts are one of the reasons I no longer work for a Fortune 500 company---but they got me back when they started describing how to balance risks across iterations, assembling a plan, and different ways to scale projects up.  None of its 672 pages is particularly light reading, but if you prefer predictability to adventure, this is a good rulebook for your next project.

Like <a href="http://www.amazon.com/gp/product/032126889X"><cite>Managing Iterative Software Development Projects</cite></a>, Kroll and MacIsaac's <a href="http://www.amazon.com/gp/product/0321321308"><cite>Agility and Discipline Made Easy: Practices from OpenUP and RUP</cite></a> is a tacit acknowledgment that the agilistas have been setting the pace for the last few years.  Most of what's here has been part of the Rational Unified Process (RUP) and its kin for years; the difference is mostly the presentation, which basically says, "Agility's great, but you need to have discipline too."

In practice, there's more emphasis on the latter than the former. In fact, I'm not sure that I'd have known this book was about agile development if the word hadn't been in the title.  What it <em>is</em> about is twenty "best practices", ranging from "test your code" to "model key perspectives".  Each one is presented in a standard form: what is the problem the practice seeks to solve, how does one apply it, at what levels can it be adopted, and what other practices are related to it.

So, why would I choose Bittner and Spence, rather than Kroll and MacIsaac?  The main reason is that the former is explicitly prescriptive, i.e., it says "do this, then do that", rather than assuming you have a process and want to tune it.  I also think that Bittner and Spence's book is more approachable: there are places where I think Kroll and MacIsaac assume more familiarity with big projects (and their problems) than most programmers in their early twenties are likely to have.

The fourth book in my pile is the most approachable of all.  Ronald Mak was in charge of building the Collaborative Information Portal (CIP) used to manage the data coming back from NASA's Mars Rovers.  In this slim and very personal volume, he presents twenty principles for building systems of that kind successfully.  Most are common sense, like "don't reinvent the wheel" and "don't ignore people issues", but Mak brings them to life by referring back to his experiences with CIP, and its successes and failures.  He also treats architecture, process, and management as three aspects of a single core problem, which I think is particularly valuable.

It's not often that I ask for a book to be longer, but this is one of those times.  If Mak were to add more of the material that's in Gorton's book, or Bittner and Spence's, I think this would be a great textbook.  As it is, it's still well worth reading, no matter how much experience you already have.

I think Daniel Jackson's <a href="http://www.amazon.com/gp/product/0262101149"><cite>Software Abstractions</cite></a> is equally worth reading, though I suspect far fewer people will.  Jackson is an advocate of formal methods, i.e., he believes that programmers should draw up mathematical specifications of what they want, then derive programs from them in rigorous, checkable ways.  This idea has been around for longer than I've been programming; what makes Jackson's approach different is a more-approachable-than-usual notation called Alloy, and the tools that accompany it.

The Alloy model checker relies on recent advances in constraint programming and other techniques to search for counter-examples or contradictions in requirements.  This allows developers to build their models incrementally, checking them as they go.  Jackson calls the result "lightweight formal methods", or "agile modeling", and while I don't think it would appeal to most agilistas, it's certainly a lot easier to use than the systems I wrestled with as a grad student. Readers will need more than passing familiarity with first-order logic and discrete mathematics in order to get through this book, but it's the best introduction I've seen yet to a programming methodology that just might, maybe, win out in the long run.

<hr />Kurt Bittner and Ian Spence: <a href="http://www.amazon.com/gp/product/032126889X"><cite>Managing Iterative Software Development Projects</cite></a>. Addison-Wesley, 2006, 032126889X, 672 pages.Ian Gorton: <a href="http://www.amazon.com/gp/product/3540287132"><cite>Essential Software Architecture</cite></a>. Springer, 2006, 3540287132, 284 pages.

Daniel Jackson: <a href="http://www.amazon.com/gp/product/0262101149"><cite>Software Abstractions</cite></a>. MIT Press, 2006, 0262101149, 504 pages.

Per Kroll and Bruce MacIsaac: <a href="http://www.amazon.com/gp/product/0321321308"><cite>Agility and Discipline Made Easy: Practices from OpenUP and RUP</cite></a>. Addison-Wesley, 2006, 0321321308, 448 pages.

Ronald Mak: <a href="http://www.amazon.com/gp/product/0471789658"><cite>The Martian Principles</cite></a>. Wiley, 2006, 0471789658, 138 pages.
