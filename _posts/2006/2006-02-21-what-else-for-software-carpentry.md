---
title: "What Else for Software Carpentry?"
date: 2006-02-21 14:18:19
year: 2006
---
16 lectures are now in place (more or less), which means I have 8 more to do.  The syllabus shows what I've covered already; my current plans include:
<ul>
	<li>unit testing</li>
	<li>XML</li>
	<li>SQL</li>
	<li>more SQL</li>
	<li>small-team development process</li>
</ul>
What do you think the other three should cover (keeping in mind that this is supposed to be a course on basic software engineering, rather than scientific programming)?  Options include:
<ol>
	<li>Basic web programming, with much-revised versions of client, server, and security</li>
	<li>Integration, including:
<ul>
	<li>wrapping C code so that it can be called from Python</li>
	<li>using popen() and its ilk to run external programs</li>
	<li>(probably) something on refactoring to make code more testable (as per Feathers' excellent <a href="http://www.third-bit.com/reading.html#feathers-legacy-code">Working Effectively with Legacy Code</a></li>
</ul>
</li>
	<li>Three lecture-length examples, building very simple versions of core tools that haven't been covered elsewhere:
<ul>
	<li>data lineage</li>
	<li>continuous integration</li>
	<li>data consistency checking</li>
</ul>
</li>
	<li>Give in, and do the scientific programming stuff anyway:
<ul>
	<li>floating-point arithmetic</li>
	<li>Python's Numeric package</li>
	<li>data visualization</li>
</ul>
</li>
	<li>Scrap the single lecture on development process, and put in four full lectures on the subject
<ul>
	<li>XP</li>
	<li>UML-based processes (probably ICONIX)</li>
	<li>something else (not entirely sure what)</li>
</ul>
</li>
	<li>Something else entirely --- suggestions would be very welcome.</li>
</ol>
Please let me know what you think.
